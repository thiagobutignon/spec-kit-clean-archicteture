metadata:
  generated: 2025-10-05T14:40:47.386Z
  source: ./src
  tool: The Regent Pattern Extractor
  version: 1.0.0
patterns:
  domain: []
  data: []
  infra: []
  presentation:
    - id: CA001
      name: domain-importing-data-layer
      regex: ^.*\/domain\/.*import.*[\'\"]\.\.\/\.\.\/data\/
      severity: critical
      description: Domain layer must not import from data layer - violates Clean
        Architecture dependency rule
      examples:
        - violation: |-
            // domain/usecases/add-account.ts
            import { Hasher } from '@/data/protocols'
          fix: |-
            // domain/usecases/add-account.ts
            // Keep domain layer pure - define only interfaces
            export interface AddAccount {
              add: (params: Params) => Promise<Result>
            }
    - id: CA002
      name: domain-importing-infra-layer
      regex: ^.*\/domain\/.*import.*[\'\"]\.\.\/\.\.\/infra\/
      severity: critical
      description: Domain layer must not import from infrastructure layer - violates
        Clean Architecture
      examples:
        - violation: |-
            // domain/usecases/authentication.ts
            import { BcryptAdapter } from '@/infra/cryptography'
          fix: |-
            // domain/usecases/authentication.ts
            export interface Authentication {
              auth: (params: Params) => Promise<Result>
            }
    - id: CA003
      name: domain-importing-presentation-layer
      regex: ^.*\/domain\/.*import.*[\'\"]\.\.\/\.\.\/presentation\/
      severity: critical
      description: Domain layer must not import from presentation layer - violates
        Clean Architecture
      examples:
        - violation: |-
            // domain/models/account.ts
            import { HttpResponse } from '@/presentation/protocols'
          fix: |-
            // domain/models/account.ts
            export type Account = {
              id: string
              name: string
            }
    - id: CA004
      name: presentation-importing-infra-layer
      regex: ^.*\/presentation\/.*import.*[\'\"]\.\.\/\.\.\/infra\/
      severity: critical
      description: Presentation layer should depend on abstractions from domain/data,
        not concrete infrastructure
      examples:
        - violation: |-
            // presentation/controllers/signup.ts
            import { MongoRepository } from '@/infra/db/mongodb'
          fix: |-
            // presentation/controllers/signup.ts
            import { AddAccount } from '@/domain/usecases'

            class SignUpController {
              constructor(private readonly addAccount: AddAccount) {}
            }
    - id: CA005
      name: external-dependency-in-domain
      regex: ^.*\/domain\/.*import.*[\'\"](axios|express|mongodb|bcrypt|jwt|validator)
      severity: critical
      description: Domain layer must not import external libraries - should be
        framework-independent
      examples:
        - violation: |-
            // domain/usecases/fetch-data.ts
            import axios from 'axios'
          fix: |-
            // domain/protocols/http-client.ts
            export interface HttpClient {
              get: (url: string) => Promise<any>
            }
            // infra/http/axios-adapter.ts
            import axios from 'axios'
            export class AxiosAdapter implements HttpClient {}
    - id: CA006
      name: controller-without-interface-implementation
      regex: export class \w+Controller(?!.*implements Controller)
      severity: high
      description: Controllers must implement Controller interface for consistency
      examples:
        - violation: |-
            export class SignUpController {
              async handle(request: any) {}
            }
          fix: >-
            export class SignUpController implements Controller {
              async handle(request: SignUpController.Request): Promise<HttpResponse> {}
            }
    - id: CA007
      name: middleware-without-interface-implementation
      regex: export class \w+Middleware(?!.*implements Middleware)
      severity: high
      description: Middlewares must implement Middleware interface for consistency
      examples:
        - violation: |-
            export class AuthMiddleware {
              async handle(request: any) {}
            }
          fix: >-
            export class AuthMiddleware implements Middleware {
              async handle(request: AuthMiddleware.Request): Promise<HttpResponse> {}
            }
    - id: CA008
      name: usecase-missing-interface
      regex: export class Db\w+(?!.*implements \w+)
      severity: high
      description: Use cases should implement domain interfaces for DIP compliance
      examples:
        - violation: |-
            export class DbAddAccount {
              async add(params: any) {}
            }
          fix: >-
            export class DbAddAccount implements AddAccount {
              async add(params: AddAccount.Params): Promise<AddAccount.Result> {}
            }
    - id: NC001
      name: controller-naming-convention
      regex: export class (?!.*Controller$)\w+ implements Controller
      severity: medium
      description: Controllers must end with 'Controller' suffix
      examples:
        - violation: export class SignUp implements Controller {}
          fix: export class SignUpController implements Controller {}
    - id: NC002
      name: usecase-implementation-naming
      regex: export class (?!Db)\w+ implements (AddAccount|Authentication|LoadSurveys)
      severity: medium
      description: Data layer use case implementations should be prefixed with 'Db'
      examples:
        - violation: export class AddAccountImpl implements AddAccount {}
          fix: export class DbAddAccount implements AddAccount {}
    - id: NC003
      name: repository-naming-convention
      regex: export class (?!.*Repository$)\w+ implements \w+Repository
      severity: medium
      description: Repository implementations must end with 'Repository' suffix
      examples:
        - violation: export class MongoAccount implements AddAccountRepository {}
          fix: export class AccountMongoRepository implements AddAccountRepository {}
    - id: TDD001
      name: test-without-describe-block
      regex: ^(?!.*describe\()[\s\S]*test\(
      severity: medium
      description: Tests should be organized within describe blocks
      examples:
        - violation: test('should return 200', () => {})
          fix: |-
            describe('SignUpController', () => {
              test('should return 200', () => {})
            })
    - id: TDD002
      name: test-naming-convention-should
      regex: test\(['"](?!Should )
      severity: low
      description: Test descriptions should start with 'Should' for consistency
      examples:
        - violation: test('returns 200 on success', async () => {})
          fix: test('Should return 200 on success', async () => {})
    - id: TDD003
      name: missing-makesut-factory
      regex: describe\([^)]+\)[\s\S]{0,200}const \w+ = new \w+\(
      severity: medium
      description: Tests should use makeSut factory pattern for DRY and consistency
      examples:
        - violation: |-
            describe('SignUpController', () => {
              test('test', () => {
                const controller = new SignUpController(dep1, dep2)
              })
            })
          fix: |-
            describe('SignUpController', () => {
              const makeSut = () => {
                const dep = new Dep()
                const sut = new SignUpController(dep)
                return { sut, dep }
              }
              test('test', () => {
                const { sut } = makeSut()
              })
            })
    - id: TDD004
      name: sut-variable-naming
      regex: const (?!sut)[a-z]\w+ = new \w+Controller\(
      severity: low
      description: System under test should be named 'sut' for clarity
      examples:
        - violation: const controller = new SignUpController()
          fix: const sut = new SignUpController()
    - id: TDD005
      name: spy-suffix-naming
      regex: "const (\\w+)(?<!Spy): \\w+ = new \\w+\\(\\)"
      severity: low
      description: Test doubles should use 'Spy' suffix for clarity
      examples:
        - violation: const validation = new ValidationStub()
          fix: const validationSpy = new ValidationSpy()
    - id: TDD006
      name: missing-error-test
      regex: describe[\s\S]*?export class \w+Controller[\s\S]*?(?!test\([^)]*throw)
      severity: medium
      description: Controllers should have tests for error scenarios
      examples:
        - violation: |-
            describe('Controller', () => {
              test('Should return 200', () => {})
            })
          fix: >-
            describe('Controller', () => {
              test('Should return 500 if dependency throws', async () => {
                const { sut, dependency } = makeSut()
                jest.spyOn(dependency, 'method').mockImplementationOnce(throwError)
                const response = await sut.handle(mockRequest())
                expect(response).toEqual(serverError(new Error()))
              })
            })
    - id: SOLID001
      name: srp-multiple-responsibilities
      regex: class \w+ implements \w+, \w+, \w+, \w+
      severity: high
      description: Class implements too many interfaces - possible SRP violation
      examples:
        - violation: class UserService implements AddUser, UpdateUser, DeleteUser,
            ValidateUser {}
          fix: |-
            class AddUserService implements AddUser {}
            class UpdateUserService implements UpdateUser {}
            class DeleteUserService implements DeleteUser {}
    - id: SOLID002
      name: dip-concrete-dependency
      regex: constructor\([^)]*new \w+\(
      severity: critical
      description: Constructor instantiates dependencies - violates Dependency
        Inversion Principle
      examples:
        - violation: |-
            constructor() {
              this.hasher = new BcryptAdapter(12)
            }
          fix: "constructor(private readonly hasher: Hasher) {}"
    - id: SOLID003
      name: dip-importing-concrete-implementation
      regex: import.*\{[^}]*(Adapter|Mongo|Bcrypt|Jwt)[^}]*\}.*from.*(?!infra)
      severity: high
      description: Importing concrete implementations outside infra layer - violates DIP
      examples:
        - violation: |-
            // data/usecases/db-auth.ts
            import { BcryptAdapter } from '@/infra/cryptography'
          fix: |-
            // data/usecases/db-auth.ts
            import { Hasher } from '@/data/protocols'

            class DbAuth {
              constructor(private readonly hasher: Hasher) {}
            }
    - id: SOLID004
      name: ocp-modification-detection
      regex: if\s*\([^)]*instanceof\s+\w+\)
      severity: medium
      description: Type checking with instanceof suggests OCP violation - use polymorphism
      examples:
        - violation: |-
            if (validator instanceof EmailValidator) {
              // handle email
            } else if (validator instanceof PhoneValidator) {
              // handle phone
            }
          fix: |-
            // Use polymorphism
            validator.validate(input)
    - id: SOLID005
      name: isp-fat-interface
      regex: export interface \w+
        \{[^}]*\n[^}]*\n[^}]*\n[^}]*\n[^}]*\n[^}]*\n[^}]*\n[^}]*\n
      severity: medium
      description: Interface with many methods may violate Interface Segregation Principle
      examples:
        - violation: |-
            export interface UserRepository {
              add(): void
              update(): void
              delete(): void
              findById(): void
              findByEmail(): void
              validate(): void
              encrypt(): void
            }
          fix: |-
            export interface AddUserRepository { add(): void }
            export interface UpdateUserRepository { update(): void }
            export interface LoadUserRepository { findById(): void }
    - id: DRY001
      name: duplicated-error-handling
      regex: (try \{[\s\S]*?catch[\s\S]*?serverError[\s\S]*?\})[\s\S]*?\1
      severity: medium
      description: Duplicated try-catch pattern - extract to decorator or base class
      examples:
        - violation: |-
            async handle() {
              try {
                // logic
              } catch (error) {
                return serverError(error)
              }
            }
          fix: |-
            // Use decorator pattern
            export class LogControllerDecorator implements Controller {
              constructor(private readonly controller: Controller) {}
              async handle(request: any): Promise<HttpResponse> {
                const response = await this.controller.handle(request)
                if (response.statusCode === 500) {
                  // handle error
                }
                return response
              }
            }
    - id: DRY002
      name: duplicated-validation-check
      regex: (const error = this\.validation\.validate[\s\S]*?if
        \(error\)[\s\S]*?return badRequest[\s\S]*?\})[\s\S]*?\1
      severity: high
      description: Duplicated validation pattern across controllers
      examples:
        - violation: |-
            // Multiple controllers with same validation code
            const error = this.validation.validate(request)
            if (error) return badRequest(error)
          fix: |-
            // Extract to base controller or use decorator
            abstract class BaseController {
              protected validateRequest(request: any): HttpResponse | null {
                const error = this.validation.validate(request)
                return error ? badRequest(error) : null
              }
            }
    - id: DP001
      name: factory-pattern-missing
      regex: new \w+Controller\([^)]*new \w+\(
      severity: medium
      description: Manual instantiation of dependencies - use Factory pattern
      examples:
        - violation: const controller = new SignUpController(new DbAddAccount())
          fix: |-
            // main/factories/signup-controller-factory.ts
            export const makeSignUpController = (): Controller => {
              const addAccount = makeDbAddAccount()
              return new SignUpController(addAccount)
            }
    - id: DP002
      name: decorator-pattern-usage
      regex: export class \w+Decorator implements \w+
      severity: low
      description: Decorator pattern detected - ensure proper delegation
      examples:
        - violation: |-
            class LogDecorator implements Controller {
              handle() { /* no delegation */ }
            }
          fix: |-
            class LogControllerDecorator implements Controller {
              constructor(private readonly controller: Controller) {}
              async handle(request: any) {
                const response = await this.controller.handle(request)
                // add logging
                return response
              }
            }
    - id: DP003
      name: composite-pattern-validation
      regex: class \w+Composite implements \w+
      severity: low
      description: Composite pattern detected - ensure iteration over children
      examples:
        - violation: |-
            class ValidationComposite implements Validation {
              validate() { /* no iteration */ }
            }
          fix: |-
            class ValidationComposite implements Validation {
              constructor(private readonly validations: Validation[]) {}
              validate(input: any): Error {
                for (const validation of this.validations) {
                  const error = validation.validate(input)
                  if (error) return error
                }
              }
            }
    - id: DP004
      name: repository-pattern-naming
      regex: export interface \w+Repository \{[^}]*\b(save|persist|store)\b
      severity: low
      description: Repository methods should use domain language, not persistence terms
      examples:
        - violation: |-
            export interface AccountRepository {
              save(account: Account): Promise<void>
            }
          fix: |-
            export interface AddAccountRepository {
              add(account: AddAccountRepository.Params): Promise<boolean>
            }
    - id: AP001
      name: singleton-antipattern
      regex: private static instance:[\s\S]*?getInstance\(\)
      severity: high
      description: Singleton pattern detected - makes testing difficult, use
        dependency injection
      examples:
        - violation: |-
            class Database {
              private static instance: Database
              static getInstance() {
                if (!this.instance) this.instance = new Database()
                return this.instance
              }
            }
          fix: |-
            // Use dependency injection
            class Database {}
            // In factory
            export const makeDatabaseConnection = (): Database => new Database()
    - id: AP002
      name: god-object-detection
      regex: class \w+ \{[\s\S]{2000,}\}
      severity: critical
      description: Class is too large (God Object) - violates SRP, split into smaller
        classes
      examples:
        - violation: |-
            class UserManager {
              // 100+ methods
            }
          fix: |-
            class AddUser {}
            class UpdateUser {}
            class DeleteUser {}
            class LoadUser {}
    - id: SEC001
      name: missing-input-validation
      regex: async handle\s*\([^)]*\):[^{]*\{(?![\s\S]*validation\.validate)
      severity: high
      description: Controller handle method missing input validation
      examples:
        - violation: |-
            async handle(request: any): Promise<HttpResponse> {
              const result = await this.usecase.execute(request)
              return ok(result)
            }
          fix: |-
            async handle(request: Request): Promise<HttpResponse> {
              const error = this.validation.validate(request)
              if (error) return badRequest(error)
              const result = await this.usecase.execute(request)
              return ok(result)
            }
    - id: SEC002
      name: missing-error-handling
      regex: async handle\s*\([^)]*\):[^{]*\{(?![\s\S]*try[\s\S]*catch)
      severity: critical
      description: Async handle method missing try-catch error handling
      examples:
        - violation: |-
            async handle(request: any): Promise<HttpResponse> {
              const result = await this.usecase.execute(request)
              return ok(result)
            }
          fix: |-
            async handle(request: any): Promise<HttpResponse> {
              try {
                const result = await this.usecase.execute(request)
                return ok(result)
              } catch (error) {
                return serverError(error)
              }
            }
    - id: TYPE001
      name: any-type-usage
      regex: :\s*any(?!\[\])
      severity: medium
      description: Avoid using 'any' type - use specific types or generics
      examples:
        - violation: "handle(request: any): Promise<HttpResponse>"
          fix: |-
            handle(request: SignUpController.Request): Promise<HttpResponse>

            export namespace SignUpController {
              export type Request = {
                name: string
                email: string
                password: string
              }
            }
    - id: TYPE002
      name: namespace-for-types
      regex: export class (\w+)(?![\s\S]*export namespace \1)
      severity: low
      description: Classes should use namespace pattern for associated types
      examples:
        - violation: |-
            export class SignUpController implements Controller {
              handle(request: SignUpRequest) {}
            }
            export type SignUpRequest = {}
          fix: |-
            export class SignUpController implements Controller {
              handle(request: SignUpController.Request) {}
            }

            export namespace SignUpController {
              export type Request = {
                name: string
                email: string
              }
            }
    - id: PERF001
      name: missing-readonly-modifier
      regex: "constructor\\s*\\([^)]*private (?!readonly)\\w+:"
      severity: low
      description: Constructor dependencies should be readonly for immutability
      examples:
        - violation: "constructor(private validation: Validation) {}"
          fix: "constructor(private readonly validation: Validation) {}"
    - id: ERR001
      name: generic-error-return
      regex: return serverError\(new Error\(\)\)
      severity: medium
      description: Return specific error instead of generic Error
      examples:
        - violation: |-
            catch (error) {
              return serverError(new Error())
            }
          fix: |-
            catch (error) {
              return serverError(error)
            }
    - id: ERR002
      name: custom-error-naming
      regex: export class (?!.*Error$)\w+ extends Error
      severity: low
      description: Custom error classes should end with 'Error' suffix
      examples:
        - violation: export class MissingParam extends Error {}
          fix: export class MissingParamError extends Error {}
    - id: COMP001
      name: deep-nesting
      regex: if[^{]*\{[^}]*if[^{]*\{[^}]*if[^{]*\{[^}]*if
      severity: medium
      description: Deep nesting detected - refactor for better readability
      examples:
        - violation: |-
            if (a) {
              if (b) {
                if (c) {
                  if (d) {}
                }
              }
            }
          fix: |-
            if (!a) return
            if (!b) return
            if (!c) return
            if (!d) return
            // main logic
    - id: COMP002
      name: early-return-pattern
      regex: if \([^)]*\) \{[\s\S]*return[\s\S]*\}[\s\S]*else \{
      severity: low
      description: Use early return instead of else block after return
      examples:
        - violation: |-
            if (error) {
              return badRequest(error)
            } else {
              return ok(data)
            }
          fix: |-
            if (error) {
              return badRequest(error)
            }
            return ok(data)
    - id: TEST001
      name: expect-assertions-count
      regex: test\([^{]*\{(?![\s\S]*expect\.assertions)
      severity: low
      description: Async tests should specify expected assertion count
      examples:
        - violation: |-
            test('Should call method', async () => {
              await sut.handle()
              expect(spy).toHaveBeenCalled()
            })
          fix: |-
            test('Should call method', async () => {
              expect.assertions(1)
              await sut.handle()
              expect(spy).toHaveBeenCalled()
            })
    - id: TEST002
      name: mock-implementation-inline
      regex: jest\.spyOn[^.]*\.mockImplementation\([^)]*=>
      severity: low
      description: Extract mock implementations to separate functions for clarity
      examples:
        - violation: jest.spyOn(obj, 'method').mockImplementation(() => { /* complex logic
            */ })
          fix: |-
            const mockMethod = () => { /* complex logic */ }
            jest.spyOn(obj, 'method').mockImplementation(mockMethod)
    - id: HTTP001
      name: http-helper-consistency
      regex: "return \\{[\\s\\S]*statusCode:[\\s\\S]*body:"
      severity: medium
      description: Use HTTP helper functions instead of manual response objects
      examples:
        - violation: |-
            return {
              statusCode: 200,
              body: data
            }
          fix: return ok(data)
    - id: HTTP002
      name: missing-status-code-helper
      regex: "statusCode:
        (201|204|400|401|403|404|500)(?![\\s\\S]{0,100}(created|noContent|badRe\
        quest|unauthorized|forbidden|notFound|serverError))"
      severity: low
      description: Create helper function for commonly used HTTP status codes
      examples:
        - violation: "return { statusCode: 204, body: null }"
          fix: |-
            export const noContent = (): HttpResponse => ({
              statusCode: 204,
              body: null
            })
  main: []
  tdd: []
  solid: []
  dry: []
  design_patterns: []
  kiss_yagni: []
  cross_cutting: []
