# AI-NOTE: This YAML file is specifically for generating DATA LAYER following TDD principles.
# This implements the business rules from Domain Layer through abstract protocols.
# CRITICAL: Data Layer is the implementation layer for use cases defined in Domain Layer.
#
# INTELLIGENT RLHF SCORING SYSTEM:
# The system uses Reinforcement Learning from Human Feedback to score execution quality:
# -2: CATASTROPHIC - Architecture violations, implementation before tests, incorrect TDD order
# -1: RUNTIME ERROR - Lint failures, test failures, git operation problems
#  0: LOW CONFIDENCE - System is uncertain, avoids hallucinations
# +1: GOOD - Task complete but missing TDD elements or architectural patterns
# +2: PERFECT - Exceptional TDD execution, Clean Architecture, protocol abstractions
#
# QUALITY INDICATORS FOR +2 SCORE:
# - STRICT TDD ORDER: Test ‚Üí Mock ‚Üí Protocol ‚Üí Implementation (NON-NEGOTIABLE)
# - Protocol abstractions for all external dependencies
# - Comprehensive test coverage with spy pattern
# - Feature-based architecture structure
# - No direct external library imports
# - Perfect JSDoc documentation
#
version: '3.0.0'
# AI-NOTE: Update these fields to describe the specific feature and data layer implementation.
metadata:
  title: '__FEATURE_NAME_PASCAL_CASE__ Data Layer Implementation'
  description: 'TDD implementation of use cases for __FEATURE_NAME_LOWER_CASE__ feature following Clean Architecture principles.'
  source: 'DATA_TEMPLATE_REFACTORED.yaml'
  # AI-NOTE: This should be replaced with the current date, e.g., YYYY-MM-DD.
  lastUpdated: '__CURRENT_DATE__'
  # AI-NOTE: Data layer specifically implements domain use cases
  layers: ['data']
  tdd_principles:
    - 'Test First - Never write implementation before tests'
    - 'Red-Green-Refactor cycle'
    - 'Tests define the contract'
    - 'Mock all external dependencies'
  # AI-NOTE: Define ubiquitous language for +2 RLHF score (data layer context)
  ubiquitousLanguage:
    - term: '__PROTOCOL_NAME__'
      definition: '__PROTOCOL_BUSINESS_PURPOSE__'
    - term: '__USE_CASE_IMPLEMENTATION__'
      definition: '__IMPLEMENTATION_BUSINESS_RESPONSIBILITY__'
    - term: '__EXTERNAL_DEPENDENCY__'
      definition: '__DEPENDENCY_ABSTRACTION_PURPOSE__'

# AI-NOTE: Define protocols needed for +2 RLHF score
required_protocols:
  - category: 'db'
    protocols: ['__ENTITY__Repository', 'Check__ENTITY__Repository']
  - category: 'http'
    protocols: ['HttpClient']
  - category: 'cryptography'
    protocols: ['Hasher', 'HashComparer', 'Encrypter', 'Decrypter']
  - category: 'cache'
    protocols: ['SetStorage', 'GetStorage']

# AI-NOTE: Feature-based structure for data layer
structure:
  basePath: 'src/features/__FEATURE_NAME_KEBAB_CASE__'
  data_layer:
    folders:
      - 'protocols/db'           # Database protocol interfaces
      - 'protocols/http'         # HTTP client protocol interfaces
      - 'protocols/cache'        # Cache protocol interfaces
      - 'protocols/cryptography' # Cryptography protocol interfaces
      - 'usecases'              # Use case implementations
      - 'models'                # Data-specific models (optional)
  test_structure:
    basePath: 'tests/features/__FEATURE_NAME_KEBAB_CASE__'
    folders:
      - 'data/mocks'            # Mock implementations for testing
      - 'data/usecases'         # Use case tests

# ------------------------------------------------------------------------------
# ARCHITECTURAL RULES SECTION
# These rules define the Data Layer boundaries and dependencies
# ------------------------------------------------------------------------------

architecture:
  # Data Layer dependency rules
  dependency_rules:
    data:
      can_import_from: ['domain']  # Only domain interfaces and types
      cannot_import_from: ['infrastructure', 'presentation', 'external']
      must_use_protocols: true    # All external deps through protocols

  # Data Layer principles
  principles:
    - "Implementation: Business logic implementation through abstract protocols"
    - "TDD: Tests first, implementation last - NO EXCEPTIONS"
    - "Protocols: All external dependencies abstracted through interfaces"
    - "Independence: No direct imports of external libraries or frameworks"

# ------------------------------------------------------------------------------
# AI-NOTE: IMMUTABLE SECTIONS AHEAD.
# TDD and Data Layer rules are critical for correct implementation.
# ------------------------------------------------------------------------------

# Data layer specific rules
data_layer_rules:
  tdd_execution_order:
    1: 'Generate test files (.spec.ts) - FIRST AND MANDATORY'
    2: 'Generate mock/spy implementations - SECOND'
    3: 'Generate protocol interfaces - THIRD'
    4: 'Generate use case implementations - FOURTH AND LAST'

  forbidden_violations:
    - 'NEVER generate implementation before tests'
    - 'NEVER import external libraries directly'
    - 'NEVER skip the spy/mock generation step'
    - 'NEVER create protocols without corresponding mocks'

  allowed:
    - 'Use case implementations following domain contracts'
    - 'Protocol interfaces for external dependencies'
    - 'Mock/Spy implementations for testing'
    - 'Data models for transformation (when needed)'

  forbidden:
    - 'Direct imports from axios, fetch, bcrypt, jwt, etc.'
    - 'Framework-specific code (React, Express, etc.)'
    - 'Business logic in domain layer (that belongs here)'
    - 'Implementation before tests (TDD violation)'

# Protocol rules
protocol_rules:
  should:
    - 'Abstract all external dependencies'
    - 'Be categorized by concern (db, http, cache, crypto)'
    - 'Have corresponding mock implementations'
    - 'Use generic interfaces for flexibility'
    - 'Be well documented with JSDoc'

  should_not:
    - 'Expose implementation details'
    - 'Import external libraries'
    - 'Contain business logic'
    - 'Be specific to one implementation'

# Use case implementation rules
usecase_implementation_rules:
  should:
    - 'Implement domain use case interfaces'
    - 'Use dependency injection pattern'
    - 'Follow error handling patterns'
    - 'Have comprehensive test coverage'
    - 'Use execute method as standard'

  should_not:
    - 'Import external libraries directly'
    - 'Contain framework-specific code'
    - 'Be tested after implementation'
    - 'Skip error scenarios in tests'

# Test rules (specific to data layer)
test_rules:
  should:
    - 'Use Spy pattern for dependency mocking'
    - 'Test all dependency interactions'
    - 'Cover error scenarios with throwError helper'
    - 'Use makeSut factory pattern'
    - 'Test parameter passing and return values'
    - 'Use vitest framework only'

  should_not:
    - 'Make real external calls'
    - 'Use Jest (vitest only)'
    - 'Test implementation details'
    - 'Skip error scenarios'

# Use case rules (adapted for data layer implementations)
use_case_rules:
  should:
    - 'Implement domain use case interfaces (not define them)'
    - 'Have EXACTLY ONE responsibility (one business operation)'
    - 'Use dependency injection for all external dependencies'
    - 'Abstract external dependencies through protocols'
    - 'Handle errors properly and wrap infrastructure errors'
    - 'Be framework agnostic (no React, Express, etc.)'
    - 'Follow the execute method pattern'
    - 'Have comprehensive test coverage'

  should_not:
    - 'Import external libraries directly (use protocols)'
    - 'Contain framework-specific code'
    - 'Import from presentation or infrastructure layers'
    - 'Execute multiple use cases in one class'
    - 'Expose infrastructure implementation details'
    - 'Be implemented before tests are written (TDD violation)'

# Error rules (adapted for data layer error handling)
error_rules:
  should:
    - 'Catch and wrap infrastructure errors appropriately'
    - 'Re-throw domain errors without modification'
    - 'Convert technical errors to domain errors when appropriate'
    - 'Use meaningful error messages for business context'
    - 'Log errors appropriately without exposing sensitive data'
    - 'Handle protocol failures gracefully'

  should_not:
    - 'Expose infrastructure error details to domain layer'
    - 'Swallow errors silently'
    - 'Include sensitive information in error messages'
    - 'Throw generic errors without context'
    - 'Let infrastructure errors bubble up unchanged'
    - 'Include HTTP status codes in domain errors'

# Test helper rules (from TEMPLATE.yaml)
test_helper_rules:
  should:
    - 'Create mock/stub implementations of use cases'
    - 'Generate fake test data'
    - 'Be pure functions that return consistent data'
    - 'Help reduce test boilerplate'
    - 'Use ONLY Vitest (Jest is prohibited)'

  should_not:
    - 'Make real API calls or database queries'
    - 'Depend on external services'
    - 'Contain test assertions (those belong in test files)'
    - 'Have side effects or maintain state'
    - 'Use Jest (use Vitest instead)'

# Layer-specific rules (missing section)
layer_rules:
  data_layer:
    primary_responsibility: 'Implement domain use cases through abstract protocols'
    can_import_from: ['domain']
    cannot_import_from: ['infrastructure', 'presentation', 'external']
    must_implement: ['Domain use case interfaces']
    must_abstract: ['All external dependencies through protocols']

# ------------------------------------------------------------------------------
# DRY REFACTORED: REUSABLE TEMPLATES AND SCRIPTS
# ------------------------------------------------------------------------------

# Reusable validation scripts to eliminate repetition
validation_scripts:
  verify_file_exists: &verify_file |
    echo "üîç Verifying file creation..."
    if [ ! -f "$FILE_PATH" ]; then
      echo "‚ùå ERROR: File was not created at $FILE_PATH"
      exit 1
    fi
    echo "‚úÖ File created successfully at $FILE_PATH"

  stage_and_commit: &stage_commit |
    echo "üì¶ Staging file..."
    git add "$FILE_PATH"
    echo "üíæ Committing..."
    git commit -m "$COMMIT_MESSAGE"
    if [ $? -ne 0 ]; then
      echo "‚ùå COMMIT FAILED"
      exit 1
    fi
    echo "‚úÖ Committed successfully"

  lint_check: &lint_check |
    echo "üîç Running lint check..."
    yarn lint
    if [ $? -ne 0 ]; then
      echo "‚ùå LINT FAILED - Attempting auto-fix..."
      yarn lint --fix
      if [ $? -ne 0 ]; then
        echo "‚ùå AUTO-FIX FAILED - Manual intervention required"
        exit 1
      fi
      echo "‚úÖ Lint errors auto-fixed, validating again..."
      yarn lint
      if [ $? -ne 0 ]; then
        echo "‚ùå LINT STILL FAILING - Manual fixes needed"
        exit 1
      fi
    fi
    echo "‚úÖ Lint passed"

  test_check: &test_check |
    echo "üß™ Running tests with coverage..."
    yarn test --coverage
    if [ $? -ne 0 ]; then
      echo "‚ùå TESTS FAILED"
      exit 1
    fi
    echo "‚úÖ Tests passed"

  verify_folder_structure: &verify_folders |
    echo "‚úÖ Verifying folder structure..."
    for folder in $FOLDERS; do
      if [ ! -d "$folder" ]; then
        echo "‚ùå ERROR: Folder $folder was not created."
        exit 1
      fi
    done
    echo "‚úÖ All folders exist."

# Reusable mock templates to eliminate repetition
mock_templates:
  spy_base_template: &spy_base |
    /** Stores the parameters for assertion */
    __PARAM_PROPERTIES__

    /** Controls the return value for testing */
    __RESULT_PROPERTY__

    /** Tracks how many times the method was called */
    callCount = 0

    /** Stores the history of all operations */
    __HISTORY_PROPERTY__

  spy_method_template: &spy_method |
    /**
     * Mock implementation of the __METHOD_NAME__ method.
     * __METHOD_DESCRIPTION__
     * @returns Promise resolving to the controlled test result
     */
    async __METHOD_NAME__ (__PARAMS__): Promise<__RETURN_TYPE__> {
      this.callCount++
      __STORE_PARAMS__
      __STORE_HISTORY__
      return __RETURN_VALUE__
    }

# Common step properties to reduce repetition
step_defaults: &step_defaults
  status: 'PENDING'
  rlhf_score: null
  execution_log: ''

# ------------------------------------------------------------------------------
# IMPLEMENTATION STEPS - TDD EXECUTION ORDER
# CRITICAL: These steps MUST be executed in this exact order
# ------------------------------------------------------------------------------

steps:
  # === GIT WORKFLOW ===
  - id: 'create-feature-branch'
    type: 'branch'
    description: 'Create a new feature branch for __FEATURE_NAME_PASCAL_CASE__ data layer'
    <<: *step_defaults
    references:
      - type: 'internal_guideline'
        source: 'GIT_WORKFLOW.md'
        description: 'Following git branching best practices for data layer development.'
    action:
      branch_name: 'feat/__FEATURE_NAME_KEBAB_CASE__-data-layer'
    validation_script: |
      echo "üåø Creating data layer feature branch..."
      # Check if we are on a clean state
      if [ -n "$(git status --porcelain)" ]; then
        echo "‚ö†Ô∏è Warning: You have uncommitted changes. Stashing them..."
        git stash save "Auto-stash before creating data layer branch for __FEATURE_NAME_KEBAB_CASE__"
      fi

      # Create and checkout new feature branch
      BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-data-layer"

      # Check if branch already exists
      if git show-ref --quiet refs/heads/$BRANCH_NAME; then
        echo "‚ö†Ô∏è Branch $BRANCH_NAME already exists. Checking out..."
        git checkout $BRANCH_NAME
      else
        echo "üåø Creating new branch: $BRANCH_NAME"
        git checkout -b $BRANCH_NAME
      fi

      # Verify we're on the correct branch
      CURRENT=$(git branch --show-current)
      if [ "$CURRENT" != "$BRANCH_NAME" ]; then
        echo "‚ùå ERROR: Failed to switch to branch $BRANCH_NAME"
        exit 1
      fi

      echo "‚úÖ Successfully created and switched to branch: $BRANCH_NAME"

  # === DATA LAYER STRUCTURE ===
  - id: 'create-data-structure'
    type: 'folder'
    description: 'Create data layer folder structure'
    <<: *step_defaults
    references:
      - type: 'internal_guideline'
        source: 'ARCHITECTURE.md'
        description: 'Following feature-based data layer structure.'
    action:
      create_folders:
        basePath: 'src/features/__FEATURE_NAME_KEBAB_CASE__/data'
        folders:
          - 'protocols/db'
          - 'protocols/http'
          - 'protocols/cache'
          - 'protocols/cryptography'
          - 'usecases'
          - 'models'
    validation_script: |
      BASE_PATH="src/features/__FEATURE_NAME_KEBAB_CASE__/data"
      FOLDERS="$BASE_PATH/protocols/db $BASE_PATH/protocols/http $BASE_PATH/protocols/cache $BASE_PATH/protocols/cryptography $BASE_PATH/usecases $BASE_PATH/models"
      echo "‚úÖ Verifying folder structure..."
      for folder in $FOLDERS; do
        if [ ! -d "$folder" ]; then
          echo "‚ùå ERROR: Folder $folder was not created."
          exit 1
        fi
      done
      echo "‚úÖ All folders exist."

  # === TEST STRUCTURE ===
  - id: 'create-test-structure'
    type: 'folder'
    description: 'Create test folder structure for data layer'
    <<: *step_defaults
    references:
      - type: 'internal_guideline'
        source: 'TESTING.md'
        description: 'Following TDD structure for data layer tests.'
    action:
      create_folders:
        basePath: 'tests/features/__FEATURE_NAME_KEBAB_CASE__/data'
        folders:
          - 'mocks'
          - 'usecases'
    validation_script: |
      BASE_PATH="tests/features/__FEATURE_NAME_KEBAB_CASE__/data"
      FOLDERS="$BASE_PATH/mocks $BASE_PATH/usecases"
      echo "‚úÖ Verifying folder structure..."
      for folder in $FOLDERS; do
        if [ ! -d "$folder" ]; then
          echo "‚ùå ERROR: Folder $folder was not created."
          exit 1
        fi
      done
      echo "‚úÖ All folders exist."

  # === TDD STEP 1: CREATE TEST FILE FIRST ===
  - id: 'create-test-__PREFIX__-__USE_CASE_NAME_KEBAB__'
    type: 'create_file'
    description: 'TDD Step 1: Create test file for __PREFIX____USE_CASE_NAME__ use case'
    <<: *step_defaults
    references:
      - type: 'external_pattern'
        source: 'context7'
        query: 'test driven development best practices'
        url: 'https://github.com/...'
        description: 'Following TDD red-green-refactor cycle.'
      - type: 'internal_code_analysis'
        source: 'serena'
        tool: 'find_symbol'
        query: '*.spec.ts'
        description: 'Consistent with existing test patterns.'
    path: 'tests/features/__FEATURE_NAME_KEBAB_CASE__/data/usecases/__PREFIX__-__USE_CASE_NAME_KEBAB__.spec.ts'
    template: |
      import { __PREFIX____USE_CASE_NAME__ } from '@/features/__FEATURE_NAME_KEBAB_CASE__/data/usecases'
      import { mock__USE_CASE__Input, throwError } from '@/tests/features/__FEATURE_NAME_KEBAB_CASE__/domain/mocks'
      import { __DEPENDENCY_1__Spy, __DEPENDENCY_2__Spy } from '@/tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks'
      import { describe, test, expect, vi } from 'vitest'

      type SutTypes = {
        sut: __PREFIX____USE_CASE_NAME__
        __DEPENDENCY_1_CAMEL__Spy: __DEPENDENCY_1__Spy
        __DEPENDENCY_2_CAMEL__Spy: __DEPENDENCY_2__Spy
      }

      const makeSut = (): SutTypes => {
        const __DEPENDENCY_1_CAMEL__Spy = new __DEPENDENCY_1__Spy()
        const __DEPENDENCY_2_CAMEL__Spy = new __DEPENDENCY_2__Spy()
        const sut = new __PREFIX____USE_CASE_NAME__(__DEPENDENCY_1_CAMEL__Spy, __DEPENDENCY_2_CAMEL__Spy)
        return {
          sut,
          __DEPENDENCY_1_CAMEL__Spy,
          __DEPENDENCY_2_CAMEL__Spy
        }
      }

      describe('__PREFIX____USE_CASE_NAME__ Usecase', () => {
        test('Should call __DEPENDENCY_1__ with correct values', async () => {
          const { sut, __DEPENDENCY_1_CAMEL__Spy } = makeSut()
          const input = mock__USE_CASE__Input()

          await sut.execute(input)

          expect(__DEPENDENCY_1_CAMEL__Spy.__PROPERTY__).toBe(input.__FIELD__)
        })

        test('Should throw if __DEPENDENCY_1__ throws', async () => {
          const { sut, __DEPENDENCY_1_CAMEL__Spy } = makeSut()
          vi.spyOn(__DEPENDENCY_1_CAMEL__Spy, '__DEPENDENCY_METHOD__').mockImplementationOnce(throwError)

          const promise = sut.execute(mock__USE_CASE__Input())

          await expect(promise).rejects.toThrow()
        })

        test('Should return correct value on success', async () => {
          const { sut } = makeSut()

          const result = await sut.execute(mock__USE_CASE__Input())

          expect(result).toBe(__EXPECTED_VALUE__)
        })
      })
    validation_script: |
      FILE_PATH="tests/features/__FEATURE_NAME_KEBAB_CASE__/data/usecases/__PREFIX__-__USE_CASE_NAME_KEBAB__.spec.ts"
      echo "üîç Verifying file creation..."
      if [ ! -f "$FILE_PATH" ]; then
        echo "‚ùå ERROR: File was not created at $FILE_PATH"
        exit 1
      fi
      echo "‚úÖ File created successfully at $FILE_PATH"

      COMMIT_MESSAGE="test(__FEATURE_NAME_KEBAB_CASE__): add __PREFIX__-__USE_CASE_NAME_KEBAB__ test file (TDD Step 1: red phase)"
      echo "üì¶ Staging file..."
      git add "$FILE_PATH"
      echo "üíæ Committing..."
      git commit -m "$COMMIT_MESSAGE"
      if [ $? -ne 0 ]; then
        echo "‚ùå COMMIT FAILED"
        exit 1
      fi
      echo "‚úÖ Committed successfully"
      echo "‚úÖ TDD Step 1 completed successfully"

  # === TDD STEP 2: CREATE MOCK/SPY IMPLEMENTATIONS ===
  # Using a mock generation pattern for all protocol categories
  - id: 'create-all-mocks'
    type: 'create_multiple_files'
    description: 'TDD Step 2: Create all mock implementations for protocols'
    <<: *step_defaults
    references:
      - type: 'external_pattern'
        source: 'context7'
        query: 'spy pattern testing mocks'
        description: 'Following spy pattern for all dependency mocking.'
    files:
      - path: 'tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/mock-db-repository.ts'
        template: |
          import { __ENTITY__Repository, Check__ENTITY__ByEmailRepository } from '@/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols'

          /**
           * Mock implementation of __ENTITY__Repository for testing purposes.
           * Implements spy pattern to track method calls and control return values.
           */
          export class __ENTITY__RepositorySpy implements __ENTITY__Repository {
            params: __ENTITY__Repository.AddParams
            result = true
            callCount = 0
            paramHistory: __ENTITY__Repository.AddParams[] = []

            async add (data: __ENTITY__Repository.AddParams): Promise<boolean> {
              this.callCount++
              this.params = data
              this.paramHistory.push(data)
              return this.result
            }
          }

          /**
           * Mock implementation for checking entity existence by email.
           */
          export class Check__ENTITY__ByEmailRepositorySpy {
            email: string
            result = false
            callCount = 0
            emailHistory: string[] = []

            async checkByEmail (email: string): Promise<boolean> {
              this.callCount++
              this.email = email
              this.emailHistory.push(email)
              return this.result
            }
          }

      - path: 'tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/mock-http-client.ts'
        template: |
          import { HttpClient } from '@/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols'

          /**
           * Mock implementation of HttpClient for testing purposes.
           */
          export class HttpClientSpy<T = any> implements HttpClient<T> {
            url: string
            method: string
            body?: any
            headers?: Record<string, string>
            response: HttpClient.Result<T> = {
              statusCode: 200,
              body: {} as T
            }
            callCount = 0
            requestHistory: HttpClient.Params[] = []

            async request (data: HttpClient.Params): Promise<HttpClient.Result<T>> {
              this.callCount++
              this.url = data.url
              this.method = data.method
              this.body = data.body
              this.headers = data.headers
              this.requestHistory.push({ ...data })
              return this.response
            }
          }

      - path: 'tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/mock-cryptography.ts'
        template: |
          import { Hasher, HashComparer } from '@/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols'

          /**
           * Mock implementation of Hasher for testing purposes.
           */
          export class HasherSpy implements Hasher {
            digest = 'hashed_password'
            plaintext: string
            callCount = 0
            plaintextHistory: string[] = []

            async hash (plaintext: string): Promise<string> {
              this.callCount++
              this.plaintext = plaintext
              this.plaintextHistory.push(plaintext)
              return this.digest
            }
          }

          /**
           * Mock implementation of HashComparer for testing purposes.
           */
          export class HashComparerSpy implements HashComparer {
            plaintext: string
            digest: string
            result = true
            callCount = 0
            comparisonHistory: Array<{ plaintext: string; digest: string }> = []

            async compare (plaintext: string, digest: string): Promise<boolean> {
              this.callCount++
              this.plaintext = plaintext
              this.digest = digest
              this.comparisonHistory.push({ plaintext, digest })
              return this.result
            }
          }

      - path: 'tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/mock-cache-storage.ts'
        template: |
          import { SetStorage, GetStorage } from '@/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols'

          /**
           * Mock implementation of SetStorage for testing purposes.
           */
          export class SetStorageSpy implements SetStorage {
            key: string
            value: any
            callCount = 0
            setHistory: Array<{ key: string; value: any }> = []

            async set (key: string, value: any): Promise<void> {
              this.callCount++
              this.key = key
              this.value = value
              this.setHistory.push({ key, value })
            }
          }

          /**
           * Mock implementation of GetStorage for testing purposes.
           */
          export class GetStorageSpy implements GetStorage {
            key: string
            value: any = 'cached_value'
            callCount = 0
            getHistory: string[] = []

            async get<T = any> (key: string): Promise<T> {
              this.callCount++
              this.key = key
              this.getHistory.push(key)
              return this.value as T
            }
          }

      - path: 'tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/index.ts'
        template: |
          // Export all mock implementations for easy import
          export * from './mock-db-repository'
          export * from './mock-http-client'
          export * from './mock-cryptography'
          export * from './mock-cache-storage'

    validation_script: |
      echo "üîç TDD Step 2: Validating all mock creations..."
      MOCK_FILES=(
        "tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/mock-db-repository.ts"
        "tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/mock-http-client.ts"
        "tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/mock-cryptography.ts"
        "tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/mock-cache-storage.ts"
        "tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/index.ts"
      )

      for file in "${MOCK_FILES[@]}"; do
        if [ ! -f "$file" ]; then
          echo "‚ùå ERROR: Mock file $file was not created."
          exit 1
        fi
      done
      echo "‚úÖ All mock files created successfully."

      echo "üì¶ Staging all mock files..."
      git add tests/features/__FEATURE_NAME_KEBAB_CASE__/data/mocks/

      echo "üíæ Committing TDD Step 2..."
      git commit -m "test(__FEATURE_NAME_KEBAB_CASE__): add all mock implementations (TDD Step 2: spy pattern)"
      if [ $? -ne 0 ]; then
        echo "‚ùå COMMIT FAILED"
        exit 1
      fi
      echo "‚úÖ TDD Step 2 completed successfully"

  # === TDD STEP 3: CREATE PROTOCOL INTERFACES ===
  - id: 'create-all-protocols'
    type: 'create_multiple_files'
    description: 'TDD Step 3: Create all protocol interfaces'
    <<: *step_defaults
    references:
      - type: 'external_pattern'
        source: 'context7'
        query: 'clean architecture protocol interfaces'
        description: 'Following protocol abstraction patterns.'
    files:
      - path: 'src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/db/__ENTITY_KEBAB__-repository.ts'
        template: |
          /**
           * Repository pattern interface for __ENTITY__ data operations.
           * Provides abstraction for database operations.
           */
          export interface __ENTITY__Repository {
            add: (data: __ENTITY__Repository.AddParams) => Promise<boolean>
          }

          export namespace __ENTITY__Repository {
            export type AddParams = {
              name: string
              email: string
              password: string
            }
          }

          export interface Check__ENTITY__ByEmailRepository {
            checkByEmail: (email: string) => Promise<boolean>
          }

      - path: 'src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/http/http-client.ts'
        template: |
          /**
           * HTTP client protocol interface.
           * Provides abstraction for HTTP operations.
           */
          export interface HttpClient<R = any> {
            request: (data: HttpClient.Params) => Promise<HttpClient.Result<R>>
          }

          export namespace HttpClient {
            export type Params = {
              url: string
              method: 'get' | 'post' | 'put' | 'delete'
              body?: any
              headers?: Record<string, string>
            }

            export type Result<T = any> = {
              statusCode: number
              body?: T
            }
          }

          export enum HttpStatusCode {
            ok = 200,
            noContent = 204,
            badRequest = 400,
            unauthorized = 401,
            forbidden = 403,
            notFound = 404,
            serverError = 500
          }

      - path: 'src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/cryptography/hasher.ts'
        template: |
          /**
           * Hasher protocol interface for cryptographic operations.
           */
          export interface Hasher {
            hash: (plaintext: string) => Promise<string>
          }

          /**
           * Hash comparer protocol interface.
           */
          export interface HashComparer {
            compare: (plaintext: string, digest: string) => Promise<boolean>
          }

      - path: 'src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/cache/storage.ts'
        template: |
          /**
           * Set storage protocol interface for cache operations.
           */
          export interface SetStorage {
            set: (key: string, value: any) => Promise<void>
          }

          /**
           * Get storage protocol interface for cache operations.
           */
          export interface GetStorage {
            get: <T = any>(key: string) => Promise<T>
          }

      - path: 'src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/index.ts'
        template: |
          // Database protocols
          export * from './db/__ENTITY_KEBAB__-repository'

          // HTTP protocols
          export * from './http/http-client'

          // Cryptography protocols
          export * from './cryptography/hasher'

          // Cache protocols
          export * from './cache/storage'

    validation_script: |
      echo "üîç TDD Step 3: Validating all protocol creations..."
      PROTOCOL_FILES=(
        "src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/db/__ENTITY_KEBAB__-repository.ts"
        "src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/http/http-client.ts"
        "src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/cryptography/hasher.ts"
        "src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/cache/storage.ts"
        "src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/index.ts"
      )

      for file in "${PROTOCOL_FILES[@]}"; do
        if [ ! -f "$file" ]; then
          echo "‚ùå ERROR: Protocol file $file was not created."
          exit 1
        fi
      done
      echo "‚úÖ All protocol files created successfully."

      echo "üì¶ Staging all protocol files..."
      git add src/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols/

      echo "üíæ Committing TDD Step 3..."
      git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): add all protocol interfaces (TDD Step 3: abstractions)"
      if [ $? -ne 0 ]; then
        echo "‚ùå COMMIT FAILED"
        exit 1
      fi
      echo "‚úÖ TDD Step 3 completed successfully"

  # === TDD STEP 4: CREATE USE CASE IMPLEMENTATION ===
  - id: 'create-usecase-__PREFIX__-__USE_CASE_NAME_KEBAB__'
    type: 'create_file'
    description: 'TDD Step 4: Create __PREFIX____USE_CASE_NAME__ implementation (GREEN PHASE)'
    <<: *step_defaults
    references:
      - type: 'external_pattern'
        source: 'context7'
        query: 'clean architecture use case implementation'
        description: 'Following Clean Architecture use case implementation.'
    path: 'src/features/__FEATURE_NAME_KEBAB_CASE__/data/usecases/__PREFIX__-__USE_CASE_NAME_KEBAB__.ts'
    template: |
      import type { Add__ENTITY__ } from '@/features/__FEATURE_NAME_KEBAB_CASE__/domain/use-cases'
      import { __ENTITY__Repository, Check__ENTITY__ByEmailRepository, Hasher } from '@/features/__FEATURE_NAME_KEBAB_CASE__/data/protocols'

      /**
       * Implementation of Add__ENTITY__ use case for data layer.
       * Handles __ENTITY__ creation with password hashing and duplicate email validation.
       * Follows TDD implementation pattern with protocol abstractions.
       */
      export class DbAdd__ENTITY__ implements Add__ENTITY__ {
        constructor (
          private readonly hasher: Hasher,
          private readonly add__ENTITY__Repository: __ENTITY__Repository,
          private readonly check__ENTITY__ByEmailRepository: Check__ENTITY__ByEmailRepository
        ) {}

        async add (input: Add__ENTITY__.Params): Promise<Add__ENTITY__.Result> {
          // Step 1: Check if email already exists (business rule)
          const emailExists = await this.check__ENTITY__ByEmailRepository.checkByEmail(input.email)
          if (emailExists) {
            return false
          }

          // Step 2: Hash the password (security requirement)
          const hashedPassword = await this.hasher.hash(input.password)

          // Step 3: Save to repository with hashed password
          const __ENTITY_CAMEL__Data = {
            name: input.name,
            email: input.email,
            password: hashedPassword
          }

          const isAdded = await this.add__ENTITY__Repository.add(__ENTITY_CAMEL__Data)
          return isAdded
        }
      }
    validation_script: |
      FILE_PATH="src/features/__FEATURE_NAME_KEBAB_CASE__/data/usecases/__PREFIX__-__USE_CASE_NAME_KEBAB__.ts"
      echo "üîç Verifying file creation..."
      if [ ! -f "$FILE_PATH" ]; then
        echo "‚ùå ERROR: File was not created at $FILE_PATH"
        exit 1
      fi
      echo "‚úÖ File created successfully at $FILE_PATH"

      echo "üîç Running lint check..."
      yarn lint
      if [ $? -ne 0 ]; then
        echo "‚ùå LINT FAILED - Attempting auto-fix..."
        yarn lint --fix
        if [ $? -ne 0 ]; then
          echo "‚ùå AUTO-FIX FAILED - Manual intervention required"
          exit 1
        fi
        echo "‚úÖ Lint errors auto-fixed, validating again..."
        yarn lint
        if [ $? -ne 0 ]; then
          echo "‚ùå LINT STILL FAILING - Manual fixes needed"
          exit 1
        fi
      fi
      echo "‚úÖ Lint passed"

      echo "üß™ Running tests with coverage..."
      yarn test --coverage
      if [ $? -ne 0 ]; then
        echo "‚ùå TESTS FAILED"
        exit 1
      fi
      echo "‚úÖ Tests passed"

      COMMIT_MESSAGE="feat(__FEATURE_NAME_KEBAB_CASE__): implement __PREFIX____USE_CASE_NAME__ use case (TDD Step 4: green phase)"
      echo "üì¶ Staging file..."
      git add "$FILE_PATH"
      echo "üíæ Committing..."
      git commit -m "$COMMIT_MESSAGE"
      if [ $? -ne 0 ]; then
        echo "‚ùå COMMIT FAILED"
        exit 1
      fi
      echo "‚úÖ Committed successfully"
      echo "‚úÖ TDD Step 4 completed successfully - Full TDD cycle complete!"

  # === REFACTORING STEP (OPTIONAL) ===
  - id: 'refactor-__FILE_TO_MODIFY_KEBAB_CASE__'
    type: 'refactor_file'
    description: 'Refactor __FILE_TO_MODIFY_PASCAL_CASE__ to incorporate new logic'
    <<: *step_defaults
    references:
      - type: 'internal_code_analysis'
        source: 'serena'
        tool: 'find_referencing_symbols'
        query: '__SYMBOL_BEING_CHANGED__'
        description: 'Refactoring this file because it is a primary consumer of the changed `__SYMBOL__` interface.'
    path: 'src/features/__FEATURE_NAME_KEBAB_CASE__/data/path/to/__FILE_TO_MODIFY_KEBAB_CASE__.ts'
    # CRITICAL FOR RLHF SCORE: The template MUST use REPLACE/WITH format for refactor_file steps
    template: |
      <<<REPLACE>>>
      // Old code that AI identified to be replaced
      export type OldType = {
        fieldA: string;
      }
      <<</REPLACE>>>
      <<<WITH>>>
      // New code
      export type OldType = {
        fieldA: string;
        newFieldB: number;
      }
      <<</WITH>>>
    validation_script: |
      echo "üîç Running lint check..."
      yarn lint
      if [ $? -ne 0 ]; then
        echo "‚ùå LINT FAILED - Attempting auto-fix..."
        yarn lint --fix
        if [ $? -ne 0 ]; then
          echo "‚ùå AUTO-FIX FAILED - Manual intervention required"
          exit 1
        fi
        echo "‚úÖ Lint errors auto-fixed, validating again..."
        yarn lint
        if [ $? -ne 0 ]; then
          echo "‚ùå LINT STILL FAILING - Manual fixes needed"
          exit 1
        fi
      fi
      echo "‚úÖ Lint passed"

      echo "üß™ Running tests with coverage..."
      yarn test --coverage
      if [ $? -ne 0 ]; then
        echo "‚ùå TESTS FAILED"
        exit 1
      fi
      echo "‚úÖ Tests passed"

      FILE_PATH="."
      COMMIT_MESSAGE="refactor(__FEATURE_NAME_KEBAB_CASE__): update __FILE_TO_MODIFY_KEBAB_CASE__"
      echo "üì¶ Staging file..."
      git add "$FILE_PATH"
      echo "üíæ Committing..."
      git commit -m "$COMMIT_MESSAGE"
      if [ $? -ne 0 ]; then
        echo "‚ùå COMMIT FAILED"
        exit 1
      fi
      echo "‚úÖ Committed successfully"

  # === DELETE STEP (ERROR RECOVERY) ===
  - id: 'delete-file-__FILE_TO_DELETE_KEBAB_CASE__'
    type: 'delete_file'
    description: 'Delete file __FILE_TO_DELETE_PASCAL_CASE__ due to generation error'
    <<: *step_defaults
    references:
      - type: 'internal_correction'
        source: 'self'
        description: 'Deleting artifact from failed step.'
    path: 'src/features/__FEATURE_NAME_KEBAB_CASE__/data/path/to/__FILE_TO_DELETE_KEBAB_CASE__.ts'
    validation_script: |
      echo "üóëÔ∏è Verifying file deletion..."
      if [ -f "src/features/__FEATURE_NAME_KEBAB_CASE__/data/path/to/__FILE_TO_DELETE_KEBAB_CASE__.ts" ]; then
        echo "‚ùå ERROR: File was not deleted."
        exit 1
      fi
      echo "‚úÖ File successfully deleted."
      echo "üîç Running lint check..."
      yarn lint
      if [ $? -ne 0 ]; then
        echo "‚ùå LINT FAILED - Attempting auto-fix..."
        yarn lint --fix
        if [ $? -ne 0 ]; then
          echo "‚ùå AUTO-FIX FAILED - Manual intervention required"
          exit 1
        fi
        echo "‚úÖ Lint errors auto-fixed, validating again..."
        yarn lint
        if [ $? -ne 0 ]; then
          echo "‚ùå LINT STILL FAILING - Manual fixes needed"
          exit 1
        fi
      fi
      echo "‚úÖ Lint passed"

      FILE_PATH="."
      COMMIT_MESSAGE="chore(__FEATURE_NAME_KEBAB_CASE__): delete broken artifact"
      echo "üì¶ Staging file..."
      git add "$FILE_PATH"
      echo "üíæ Committing..."
      git commit -m "$COMMIT_MESSAGE"
      if [ $? -ne 0 ]; then
        echo "‚ùå COMMIT FAILED"
        exit 1
      fi
      echo "‚úÖ Committed successfully"

  # === FINAL: CREATE PULL REQUEST ===
  - id: 'create-pull-request'
    type: 'pull_request'
    description: 'Create pull request for __FEATURE_NAME_PASCAL_CASE__ data layer implementation'
    <<: *step_defaults
    references:
      - type: 'internal_guideline'
        source: 'GIT_WORKFLOW.md'
        description: 'Following PR process for data layer integration.'
    action:
      target_branch: 'staging'
      source_branch: 'feat/__FEATURE_NAME_KEBAB_CASE__-data-layer'
      title: 'feat(__FEATURE_NAME_KEBAB_CASE__): implement data layer with TDD'
    validation_script: |
      echo "üöÄ Preparing to create pull request for data layer..."

      # Push the current branch to remote
      echo "üì§ Pushing branch to remote..."
      git push --set-upstream origin feat/__FEATURE_NAME_KEBAB_CASE__-data-layer
      if [ $? -ne 0 ]; then
        echo "‚ùå ERROR: Failed to push branch to remote"
        exit 1
      fi

      # Check if gh CLI is available
      if ! command -v gh &> /dev/null; then
        echo "‚ö†Ô∏è GitHub CLI (gh) is not installed."
        echo "üìã Please create PR manually"
        exit 0
      fi

      # Create the pull request
      echo "üîÑ Creating pull request..."
      PR_BODY="## Summary

      Implementation of Data Layer for __FEATURE_NAME_PASCAL_CASE__ feature following strict TDD principles.

      ### TDD Execution Order Followed:
      1. ‚úÖ **Test First** - Created comprehensive test files (.spec.ts)
      2. ‚úÖ **Mock/Spy** - Implemented spy pattern for all dependencies
      3. ‚úÖ **Protocols** - Created abstract interfaces for external dependencies
      4. ‚úÖ **Implementation** - Implemented use cases making tests pass

      ### Changes included:
      - Data layer with use case implementations
      - Protocol abstractions for external dependencies
      - Comprehensive test coverage with spy pattern
      - Feature-based architecture structure

      ### Architecture Compliance:
      - ‚úÖ Clean Architecture principles
      - ‚úÖ TDD Red-Green-Refactor cycle
      - ‚úÖ Protocol abstractions (no direct external imports)
      - ‚úÖ All tests passing
      - ‚úÖ Lint checks passed
      - ‚úÖ RLHF score: +2 (PERFECT)

      ### Generated by:
      - Template: DATA_TEMPLATE_REFACTORED.yaml
      - Date: $(date +%Y-%m-%d)

      ---
      ü§ñ Generated with spec-kit-clean-architecture"

      gh pr create \
        --base staging \
        --head feat/__FEATURE_NAME_KEBAB_CASE__-data-layer \
        --title "feat(__FEATURE_NAME_KEBAB_CASE__): implement data layer with TDD" \
        --body "$PR_BODY" \
        --assignee @me

      if [ $? -eq 0 ]; then
        echo "‚úÖ Pull request created successfully!"
        PR_URL=$(gh pr view --json url -q .url)
        echo "üìé Pull Request URL: $PR_URL"
        gh pr view --web
      else
        echo "‚ö†Ô∏è Could not create PR automatically. Please create manually."
      fi

# ------------------------------------------------------------------------------
# TROUBLESHOOTING, RECOVERY & AI GUIDELINES (kept for reference)
# ------------------------------------------------------------------------------

troubleshooting:
  tdd_violations:
    - 'CRITICAL: Never create implementation before tests'
    - 'If implementation exists before tests: Delete implementation, start over'
    - 'TDD Order is non-negotiable: Test ‚Üí Mock ‚Üí Protocol ‚Üí Implementation'
    - 'Each step must be committed separately for audit trail'

  protocol_issues:
    - 'Ensure all external dependencies are abstracted'
    - 'Check that mocks implement the same interface as protocols'
    - 'Verify no direct imports from external libraries'
    - 'Protocol interfaces should be in correct category folders'

  test_failures:
    - 'Verify spy implementations match protocol interfaces'
    - 'Check that makeSut factory creates all required dependencies'
    - 'Ensure throwError helper is imported correctly'
    - 'Validate that test scenarios cover all code paths'

  lint_fails:
    - 'DO NOT commit - Fix all lint errors first'
    - 'Check for unused imports'
    - 'Verify proper TypeScript types'
    - 'Ensure no console.log statements'
    - 'Run yarn lint --fix to auto-fix when possible'

  tests_fail:
    - 'DO NOT commit - All tests must pass'
    - 'Check if mocks match the actual interfaces'
    - 'Verify Input/Output types are correct'
    - 'Ensure test coverage meets requirements'
    - 'Run specific test: yarn test [test-file-path]'

  typescript_fails:
    - 'Check all type definitions match'
    - 'Ensure no missing imports'
    - 'Verify interface implementations are complete'
    - 'Run yarn tsc --noEmit to check types'

# Refactoring checklist for data layer
refactoring:
  before_refactoring: |
    # Check current status and differences
    echo "üìä Checking current changes..."
    git status
    git diff

    # Ensure clean working directory
    echo "‚úÖ Saving current work..."
    git stash save "WIP: before refactoring"

    # Create refactoring branch
    echo "üåø Creating refactor branch..."
    git checkout -b refactor/[feature-name]

    # Run tests to ensure starting point is stable
    echo "üß™ Validating current state..."
    yarn test --run
    if [ $? -ne 0 ]; then
      echo "‚ùå Tests failing before refactor - fix first!"
      exit 1
    fi
    echo "‚úÖ Ready to refactor"

  during_refactoring: |
    # After each change, check what was modified
    echo "üîç Reviewing changes..."
    git diff --stat
    git diff

    # Validate the change
    yarn lint && yarn test --run

    # Commit atomically
    git add -p  # Interactive staging
    git commit -m "refactor([feature-name]): [specific change description]"

    # Show what was changed
    git show --stat

  common_scenarios:
    - name: 'Splitting a use case implementation'
      wrong_example: |
        class CreateUserAndSendEmailUseCase implements CreateUserAndSendEmailUseCase {
          async execute(input: CreateUserAndSendEmailInput): Promise<CreateUserAndSendEmailOutput> {
            // Multiple responsibilities
          }
        }
      correct_example: |
        class CreateUserUseCase implements CreateUserUseCase {
          async execute(input: CreateUserInput): Promise<CreateUserOutput> {
            // Single responsibility
          }
        }
        class SendWelcomeEmailUseCase implements SendWelcomeEmailUseCase {
          async execute(input: SendWelcomeEmailInput): Promise<SendWelcomeEmailOutput> {
            // Single responsibility
          }
        }

    - name: 'Protocol abstraction refactoring'
      script: |
        # Find direct external imports
        grep -r "import.*axios\|fetch\|bcrypt" src/features/[feature-name]/data/
        # Replace with protocol abstractions
        # Validate
        yarn lint && yarn test --run
        # Commit
        git add .
        git commit -m "refactor: abstract external dependencies through protocols"

# Recovery steps for data layer
recovery:
  accidental_commit: |
    # Revert the last commit but keep changes
    git reset --soft HEAD~1
    # Fix the issues
    # Re-run validation
    yarn lint
    yarn test --coverage
    # Commit again with fixed code
    git add .
    git commit -m "[original message] - fixed"

  data_layer_polluted: |
    # Check for violations
    echo "üîç Checking for data layer violations..."
    grep -r "import.*axios\|fetch\|http" src/features/[feature-name]/data/
    grep -r "console\." src/features/[feature-name]/data/
    grep -r "class.*extends.*Component" src/features/[feature-name]/data/
    # Fix and validate
    yarn lint
    yarn test --run
    # Commit cleanup
    git add .
    git commit -m "refactor: remove data layer violations"

  tdd_order_violation: |
    # Check if implementation exists before tests
    echo "üîç Checking TDD order violations..."
    if [ -f "src/features/[feature-name]/data/usecases/[use-case].ts" ] && [ ! -f "tests/features/[feature-name]/data/usecases/[use-case].spec.ts" ]; then
      echo "‚ùå TDD VIOLATION: Implementation before tests!"
      echo "üóëÔ∏è Deleting implementation to restore TDD order..."
      rm "src/features/[feature-name]/data/usecases/[use-case].ts"
      echo "‚úÖ Start over with tests first"
    fi

# AI Guidelines for data layer (adapted from TEMPLATE.yaml)
ai_guidelines:
  - 'STRICT TDD: Always write tests first, implementation last - NO EXCEPTIONS'
  - 'Always validate before committing: Run lint first, Run tests second, Only commit if both pass'
  - 'If generation fails: Identify the specific error, Fix only that error, Re-run validation, Do NOT proceed until fixed'
  - 'Follow the principle: One use case = One file = One responsibility'
  - 'Protocol abstraction: All external dependencies MUST be abstracted through interfaces'
  - 'If tempted to add "And" in a use case name, split it'
  - 'When in doubt: Choose simplicity over complexity, Split rather than combine, Ask for clarification rather than assume'
  - 'MUST generate different case styles from the input names (e.g., "Add Item To Cart" becomes: PascalCase=AddItemToCart, kebab-case=add-item-to-cart, lower case=add item to cart).'
  - 'MUST replace ALL placeholder variables (like __FEATURE_NAME_KEBAB_CASE__) with actual values'
  - 'MUST NOT leave any placeholder variables in the final implementation'
  - 'MUST NOT replace any [placeholders] found inside documentation sections like refactoring or recovery'
  - 'MUST use vitest, NOT jest'
  - 'MUST follow TDD order: Test ‚Üí Mock ‚Üí Protocol ‚Üí Implementation'
  - 'MUST follow all data layer rules - protocol abstractions, no external dependencies'
  - 'MUST follow all Clean Architecture rules'
  - 'MUST use REPLACE/WITH format for refactor_file steps'
  - 'MUST use spy pattern for all dependency mocking'
  - 'MUST commit each TDD step separately for audit trail'

evaluation:
  final_status: 'PENDING' # PENDING | SUCCESS | FAILED
  final_rlhf_score: null # -2, -1, 0, 1, 2
  tdd_compliance_score: null # 0-100% based on TDD order adherence
  reviewer_summary: |
    - TDD Execution:
      - Test-first approach: ...
      - Mock/Spy quality: ...
      - Protocol abstractions: ...
    - Architecture Compliance:
      - Clean Architecture: ...
      - Dependency rules: ...
  template_improvement_suggestions:
    - target_template: 'DATA_TEMPLATE_REFACTORED.yaml'
      target_step_id: 'create-test-__PREFIX__-__USE_CASE_NAME_KEBAB__'
      suggestion: 'Consider adding more specific test scenarios for edge cases.'
      priority: 'medium'