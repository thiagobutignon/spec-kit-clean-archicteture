# ============= BEGIN RULES FULLSTACK SECTION =============

  # ------------------------------------------------------------------------------
  # AI-NOTE: IMMUTABLE SECTIONS AHEAD.
  # The sections from here until 'steps' are architectural rules.
  # You MUST copy them verbatim into the implementation file without ANY modification.
  #
  # AUTOMATED LEARNING SYSTEM:
  # The RLHF system automatically:
  # - Tracks success/failure patterns across executions
  # - Identifies common error types and their fixes
  # - Applies improvements when confidence > 80%
  # - Generates learning reports with actionable insights
  # - Prevents hallucinations with score 0 for uncertain cases
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # FULLSTACK RULES SECTION
  # Clean Architecture rules for unified Next.js 15 frontend + backend development
  # Shared components: domain, validation | Split components: data, presentation, main
  # ------------------------------------------------------------------------------

  rules:
    # Domain layer rules (Shared between frontend and backend)
    domain:
      shared_purpose: 'Domain logic must be 100% shared between frontend and backend'

      allowed:
        - 'Business entities with immutable data structures'
        - 'Use case interfaces with single execute() method'
        - 'Separate Input and Output types for each use case'
        - 'Domain types and DTOs for API communication'
        - 'Domain errors for business rule violations'
        - 'JSDoc documentation for all public interfaces'
        - 'ES2015 module exports (export type, export interface)'

      forbidden:
        - 'Multiple methods in a single use case interface'
        - 'Combined operations (e.g., __USE_CASE_NAME__And__OTHER_ACTION__)'
        - 'Framework dependencies (React, Next.js, Node.js specifics)'
        - 'External libraries (HTTP, database, or browser clients)'
        - 'Implementation details of any kind'
        - 'React components or API handlers'
        - 'HTTP/Database/File system operations'
        - 'Environment variables or configuration'
        - 'Console.log or any I/O operations'
        - 'Implementation of business logic (only interfaces allowed)'
        - 'Validation implementations (use validation layer)'
        - 'Error throwing or handling (define error types only)'
        - 'Dependency injection'
        - 'Domain entities with methods/behavior (use simple data structures)'

      use_case:
        must:
          - 'Have only ONE execute() method per interface'
          - 'Define separate Input and Output types'
          - 'Have EXACTLY ONE responsibility (one business operation)'
          - 'Be named with single verb describing ONE action (__USE_CASE_NAME__, not __USE_CASE_NAME__And__OTHER_ACTION__)'
          - 'Include comprehensive JSDoc documentation'
          - 'Return Promise<Output> from execute method'
          - 'Be framework agnostic (runnable in both browser and Node.js)'
          - 'Follow naming convention: VerbNoun (e.g., __USE_CASE_EXAMPLE_1__, __USE_CASE_EXAMPLE_2__, __USE_CASE_EXAMPLE_3__)'
        must_not:
          - 'Have multiple methods (no __METHOD_1__() AND __METHOD_2__() in same interface)'
          - 'Combine multiple operations (__USE_CASE_NAME__And__OTHER_ACTION__ violates SRP)'
          - 'Contain implementation logic'
          - 'Know about HTTP, databases, or external services'
          - 'Import from data, presentation, or infrastructure layers'
          - 'Have side effects'
          - 'Use generic method names like handle(), process(), or run()'

    # Data layer rules (Split: backend and frontend implementations)
    data:
      split_purpose: 'Data layer splits into backend (database operations) and frontend (API calls)'

      backend:
        must:
          - 'Implement domain use case interfaces for server-side logic'
          - 'Use constructor injection for dependencies'
          - 'Define protocols for database and external services'
          - 'Use prefix naming (Db__USE_CASE_NAME__, Service__USE_CASE_NAME__)'
          - 'Handle database transactions and rollbacks'
          - 'Map database models to domain entities'
          - 'Return domain types, not database-specific types'
          - 'Handle server-side errors and status codes'
        must_not:
          - 'Import from infrastructure layer directly'
          - 'Contain complex business logic (belongs in domain)'
          - 'Expose database details to domain'
          - 'Use concrete database implementations instead of protocols'
          - 'Have direct database calls (use repository protocols)'
          - 'Know about HTTP requests or browser APIs'

      frontend:
        must:
          - 'Implement domain use case interfaces for client-side logic'
          - 'Use constructor injection for dependencies'
          - 'Define protocols for API communication'
          - 'Use prefix naming (Remote__USE_CASE_NAME__, Api__USE_CASE_NAME__)'
          - 'Handle network errors and retry logic'
          - 'Map API responses to domain entities'
          - 'Return domain types, not HTTP-specific types'
          - 'Handle client-side caching and optimistic updates'
        must_not:
          - 'Import from infrastructure layer directly'
          - 'Contain complex business logic (belongs in domain)'
          - 'Expose HTTP details to domain'
          - 'Use concrete HTTP implementations instead of protocols'
          - 'Have direct API calls (use HTTP client protocols)'
          - 'Know about database operations or server-side logic'

    # Infrastructure layer rules (Split: server-side and client-side)
    infra:
      split_purpose: 'Infrastructure splits into server-side (database, cache) and client-side (HTTP, storage)'

      backend:
        must:
          - 'Implement data layer protocols for server operations'
          - 'Use Prisma ORM for database operations'
          - 'Support PostgreSQL with pgvector extension'
          - 'Use Redis for server-side caching'
          - 'Handle database connection pooling and transactions'
          - 'Use environment variables for server configuration'
          - 'Implement background job processing'
          - 'Handle file storage (S3, local filesystem)'
        must_not:
          - 'Import from domain or use case layers'
          - 'Contain business logic'
          - 'Expose database-specific types to other layers'
          - 'Use MongoDB (use Prisma with PostgreSQL)'
          - 'Know about browser APIs or client-side concerns'

      frontend:
        must:
          - 'Implement data layer protocols for client operations'
          - 'Use native Fetch API for HTTP requests'
          - 'Handle browser localStorage/sessionStorage'
          - 'Implement client-side cache strategies (React Query, SWR)'
          - 'Handle network retry logic and offline scenarios'
          - 'Use environment variables for client configuration (NEXT_PUBLIC_*)'
          - 'Handle CORS and authentication headers'
          - 'Implement WebSocket connections for real-time features'
        must_not:
          - 'Import from domain or use case layers'
          - 'Contain business logic'
          - 'Use multiple HTTP client implementations'
          - 'Expose HTTP-specific types to other layers'
          - 'Use axios or other HTTP libraries (use Fetch API)'
          - 'Know about database operations or server-side concerns'

    # Presentation layer rules (Split: backend handlers and frontend UI)
    presentation:
      split_purpose: 'Presentation splits into backend (API handlers) and frontend (Server Actions, components, hooks)'

      backend:
        handlers:
          must:
            - 'Use Next.js 15 API Routes for RESTful endpoints'
            - 'Implement handler functions with standard HTTP methods (GET, POST, PUT, DELETE)'
            - 'Return standardized API responses (NextResponse.json)'
            - 'Use Next.js middleware for cross-cutting concerns'
            - 'Handle errors gracefully with try/catch'
            - 'Validate requests with shared Zod schemas'
            - 'Use dependency injection from main layer factories'
          must_not:
            - 'Use Express or other HTTP frameworks (use Next.js API Routes)'
            - 'Import from infra layer directly'
            - 'Contain business logic (delegate to use cases)'
            - 'Make direct database calls'
            - 'Know about React components or client-side concerns'

      frontend:
        actions:
          must:
            - 'Use Next.js 15 Server Actions for form submission'
            - 'Implement "use server" directive for server-side execution'
            - 'Return ActionResult<T> or FormState for form feedback'
            - 'Validate with shared Zod schemas'
            - 'Handle errors with redirect/revalidate patterns'
            - 'Use dependency injection from main layer composites'
          must_not:
            - 'Contain business logic (delegate to use cases)'
            - 'Make direct database calls'
            - 'Import from infra layer directly'

        components:
          must:
            - 'Use Shadcn/ui components with Tailwind CSS'
            - 'Prefer Server Components over Client Components'
            - 'Use "use client" directive only when necessary'
            - 'Follow atomic design principles (atoms, molecules, organisms)'
            - 'Implement proper error boundaries'
            - 'Use TypeScript for props and state'
            - 'Receive dependencies as props from main layer'
          must_not:
            - 'Use custom CSS/SASS (use Tailwind CSS)'
            - 'Contain business logic (use custom hooks)'
            - 'Make direct API calls (use Server Actions or hooks)'
            - 'Import from data or infra layers directly'

        hooks:
          must:
            - 'Use React hooks for state management and side effects'
            - 'Implement custom hooks for reusable logic'
            - 'Use Context API for feature-specific state'
            - 'Handle loading, error, and success states'
            - 'Follow hooks rules (no conditional calls)'
            - 'Integrate with client-side data layer when needed'
          must_not:
            - 'Use Redux or external state managers (use Context API)'
            - 'Contain business logic (delegate to use cases)'
            - 'Make direct API calls (use data layer)'
            - 'Import from infra layer directly'

    # Error rules
    error:
      must:
        - 'Extend the native Error class'
        - 'Have descriptive names ending with Error'
        - 'Contain meaningful error messages'
        - 'Represent business rule violations'
        - 'Be thrown when domain invariants are violated'

      must_not:
        - 'Contain HTTP status codes'
        - 'Include technical/implementation details'
        - 'Expose sensitive information'
        - 'Import external dependencies'

    # Test helper rules
    test_helper:
      must:
        - 'Create mock/stub implementations of use cases'
        - 'Generate fake test data'
        - 'Be pure functions that return consistent data'
        - 'Help reduce test boilerplate'
        - 'Use ONLY Vitest (Jest is prohibited)'

      must_not:
        - 'Make real API calls or database queries'
        - 'Depend on external services'
        - 'Contain test assertions (those belong in test files)'
        - 'Have side effects or maintain state'
        - 'Use Jest (use Vitest instead)'

    # Validation rules (Shared between frontend and backend)
    validation:
      shared_purpose: 'Validation schemas must be 100% shared between frontend and backend using Zod'

      schemas:
        must:
          - 'Use Zod for schema definition and validation'
          - 'Define schemas that match domain Input/Output types'
          - 'Support both client and server-side validation'
          - 'Include descriptive error messages for form fields'
          - 'Export schemas for reuse across frontend and backend'
          - 'Use consistent naming: __USE_CASE_NAME__InputSchema, __USE_CASE_NAME__OutputSchema'
          - 'Support nested object validation for complex domain types'
          - 'Provide transform functions for data sanitization'
        must_not:
          - 'Import from domain layer (validation is independent)'
          - 'Import from data, presentation, or infra layers'
          - 'Contain business logic (only validation rules)'
          - 'Use other validation libraries (Zod only)'
          - 'Access external services for validation'
          - 'Use async validation (keep schemas synchronous)'

      validators:
        must:
          - 'Implement reusable field validators with Zod'
          - 'Support synchronous validation for forms and APIs'
          - 'Return user-friendly error messages'
          - 'Follow Zod patterns and conventions'
          - 'Provide helper functions for common validation patterns'
          - 'Support type inference for TypeScript integration'
          - 'Use refinements for complex validation rules'
        must_not:
          - 'Import from data or infra layers'
          - 'Throw exceptions (return validation results)'
          - 'Access external services for validation'
          - 'Use async validation (prefer synchronous)'
          - 'Duplicate validation logic between schemas'

    # Main layer rules (Split: backend factories and frontend composites)
    main:
      split_purpose: 'Main layer splits into backend (factories for API handlers) and frontend (composites for UI components)'

      backend:
        factories:
          must:
            - 'Create factory functions for Next.js API route handlers'
            - 'Wire up all dependencies using composition root pattern'
            - 'Apply decorators for cross-cutting concerns (logging, monitoring)'
            - 'Configure Next.js middleware for API routes'
            - 'Handle environment configuration and secrets'
            - 'Use dependency injection containers'
            - 'Return fully configured API handlers'
            - 'Setup database connections and migrations'
            - 'Initialize monitoring and health checks'
          must_not:
            - 'Contain business logic (only wiring and composition)'
            - 'Have direct database or API calls'
            - 'Include complex algorithms or calculations'
            - 'Store application state'
            - 'Define new interfaces or types (use existing from other layers)'
            - 'Handle request/response logic (belongs in presentation)'

      frontend:
        composites:
          must:
            - 'Create composite components that wire all dependencies'
            - 'Compose Server Actions with validation schemas'
            - 'Wire use cases with data layer and validation'
            - 'Export fully configured components ready for App Router'
            - 'Handle error states and loading states'
            - 'Use Next.js 15 App Router patterns (layout, page, loading, error)'
            - 'Implement proper SEO metadata and structured data'
            - 'Handle authentication and route protection'
          must_not:
            - 'Contain business logic (only composition)'
            - 'Make direct API calls'
            - 'Define new interfaces or types'
            - 'Store application state directly'
            - 'Include complex algorithms or calculations'

        pages:
          must:
            - 'Create page composers that aggregate feature composites'
            - 'Use Next.js 15 App Router patterns (layout, page, loading, error)'
            - 'Implement proper SEO metadata and structured data'
            - 'Handle authentication and route protection'
            - 'Export React.FC components for App Router integration'
            - 'Use Server Components by default, Client Components when necessary'
          must_not:
            - 'Contain business logic (delegate to composites)'
            - 'Have direct state management (use providers)'
            - 'Include complex algorithms or calculations'
            - 'Store application state directly'

    # Reference patterns
    reference_patterns:
      clean_architecture:
        type: 'external_pattern'
        source: 'context7'
        query: 'clean architecture use case'
        url: 'https://github.com/...'
        description: 'Following Clean Architecture pattern.'

      ddd_pattern:
        type: 'external_pattern'
        source: 'context7'
        query: 'domain driven design'
        url: 'https://github.com/...'
        description: 'Following DDD patterns.'

      tdd_pattern:
        type: 'external_pattern'
        source: 'context7'
        query: 'test driven development'
        url: 'https://github.com/...'
        description: 'Following TDD patterns.'

    # Learning patterns (Fullstack-specific)
    learning_patterns:
      common_errors:
        - pattern: 'import axios'
          fix: 'Use Fetch API instead of axios in fullstack infra layer'
          score_impact: -2

        - pattern: '__USE_CASE_NAME__And__OTHER_ACTION__'
          fix: 'Split into two separate use cases (SRP violation)'
          score_impact: -1

        - pattern: '"use client" everywhere'
          fix: 'Prefer Server Components, use "use client" only when necessary'
          score_impact: -1

        - pattern: 'useState for server state'
          fix: 'Use Server Actions and revalidation instead of client state'
          score_impact: -1

        - pattern: 'missing Zod validation'
          fix: 'Add Zod schema validation for forms and APIs'
          score_impact: -2

        - pattern: 'duplicate validation logic'
          fix: 'Share Zod schemas between frontend and backend'
          score_impact: -1

        - pattern: 'Express in fullstack'
          fix: 'Use Next.js API Routes instead of Express for fullstack'
          score_impact: -2

      success_indicators:
        - 'Uses ubiquitous language consistently'
        - 'Follows single responsibility principle'
        - 'No dependency violations between layers'
        - 'Proper Server Component vs Client Component usage'
        - 'Shared Zod schemas between frontend and backend'
        - 'Comprehensive test coverage with Vitest'
        - 'Clean git history with atomic commits'
        - 'Effective use of Next.js App Router patterns'
        - 'Strong TypeScript typing throughout'

    # Required protocols for all layers
    required_protocols:
      # Domain Layer
      domain:
        - 'All use cases must have single execute() method'
        - 'All use cases must define separate Input and Output types'
        - 'All domain types must be immutable'
        - 'No use case can perform multiple operations (SRP)'
        - 'All models must be simple DTOs without behavior'

      # Data Layer
      data:
        - 'All implementations must inject dependencies via constructor'
        - 'All protocols must be interfaces, not concrete classes'
        - 'All implementations must use Db or Remote prefix'
        - 'Must return domain types, not infrastructure types'
        - 'Must handle errors and map status codes appropriately'

      # Infrastructure Layer
      infra:
        - 'All adapters must implement data layer protocols'
        - 'HTTP clients must use Fetch API, not axios'
        - 'Database repositories must use Prisma with PostgreSQL'
        - 'All external configs must come from environment variables'
        - 'Must not expose infrastructure types to other layers'

      # Presentation Layer
      presentation:
        - 'Controllers must implement handle() method'
        - 'Controllers must return HTTP helpers (ok, badRequest, etc.)'
        - 'React components must use function components with hooks'
        - 'Pages must receive dependencies as props'
        - 'Middlewares must implement handle() with next parameter'

      # Validation Layer (Shared)
      validation:
        - 'All schemas must use Zod for validation'
        - 'Schemas must match domain model structure'
        - 'Validation must be synchronous for forms and APIs'
        - 'Must support both client and server validation'
        - 'Error messages must be user-friendly'
        - 'Schema naming: __USE_CASE_NAME__InputSchema, __USE_CASE_NAME__OutputSchema'

      # Main Layer (Split)
      main:
        - 'Backend factories must return configured API handlers'
        - 'Frontend composites must return configured React components'
        - 'All factory functions must wire all dependencies'
        - 'No business logic allowed (only composition)'
        - 'Must use Next.js patterns for both API routes and App Router'
        - 'Must not define new types (use existing from other layers)'

      # Cross-cutting Concerns
      general:
        - 'All public interfaces must have JSDoc documentation'
        - 'All errors must extend native Error class'
        - 'All test helpers must be pure functions'
        - 'All tests must use Vitest, not Jest'
        - 'No use of faker - fixed test data only'

    # Documentation standards (JSDoc)
    documentation:
      # Domain Layer Documentation
      domain:
        use_case_interface:
          - '@description - Clear description of the use case purpose'
          - '@example - Usage example with execute() method'
          - '@see - Reference to related use cases or documentation'
        input_output_types:
          - '@typedef - Define Input and Output types'
          - '@property - Document each field with type and constraints'
          - '@example - Show valid input/output instances'
        model_type:
          - '@typedef - Define the domain model'
          - '@property - Document each property with business rules'
          - '@example - Show valid model instance'

      # Data Layer Documentation
      data:
        protocol_interface:
          - '@interface - Define protocol contracts'
          - '@method - Document each method signature'
          - '@throws - Document possible errors'
        implementation_class:
          - '@class - Describe the use case implementation'
          - '@implements - List implemented interfaces'
          - '@constructor - Document dependency injection'
          - '@method - Document orchestration logic'

      # Infrastructure Layer Documentation
      infra:
        adapter_class:
          - '@class - Describe the adapter purpose'
          - '@implements - Protocol being implemented'
          - '@dependency - External libraries used'
        database_repository:
          - '@class - Repository implementation'
          - '@method - Document CRUD operations'
          - '@throws - Database-specific errors'
        http_client:
          - '@class - HTTP client implementation'
          - '@method - Document request/response handling'
          - '@throws - Network-related errors'

      # Presentation Layer Documentation
      presentation:
        controller:
          - '@class - Controller description'
          - '@route - HTTP route and method'
          - '@param - Request parameters'
          - '@returns - HTTP response format'
          - '@throws - HTTP error responses'
        middleware:
          - '@function - Middleware purpose'
          - '@param - Request, Response, Next'
          - '@throws - Authorization/validation errors'
        react_component:
          - '@component - Component description'
          - '@props - Component properties'
          - '@state - Component state (if any)'
          - '@returns - JSX element'

      # Validation Layer Documentation (Shared)
      validation:
        zod_schema:
          - '@schema - Zod schema description'
          - '@property - Document each field with validation rules'
          - '@example - Show valid and invalid examples'
          - '@returns - Parsed data or validation errors'
        validator_function:
          - '@function - Field validator description'
          - '@param - Value to validate'
          - '@returns - Validation result or error message'
        shared_validator:
          - '@function - Shared validator for frontend and backend'
          - '@param - Input data to validate'
          - '@returns - Type-safe parsed data or validation errors'

      # Main Layer Documentation (Split)
      main:
        backend_factory:
          - '@function - Backend factory function description'
          - '@returns - Configured API handler with dependencies'
          - '@example - How to use the factory in API routes'
        frontend_composite:
          - '@component - Frontend composite description'
          - '@returns - Configured React component with all dependencies'
          - '@example - How to use the composite in App Router'
        page_composer:
          - '@component - Page composer description'
          - '@param - Page props and metadata'
          - '@returns - Next.js page component'
        dependency_composition:
          - '@function - Dependency composition for fullstack'
          - '@returns - Fully configured instances for both frontend and backend'

      example_template: |
        /**
        * @description __USE_CASE_DESCRIPTION__
        * @example
        * const __USE_CASE_NAME_CAMEL_CASE__ = new __USE_CASE_NAME_PASCAL_CASE__Impl(__DEPENDENCY_NAME__)
        * const result = await __USE_CASE_NAME_CAMEL_CASE__.execute({
        *   __INPUT_FIELD_1__: '__EXAMPLE_VALUE_1__',
        *   __INPUT_FIELD_2__: '__EXAMPLE_VALUE_2__',
        *   __INPUT_FIELD_3__: '__EXAMPLE_VALUE_3__'
        * })
        * @see {@link __RELATED_USE_CASE__} for __RELATED_DESCRIPTION__
        */
        export interface __USE_CASE_NAME_PASCAL_CASE__ {
          execute(input: __USE_CASE_NAME_PASCAL_CASE__Input): Promise<__USE_CASE_NAME_PASCAL_CASE__Output>
        }

        /**
        * @typedef {Object} __USE_CASE_NAME_PASCAL_CASE__Input
        * @property {string} __INPUT_FIELD_1__ - __FIELD_1_DESCRIPTION__ (__FIELD_1_CONSTRAINTS__)
        * @property {string} __INPUT_FIELD_2__ - __FIELD_2_DESCRIPTION__
        * @property {string} __INPUT_FIELD_3__ - __FIELD_3_DESCRIPTION__ (__FIELD_3_CONSTRAINTS__)
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Input = {
          __INPUT_FIELD_1__: string
          __INPUT_FIELD_2__: string
          __INPUT_FIELD_3__: string
        }

        /**
        * @typedef {Object} __USE_CASE_NAME_PASCAL_CASE__Output
        * @property {string} __OUTPUT_FIELD_1__ - __OUTPUT_FIELD_1_DESCRIPTION__
        * @property {string} __OUTPUT_FIELD_2__ - __OUTPUT_FIELD_2_DESCRIPTION__
        * @property {string} __OUTPUT_FIELD_3__ - __OUTPUT_FIELD_3_DESCRIPTION__
        * @property {Date} __TIMESTAMP_FIELD__ - __TIMESTAMP_DESCRIPTION__
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Output = {
          __OUTPUT_FIELD_1__: string
          __OUTPUT_FIELD_2__: string
          __OUTPUT_FIELD_3__: string
          __TIMESTAMP_FIELD__: Date
        }
# ============= END RULES FULLSTACK WITH NEXT.JS SECTION =============
