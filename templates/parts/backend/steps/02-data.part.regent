# ============= BEGIN DATA STEPS BACKEND SECTION =============

  # ------------------------------------------------------------------------------
  # AI-NOTE: DATA LAYER IMPLEMENTATION STEPS FOR BACKEND (TDD)
  # Simplified to match real codebase patterns - supports both Db and Remote
  # Based on real code: DbAddAccount (database) and potential 3rd party APIs
  # ------------------------------------------------------------------------------

  data_steps:
    # === STEP 1: CREATE FEATURE BRANCH ===
    - id: 'create-feature-branch-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create feature branch for __USE_CASE_NAME_PASCAL_CASE__ backend data layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Following Git Flow pattern for feature development.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'git workflow feature branch naming conventions'
          url: 'https://github.com/...'
          description: 'Git Flow and feature branch best practices.'
      run_scripts:
        description: 'Create and checkout feature branch for data layer development'
        scripts:
          - name: 'Create feature branch'
            command: 'git checkout -b feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-backend'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Push feature branch'
            command: 'git push -u origin feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-backend'
            workingDirectory: '__PROJECT_NAME__'
      validation_script: |
        current_branch=$(git branch --show-current)
        expected_branch="feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-backend"
        if [ "$current_branch" != "$expected_branch" ]; then
          echo "‚ùå ERROR: Expected branch $expected_branch, but current branch is $current_branch"
          exit 1
        fi
        echo "‚úÖ Feature branch created successfully: $current_branch"

    # === STEP 2: CREATE DATA STRUCTURE ===
    - id: 'create-data-structure-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'folder'
      description: 'Create data layer folder structure for __USE_CASE_NAME_PASCAL_CASE__ backend use case'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'BACKEND_ARCHITECTURE.md'
          description: 'Following Clean Architecture data layer structure for backend.'
      action:
        create_folders:
          basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data'
          folders:
            - 'usecases'     # Both Db (database) and Remote (3rd party API) implementations

    # === STEP 3: CREATE DATABASE TESTS (RED PHASE) ===
    - id: 'create-database-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create failing tests for Db__USE_CASE_NAME_PASCAL_CASE__ database implementation (RED)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_code_analysis'
          source: 'serena'
          description: 'Following existing test patterns from DbAddAccount and DbAuthentication.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'test driven development jest typescript'
          url: 'https://github.com/...'
          description: 'TDD patterns with Jest for TypeScript.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/db-__USE_CASE_NAME_KEBAB_CASE__.spec.ts'
      template: |
        import { Db__USE_CASE_NAME_PASCAL_CASE__ } from './db-__USE_CASE_NAME_KEBAB_CASE__'
        import type { __USE_CASE_NAME_PASCAL_CASE__ } from '../../domain/usecases/__USE_CASE_NAME_KEBAB_CASE__'

        /**
         * Database Data Layer Tests - Following DbAddAccount pattern
         */
        describe('Db__USE_CASE_NAME_PASCAL_CASE__', () => {
          let sut: Db__USE_CASE_NAME_PASCAL_CASE__
          let __DEPENDENCY_1_CAMEL_CASE__Stub: any
          let __DEPENDENCY_2_CAMEL_CASE__Stub: any

          beforeEach(() => {
            __DEPENDENCY_1_CAMEL_CASE__Stub = {
              __METHOD_1__: jest.fn()
            }
            __DEPENDENCY_2_CAMEL_CASE__Stub = {
              __METHOD_2__: jest.fn()
            }
            sut = new Db__USE_CASE_NAME_PASCAL_CASE__(
              __DEPENDENCY_1_CAMEL_CASE__Stub,
              __DEPENDENCY_2_CAMEL_CASE__Stub
            )
          })

          describe('RED Phase - These should FAIL initially', () => {
            it('should call __DEPENDENCY_1__ with correct values', async () => {
              const params = {
                __INPUT_FIELD_1__: 'any_value_1',
                __INPUT_FIELD_2__: 'any_value_2'
              }

              await sut.__USE_CASE_METHOD_NAME__(params)

              expect(__DEPENDENCY_1_CAMEL_CASE__Stub.__METHOD_1__).toHaveBeenCalledWith(params)
            })

            it('should return correct result on success', async () => {
              const expectedResult = {
                __OUTPUT_FIELD_1__: 'any_value_1',
                __OUTPUT_FIELD_2__: 'any_value_2'
              }
              __DEPENDENCY_2_CAMEL_CASE__Stub.__METHOD_2__.mockResolvedValue(expectedResult)

              const result = await sut.__USE_CASE_METHOD_NAME__({
                __INPUT_FIELD_1__: 'any_input_1',
                __INPUT_FIELD_2__: 'any_input_2'
              })

              expect(result).toEqual(expectedResult)
            })

            it('should throw if __DEPENDENCY_1__ throws', async () => {
              __DEPENDENCY_1_CAMEL_CASE__Stub.__METHOD_1__.mockRejectedValue(new Error())

              const promise = sut.__USE_CASE_METHOD_NAME__({
                __INPUT_FIELD_1__: 'any_input_1',
                __INPUT_FIELD_2__: 'any_input_2'
              })

              await expect(promise).rejects.toThrow()
            })
          })
        })

      validation_script: |
        echo "üî¥ RED PHASE: Running failing database tests..."
        npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/db --no-coverage || {
          echo "‚úÖ Tests are failing as expected (RED phase)"
          git add .
          git commit -m "test(__FEATURE_NAME_KEBAB_CASE__): add failing tests for database data layer (RED)"
          exit 0
        }
        echo "‚ùå ERROR: Tests should be failing in RED phase!"
        exit 1

    # === STEP 4: CREATE DATABASE IMPLEMENTATION (GREEN PHASE) ===
    - id: 'create-database-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create Db__USE_CASE_NAME_PASCAL_CASE__ database implementation following real patterns (GREEN)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_code_analysis'
          source: 'serena'
          description: 'Following DbAddAccount and DbAuthentication patterns.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/db-__USE_CASE_NAME_KEBAB_CASE__.ts'
      template: |
        import { __USE_CASE_NAME_PASCAL_CASE__ } from '@/domain/usecases'
        import { __PROTOCOL_1__, __PROTOCOL_2__ } from '@/data/protocols'

        /**
         * Database implementation of __USE_CASE_NAME_PASCAL_CASE__ use case
         * Following the exact pattern of DbAddAccount and DbAuthentication
         */
        export class Db__USE_CASE_NAME_PASCAL_CASE__ implements __USE_CASE_NAME_PASCAL_CASE__ {
          constructor (
            private readonly __DEPENDENCY_1_CAMEL_CASE__: __PROTOCOL_1__,
            private readonly __DEPENDENCY_2_CAMEL_CASE__: __PROTOCOL_2__
          ) {}

          async __USE_CASE_METHOD_NAME__ (params: __USE_CASE_NAME_PASCAL_CASE__.Params): Promise<__USE_CASE_NAME_PASCAL_CASE__.Result> {
            // Simple orchestration logic like DbAddAccount
            const __INTERMEDIATE_VALUE__ = await this.__DEPENDENCY_1_CAMEL_CASE__.__METHOD_1__(params.__INPUT_FIELD_1__)

            if (!__INTERMEDIATE_VALUE__) {
              return null
            }

            const result = await this.__DEPENDENCY_2_CAMEL_CASE__.__METHOD_2__({
              ...params,
              __PROCESSED_FIELD__: __INTERMEDIATE_VALUE__
            })

            return result
          }
        }

    # === STEP 5: CREATE EXTERNAL API TESTS (RED PHASE - CONDITIONAL) ===
    - id: 'create-external-api-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Create failing tests for Remote__USE_CASE_NAME_PASCAL_CASE__ external API implementation (RED)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: '__REQUIRES_EXTERNAL_API__'
      references:
        - type: 'internal_code_analysis'
          source: 'serena'
          description: 'Following patterns for external API integration.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/remote-__USE_CASE_NAME_KEBAB_CASE__.spec.ts'
      template: |
        import { HttpClient, HttpStatusCode } from '@/data/protocols/http'
        import { Remote__USE_CASE_NAME_PASCAL_CASE__ } from './remote-__USE_CASE_NAME_KEBAB_CASE__'
        import type { __USE_CASE_NAME_PASCAL_CASE__ } from '../../domain/usecases/__USE_CASE_NAME_KEBAB_CASE__'
        import { UnexpectedError } from '@/domain/errors'

        /**
         * External API Data Layer Tests - For 3rd party integrations
         */
        describe('Remote__USE_CASE_NAME_PASCAL_CASE__', () => {
          let sut: Remote__USE_CASE_NAME_PASCAL_CASE__
          let url: string
          let httpClientSpy: HttpClient

          beforeEach(() => {
            url = 'https://api.example.com/endpoint'
            httpClientSpy = {
              request: jest.fn()
            }
            sut = new Remote__USE_CASE_NAME_PASCAL_CASE__(url, httpClientSpy)
          })

          describe('RED Phase - These should FAIL initially', () => {
            it('should call HttpClient with correct values', async () => {
              const params = {
                __INPUT_FIELD_1__: 'any_value_1',
                __INPUT_FIELD_2__: 'any_value_2'
              }

              jest.spyOn(httpClientSpy, 'request').mockResolvedValueOnce({
                statusCode: HttpStatusCode.ok,
                body: 'any_body'
              })

              await sut.__USE_CASE_METHOD_NAME__(params)

              expect(httpClientSpy.request).toHaveBeenCalledWith({
                url: 'https://api.example.com/endpoint',
                method: 'post',
                body: params
              })
            })

            it('should return correct data on HttpStatusCode.ok', async () => {
              const httpResult = {
                __OUTPUT_FIELD_1__: 'any_value_1',
                __OUTPUT_FIELD_2__: 'any_value_2'
              }

              jest.spyOn(httpClientSpy, 'request').mockResolvedValueOnce({
                statusCode: HttpStatusCode.ok,
                body: httpResult
              })

              const result = await sut.__USE_CASE_METHOD_NAME__({
                __INPUT_FIELD_1__: 'any_input_1',
                __INPUT_FIELD_2__: 'any_input_2'
              })

              expect(result).toEqual(httpResult)
            })

            it('should throw UnexpectedError on server error', async () => {
              jest.spyOn(httpClientSpy, 'request').mockResolvedValueOnce({
                statusCode: HttpStatusCode.serverError,
                body: 'any_error'
              })

              const promise = sut.__USE_CASE_METHOD_NAME__({
                __INPUT_FIELD_1__: 'any_input_1',
                __INPUT_FIELD_2__: 'any_input_2'
              })

              await expect(promise).rejects.toThrow(new UnexpectedError())
            })
          })
        })

      validation_script: |
        echo "üî¥ RED PHASE: Running failing external API tests..."
        npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/remote --no-coverage || {
          echo "‚úÖ Tests are failing as expected (RED phase)"
          git add .
          git commit -m "test(__FEATURE_NAME_KEBAB_CASE__): add failing tests for external API data layer (RED)"
          exit 0
        }
        echo "‚ùå ERROR: Tests should be failing in RED phase!"
        exit 1

    # === STEP 6: CREATE EXTERNAL API IMPLEMENTATION (GREEN PHASE - CONDITIONAL) ===
    - id: 'create-external-api-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Create Remote__USE_CASE_NAME_PASCAL_CASE__ external API implementation (GREEN)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: '__REQUIRES_EXTERNAL_API__'
      references:
        - type: 'internal_code_analysis'
          source: 'serena'
          description: 'Following patterns for external API integration.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/remote-__USE_CASE_NAME_KEBAB_CASE__.ts'
      template: |
        import { HttpClient, HttpStatusCode } from '@/data/protocols/http'
        import { __USE_CASE_NAME_PASCAL_CASE__ } from '@/domain/usecases'
        import { UnexpectedError, AccessDeniedError } from '@/domain/errors'

        /**
         * External API implementation of __USE_CASE_NAME_PASCAL_CASE__ use case
         * For integrating with 3rd party services
         */
        export class Remote__USE_CASE_NAME_PASCAL_CASE__ implements __USE_CASE_NAME_PASCAL_CASE__ {
          constructor (
            private readonly url: string,
            private readonly httpClient: HttpClient<Remote__USE_CASE_NAME_PASCAL_CASE__.Model>
          ) {}

          async __USE_CASE_METHOD_NAME__ (params: __USE_CASE_NAME_PASCAL_CASE__.Params): Promise<__USE_CASE_NAME_PASCAL_CASE__.Model> {
            const httpResponse = await this.httpClient.request({
              url: this.url,
              method: 'post',
              body: params,
              headers: {
                'Content-Type': 'application/json',
                'X-API-Key': process.env.__EXTERNAL_API_KEY__
              }
            })

            switch (httpResponse.statusCode) {
              case HttpStatusCode.ok: return httpResponse.body
              case HttpStatusCode.unauthorized: throw new AccessDeniedError()
              case HttpStatusCode.forbidden: throw new AccessDeniedError()
              default: throw new UnexpectedError()
            }
          }
        }

        export namespace Remote__USE_CASE_NAME_PASCAL_CASE__ {
          export type Model = __USE_CASE_NAME_PASCAL_CASE__.Model
        }

    # === STEP 7: RUN ALL TESTS (GREEN PHASE) ===
    - id: 'run-passing-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Verify all backend tests pass with implementations (GREEN phase)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'test driven development green phase'
          url: 'https://github.com/...'
          description: 'TDD Green phase - making tests pass.'
      run_scripts:
        description: 'Run tests to verify GREEN phase completion'
        scripts:
          - name: 'Run all data layer tests'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Commit GREEN phase'
            command: 'git add . && git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): implement backend data layer (GREEN)"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 8: REFACTOR DATABASE IMPLEMENTATION (REFACTOR PHASE) ===
    - id: 'refactor-database-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Refactor Db__USE_CASE_NAME_PASCAL_CASE__ with better error handling and logging (REFACTOR)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'test driven development refactor phase'
          url: 'https://github.com/...'
          description: 'TDD Refactor phase - improving code without breaking tests.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/db-__USE_CASE_NAME_KEBAB_CASE__.ts'
      template: |
        import { __USE_CASE_NAME_PASCAL_CASE__ } from '@/domain/usecases'
        import { __PROTOCOL_1__, __PROTOCOL_2__, LogErrorRepository } from '@/data/protocols'

        /**
         * Database implementation of __USE_CASE_NAME_PASCAL_CASE__ use case
         * Refactored version with error handling and logging
         */
        export class Db__USE_CASE_NAME_PASCAL_CASE__ implements __USE_CASE_NAME_PASCAL_CASE__ {
          constructor (
            private readonly __DEPENDENCY_1_CAMEL_CASE__: __PROTOCOL_1__,
            private readonly __DEPENDENCY_2_CAMEL_CASE__: __PROTOCOL_2__,
            private readonly logErrorRepository?: LogErrorRepository
          ) {}

          async __USE_CASE_METHOD_NAME__ (params: __USE_CASE_NAME_PASCAL_CASE__.Params): Promise<__USE_CASE_NAME_PASCAL_CASE__.Result> {
            try {
              // Check preconditions
              const exists = await this.__DEPENDENCY_1_CAMEL_CASE__.check(params.__INPUT_FIELD_1__)
              if (exists) {
                return null
              }

              // Process data
              const processed = await this.__DEPENDENCY_1_CAMEL_CASE__.process(params)

              // Save to repository
              const result = await this.__DEPENDENCY_2_CAMEL_CASE__.save({
                ...params,
                ...processed,
                createdAt: new Date()
              })

              return result
            } catch (error) {
              if (this.logErrorRepository) {
                await this.logErrorRepository.logError(error.stack)
              }
              throw error
            }
          }
        }

    # === STEP 9: REFACTOR EXTERNAL API IMPLEMENTATION (REFACTOR PHASE - CONDITIONAL) ===
    - id: 'refactor-external-api-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Refactor Remote__USE_CASE_NAME_PASCAL_CASE__ with retry logic and better error handling (REFACTOR)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: '__REQUIRES_EXTERNAL_API__'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/remote-__USE_CASE_NAME_KEBAB_CASE__.ts'
      template: |
        import { HttpClient, HttpStatusCode } from '@/data/protocols/http'
        import { __USE_CASE_NAME_PASCAL_CASE__ } from '@/domain/usecases'
        import { UnexpectedError, AccessDeniedError, ApiRateLimitError } from '@/domain/errors'

        /**
         * External API implementation of __USE_CASE_NAME_PASCAL_CASE__ use case
         * Refactored version with retry logic and comprehensive error handling
         */
        export class Remote__USE_CASE_NAME_PASCAL_CASE__ implements __USE_CASE_NAME_PASCAL_CASE__ {
          constructor (
            private readonly url: string,
            private readonly httpClient: HttpClient<Remote__USE_CASE_NAME_PASCAL_CASE__.Model>,
            private readonly maxRetries: number = 3
          ) {}

          async __USE_CASE_METHOD_NAME__ (params: __USE_CASE_NAME_PASCAL_CASE__.Params): Promise<__USE_CASE_NAME_PASCAL_CASE__.Model> {
            let lastError: Error

            for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
              try {
                const httpResponse = await this.httpClient.request({
                  url: this.url,
                  method: 'post',
                  body: params,
                  headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': process.env.__EXTERNAL_API_KEY__,
                    'X-Request-ID': `${Date.now()}-${attempt}`
                  }
                })

                const remoteData = httpResponse.body || {}

                switch (httpResponse.statusCode) {
                  case HttpStatusCode.ok:
                    return this.adapt(remoteData)
                  case HttpStatusCode.noContent:
                    return this.getDefaultResponse()
                  case HttpStatusCode.unauthorized:
                  case HttpStatusCode.forbidden:
                    throw new AccessDeniedError()
                  case HttpStatusCode.tooManyRequests:
                    throw new ApiRateLimitError()
                  default:
                    lastError = new UnexpectedError()
                    if (attempt < this.maxRetries) {
                      await this.delay(attempt * 1000) // Exponential backoff
                      continue
                    }
                    throw lastError
                }
              } catch (error) {
                lastError = error
                if (attempt === this.maxRetries) throw error
              }
            }

            throw lastError
          }

          private adapt(remoteData: Remote__USE_CASE_NAME_PASCAL_CASE__.Model): __USE_CASE_NAME_PASCAL_CASE__.Model {
            return {
              __OUTPUT_FIELD_1__: remoteData.__OUTPUT_FIELD_1__,
              __OUTPUT_FIELD_2__: remoteData.__OUTPUT_FIELD_2__,
              __TIMESTAMP_FIELD__: new Date(remoteData.__TIMESTAMP_FIELD__)
            }
          }

          private getDefaultResponse(): __USE_CASE_NAME_PASCAL_CASE__.Model {
            return {
              __OUTPUT_FIELD_1__: '',
              __OUTPUT_FIELD_2__: '',
              __TIMESTAMP_FIELD__: new Date()
            }
          }

          private delay(ms: number): Promise<void> {
            return new Promise(resolve => setTimeout(resolve, ms))
          }
        }

        export namespace Remote__USE_CASE_NAME_PASCAL_CASE__ {
          export type Model = {
            __OUTPUT_FIELD_1__: string
            __OUTPUT_FIELD_2__: string
            __TIMESTAMP_FIELD__: string
          }
        }

    # === STEP 10: FINAL VALIDATION (REFACTOR PHASE) ===
    - id: 'validate-refactored-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Run all tests and validations after refactoring (REFACTOR phase complete)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'TESTING_STRATEGY.md'
          description: 'Complete test coverage and validation requirements.'
      run_scripts:
        description: 'Complete TDD cycle validation and commit refactored code'
        scripts:
          - name: 'Run all backend data tests'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data --coverage'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'TypeScript compilation check'
            command: 'npx tsc --noEmit --project tsconfig.json'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'ESLint validation'
            command: 'npm run lint -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Commit refactored implementation'
            command: 'git add . && git commit -m "refactor(__FEATURE_NAME_KEBAB_CASE__): improve backend data layer design (REFACTOR)"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 11: INTEGRATION TESTS ===
    - id: 'create-integration-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create integration tests for backend data layer'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'integration testing backend node.js'
          url: 'https://github.com/...'
          description: 'Integration testing patterns for backend applications.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/__tests__/integration/data-integration.spec.ts'
      template: |
        import { Db__USE_CASE_NAME_PASCAL_CASE__ } from '../../data/usecases/db-__USE_CASE_NAME_KEBAB_CASE__'
        // import { Remote__USE_CASE_NAME_PASCAL_CASE__ } from '../../data/usecases/remote-__USE_CASE_NAME_KEBAB_CASE__'

        /**
         * Integration tests for backend data layer
         * Tests database operations and external API integrations if needed
         */
        describe('Backend Data Layer Integration', () => {
          describe('Db__USE_CASE_NAME_PASCAL_CASE__', () => {
            it('should create data in database successfully', async () => {
              // Test real database integration
            })
          })

          // Uncomment if external API is used
          // describe('Remote__USE_CASE_NAME_PASCAL_CASE__', () => {
          //   it('should integrate with external API successfully', async () => {
          //     // Test real external API integration
          //   })
          // })
        })

    # === STEP 12: VALIDATE COMPLETE DATA LAYER ===
    - id: 'validate-complete-data-layer-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Final validation of complete backend data layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'CI_CD.md'
          description: 'Following CI/CD validation requirements.'
      run_scripts:
        description: 'Run comprehensive validation of backend data layer'
        scripts:
          - name: 'Complete test suite'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__ --coverage --runInBand'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Build check'
            command: 'npm run build'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Final commit'
            command: 'git add . && git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): complete backend data layer with TDD"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 13: OPEN PULL REQUEST ===
    - id: 'open-pull-request-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Open Pull Request for backend data layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Pull Request process and review guidelines.'
      run_scripts:
        description: 'Create pull request with comprehensive description'
        scripts:
          - name: 'Push final changes'
            command: 'git push origin feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-backend'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Create Pull Request'
            command: |
              gh pr create \
                --title "feat(__FEATURE_NAME_KEBAB_CASE__): implement backend data layer for __USE_CASE_NAME_PASCAL_CASE__" \
                --body "## Summary

              Implements backend data layer with support for both database and external API integrations.

              ### Database Implementation (Db__USE_CASE_NAME_PASCAL_CASE__)
              - ‚úÖ Following DbAddAccount pattern (20-25 lines)
              - ‚úÖ Simple repository orchestration
              - ‚úÖ Error handling and logging

              ### External API Implementation (Remote__USE_CASE_NAME_PASCAL_CASE__) - If needed
              - ‚úÖ HTTP client integration for 3rd party APIs
              - ‚úÖ Retry logic with exponential backoff
              - ‚úÖ Comprehensive error handling

              ### Testing
              - ‚úÖ TDD methodology (RED-GREEN-REFACTOR)
              - ‚úÖ Unit tests for all implementations
              - ‚úÖ Integration tests for real operations

              Follows established patterns from real codebase." \
                --draft
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 14: AI CODE REVIEW ===
    - id: 'ai-code-review-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'AI-powered code review focusing on pattern consistency'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'AI_CODE_REVIEW.md'
          description: 'AI review patterns and quality gates.'
      ai_review_prompts:
        database_pattern_check: |
          Review the Db__USE_CASE_NAME_PASCAL_CASE__ implementation:
          - Should follow DbAddAccount pattern (20-25 lines)
          - Constructor injection of repository protocols
          - Simple orchestration logic, no complex business rules
          - Error logging if LogErrorRepository is provided
          - Compare with: DbAddAccount, DbAuthentication

        external_api_pattern_check: |
          Review the Remote__USE_CASE_NAME_PASCAL_CASE__ implementation (if exists):
          - Constructor: url + httpClient + optional maxRetries
          - Retry logic with exponential backoff
          - Comprehensive error handling for different status codes
          - API key from environment variables
          - Data adaptation methods

    # === STEP 15: CLEANUP AND MERGE ===
    - id: 'cleanup-and-merge-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Final cleanup and merge backend data layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Merge process and branch cleanup.'
      run_scripts:
        description: 'Complete PR merge and cleanup process'
        scripts:
          - name: 'Final validation'
            command: 'npm run validate:all -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Merge Pull Request'
            command: 'gh pr merge --squash --delete-branch'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Cleanup'
            command: 'git checkout main && git pull origin main && git branch -d feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-backend'
            workingDirectory: '__PROJECT_NAME__'

  # ------------------------------------------------------------------------------
  # BROWNFIELD REFACTORING STEPS (OPTIONAL)
  # For existing backend projects that need to separate database and external APIs
  # ------------------------------------------------------------------------------

  brownfield_data_steps:
    # === STEP 16: IDENTIFY MIXED IMPLEMENTATIONS ===
    - id: 'identify-mixed-implementations-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'analysis'
      description: 'Identify existing mixed database/external API code to refactor'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'REFACTORING_GUIDE.md'
          description: 'Brownfield refactoring strategies for backend separation.'
      analysis_script: |
        echo "üîç Searching for mixed implementations..."
        grep -r "prisma\|mongoose\|axios\|fetch" --include="*.ts" src/ || true
        echo "üìã Identifying database vs external API calls..."
        find src/ -name "*repository*.ts" || true
        find src/ -name "*http*.ts" || true

    # === STEP 17: CREATE SEPARATION STRATEGY ===
    - id: 'create-separation-strategy-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Plan separation of database and external API layers'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      migration_strategy: |
        1. Identify all direct database calls (move to Db implementations)
        2. Identify all external API calls (move to Remote implementations)
        3. Create protocols for both types of operations
        4. Replace direct calls with protocol-based implementations
        5. Test both layers independently
        6. Remove legacy mixed code

    # === STEP 18: GRADUAL MIGRATION ===
    - id: 'gradual-migration-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Implement gradual migration from mixed to separated layers'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'strangler fig pattern backend refactoring'
          url: 'https://github.com/...'
          description: 'Gradual migration pattern for backend applications.'
      run_scripts:
        description: 'Execute migration with feature flags'
        scripts:
          - name: 'Create feature flag'
            command: 'echo "USE_SEPARATED_DATA_LAYERS=true" >> .env'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Run parallel implementations'
            command: 'npm run dev'
            workingDirectory: '__PROJECT_NAME__'

# ============= END DATA STEPS BACKEND SECTION =============