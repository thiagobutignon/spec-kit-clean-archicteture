# ============= BEGIN DATA STEPS FRONTEND SECTION =============

  # ------------------------------------------------------------------------------
  # AI-NOTE: DATA LAYER IMPLEMENTATION STEPS FOR FRONTEND (TDD)
  # These steps implement data layer following RED-GREEN-REFACTOR cycle
  # Specific to frontend with Remote prefix, Fetch API, and Next.js 15 patterns
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # DATA LAYER STEPS SECTION
  # Steps for generating data layer artifacts in frontend features
  # Following Test-Driven Development (RED-GREEN-REFACTOR) methodology
  # Using Remote prefix, Fetch API, and frontend-specific patterns
  # ------------------------------------------------------------------------------

  data_steps:
    # === STEP 1: CREATE FEATURE BRANCH ===
    - id: 'create-feature-branch-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create feature branch for __USE_CASE_NAME_PASCAL_CASE__ frontend data layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Following Git Flow pattern for feature development.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'git workflow feature branch naming conventions'
          url: 'https://github.com/...'
          description: 'Git Flow and feature branch best practices.'
      run_scripts:
        description: 'Create and checkout feature branch for data layer development'
        scripts:
          - name: 'Create feature branch'
            command: 'git checkout -b feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Verify branch creation'
            command: 'git branch --show-current'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Push feature branch'
            command: 'git push -u origin feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'
      validation_script: |
        current_branch=$(git branch --show-current)
        expected_branch="feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-frontend"
        if [ "$current_branch" != "$expected_branch" ]; then
          echo "‚ùå ERROR: Expected branch $expected_branch, but current branch is $current_branch"
          exit 1
        fi
        echo "‚úÖ Feature branch created successfully: $current_branch"

    # === STEP 2: CREATE DATA STRUCTURE (RED PHASE) ===
    - id: 'create-data-structure-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'folder'
      description: 'Create data layer folder structure for __USE_CASE_NAME_PASCAL_CASE__ frontend use case'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'FRONTEND_ARCHITECTURE.md'
          description: 'Following Clean Architecture data layer structure for frontend.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'clean architecture data layer frontend typescript fetch api'
          url: 'https://github.com/...'
          description: 'Data layer patterns for frontend with Fetch API.'
      action:
        create_folders:
          basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data'
          folders:
            - 'usecases'     # Use case implementations (Remote prefix)
            - 'protocols'    # HTTP/API protocol interfaces

    # === STEP 3: CREATE PROTOCOL INTERFACES (RED PHASE) ===
    - id: 'create-data-protocols-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create HTTP/API protocol interfaces for __USE_CASE_NAME_PASCAL_CASE__ data layer (RED)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'dependency inversion protocol interfaces http api frontend'
          url: 'https://github.com/...'
          description: 'Protocol interfaces for HTTP/API dependencies.'
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '*Protocol'
          description: 'Consistent with existing protocol naming patterns.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/protocols/__USE_CASE_NAME_KEBAB_CASE__-http-client.ts'
      template: |
        /**
         * HTTP client protocol for __USE_CASE_NAME_PASCAL_CASE__ frontend operations
         * Abstracts HTTP/API communication from the data layer
         *
         * @protocol HTTP Client Protocol
         * @layer Data Layer - Protocol Interface
         * @pattern Dependency Inversion - Abstract HTTP operations
         */
        export interface __USE_CASE_NAME_PASCAL_CASE__HttpClient {
          /**
           * Perform HTTP request for __USE_CASE_NAME_PASCAL_CASE__ operation
           *
           * @param request - HTTP request parameters
           * @returns Promise with HTTP response data
           * @throws Will throw HttpError for network or API errors
           */
          request<T = unknown>(request: HttpRequest): Promise<HttpResponse<T>>
        }

        /**
         * HTTP request parameters for frontend API calls
         */
        export interface HttpRequest {
          url: string
          method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'
          headers?: Record<string, string>
          body?: unknown
          signal?: AbortSignal // For request cancellation
        }

        /**
         * HTTP response structure for frontend API responses
         */
        export interface HttpResponse<T = unknown> {
          data: T
          status: number
          statusText: string
          headers: Record<string, string>
        }

        /**
         * Cache protocol for frontend data layer (optional)
         */
        export interface __USE_CASE_NAME_PASCAL_CASE__CacheClient {
          /**
           * Get cached data
           */
          get<T = unknown>(key: string): Promise<T | null>

          /**
           * Set cached data with TTL
           */
          set<T = unknown>(key: string, value: T, ttl?: number): Promise<void>

          /**
           * Invalidate cached data
           */
          invalidate(key: string): Promise<void>
        }

    # === STEP 4: CREATE FAILING TESTS (RED PHASE) ===
    - id: 'create-data-failing-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create failing tests for Remote__USE_CASE_NAME_PASCAL_CASE__ data implementation (RED)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'test driven development red phase vitest frontend mocking'
          url: 'https://github.com/...'
          description: 'TDD RED phase patterns for frontend with Vitest.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/remote-__USE_CASE_NAME_KEBAB_CASE__.spec.ts'
      template: |
        import { describe, it, expect, beforeEach, vi, type MockedFunction } from 'vitest'
        import type {
          __USE_CASE_NAME_PASCAL_CASE__,
          __USE_CASE_NAME_PASCAL_CASE__Input,
          __USE_CASE_NAME_PASCAL_CASE__Output
        } from '../../domain/usecases/__USE_CASE_NAME_KEBAB_CASE__'
        import type {
          __USE_CASE_NAME_PASCAL_CASE__HttpClient,
          HttpRequest,
          HttpResponse
        } from '../protocols/__USE_CASE_NAME_KEBAB_CASE__-http-client'
        import { Remote__USE_CASE_NAME_PASCAL_CASE__ } from './remote-__USE_CASE_NAME_KEBAB_CASE__'

        /**
         * TDD Tests for Remote__USE_CASE_NAME_PASCAL_CASE__ data layer implementation
         * Following RED-GREEN-REFACTOR cycle for frontend data operations
         *
         * @testType Integration Test - Data Layer with Mocked HTTP
         * @phase RED - These tests should FAIL initially
         */
        describe('Remote__USE_CASE_NAME_PASCAL_CASE__ (TDD RED Phase)', () => {
          let sut: Remote__USE_CASE_NAME_PASCAL_CASE__
          let httpClientMock: {
            request: MockedFunction<__USE_CASE_NAME_PASCAL_CASE__HttpClient['request']>
          }

          beforeEach(() => {
            httpClientMock = {
              request: vi.fn()
            }
            sut = new Remote__USE_CASE_NAME_PASCAL_CASE__(httpClientMock)
          })

          describe('RED Phase - These should FAIL', () => {
            it('should implement __USE_CASE_NAME_PASCAL_CASE__ interface', () => {
              // RED: This will fail because Remote__USE_CASE_NAME_PASCAL_CASE__ doesn't exist yet
              expect(sut).toBeInstanceOf(Remote__USE_CASE_NAME_PASCAL_CASE__)
              expect(typeof sut.execute).toBe('function')
            })

            it('should make HTTP request with correct parameters', async () => {
              // RED: This will fail because implementation doesn't exist
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'test-value-1',
                __INPUT_FIELD_2__: 'test-value-2'
              }

              const expectedResponse: HttpResponse<any> = {
                data: {
                  __OUTPUT_FIELD_1__: 'response-1',
                  __OUTPUT_FIELD_2__: 'response-2',
                  __OUTPUT_FIELD_3__: 123,
                  __TIMESTAMP_FIELD__: '2024-01-01T00:00:00.000Z',
                  success: true
                },
                status: 200,
                statusText: 'OK',
                headers: {}
              }

              httpClientMock.request.mockResolvedValueOnce(expectedResponse)

              await sut.execute(input)

              expect(httpClientMock.request).toHaveBeenCalledWith({
                url: '/api/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json'
                },
                body: input
              })
            })

            it('should return domain output type from HTTP response', async () => {
              // RED: This will fail because transformation doesn't exist
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'test-value-1',
                __INPUT_FIELD_2__: 'test-value-2'
              }

              const httpResponse: HttpResponse<any> = {
                data: {
                  __OUTPUT_FIELD_1__: 'api-response-1',
                  __OUTPUT_FIELD_2__: 'api-response-2',
                  __OUTPUT_FIELD_3__: 456,
                  __TIMESTAMP_FIELD__: '2024-01-01T00:00:00.000Z',
                  success: true
                },
                status: 200,
                statusText: 'OK',
                headers: {}
              }

              httpClientMock.request.mockResolvedValueOnce(httpResponse)

              const result = await sut.execute(input)

              const expectedOutput: __USE_CASE_NAME_PASCAL_CASE__Output = {
                __OUTPUT_FIELD_1__: 'api-response-1',
                __OUTPUT_FIELD_2__: 'api-response-2',
                __OUTPUT_FIELD_3__: 456,
                __TIMESTAMP_FIELD__: new Date('2024-01-01T00:00:00.000Z'),
                success: true
              }

              expect(result).toEqual(expectedOutput)
            })

            it('should handle HTTP errors appropriately', async () => {
              // RED: This will fail because error handling doesn't exist
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'error-trigger',
                __INPUT_FIELD_2__: 'test'
              }

              const httpError = new Error('Network Error')
              httpClientMock.request.mockRejectedValueOnce(httpError)

              await expect(sut.execute(input)).rejects.toThrow('Failed to execute __USE_CASE_NAME_PASCAL_CASE__')
            })

            it('should handle 404 responses gracefully', async () => {
              // RED: This will fail because status code handling doesn't exist
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'not-found',
                __INPUT_FIELD_2__: 'test'
              }

              const notFoundResponse: HttpResponse<any> = {
                data: { error: 'Not found' },
                status: 404,
                statusText: 'Not Found',
                headers: {}
              }

              httpClientMock.request.mockResolvedValueOnce(notFoundResponse)

              await expect(sut.execute(input)).rejects.toThrow('Resource not found')
            })

            it('should handle validation errors from API', async () => {
              // RED: This will fail because validation error handling doesn't exist
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: '',
                __INPUT_FIELD_2__: 'test'
              }

              const validationResponse: HttpResponse<any> = {
                data: {
                  error: 'Validation failed',
                  details: ['__INPUT_FIELD_1__ is required']
                },
                status: 400,
                statusText: 'Bad Request',
                headers: {}
              }

              httpClientMock.request.mockResolvedValueOnce(validationResponse)

              await expect(sut.execute(input)).rejects.toThrow('Validation failed')
            })
          })

          describe('Type Safety Tests (RED Phase)', () => {
            it('should ensure input type compatibility', () => {
              // RED: Will fail if types are not properly defined
              const validInput: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'string-value',
                __INPUT_FIELD_2__: 'another-string',
                __INPUT_FIELD_3__: 'optional-field'
              }

              expect(validInput).toBeDefined()
            })

            it('should ensure output type compatibility', async () => {
              // RED: Will fail if return type is not correct
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'test',
                __INPUT_FIELD_2__: 'test'
              }

              httpClientMock.request.mockResolvedValueOnce({
                data: {
                  __OUTPUT_FIELD_1__: 'result',
                  __OUTPUT_FIELD_2__: 'result',
                  __OUTPUT_FIELD_3__: 1,
                  __TIMESTAMP_FIELD__: '2024-01-01T00:00:00.000Z',
                  success: true
                },
                status: 200,
                statusText: 'OK',
                headers: {}
              })

              const result = await sut.execute(input)

              // TypeScript should enforce these types
              expect(typeof result.__OUTPUT_FIELD_1__).toBe('string')
              expect(typeof result.__OUTPUT_FIELD_3__).toBe('number')
              expect(result.__TIMESTAMP_FIELD__).toBeInstanceOf(Date)
              expect(typeof result.success).toBe('boolean')
            })
          })
        })

      validation_script: |
        run_failing_tests() {
          echo "üî¥ RED PHASE: Running failing tests..."
          npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data --reporter=verbose || {
            echo "‚úÖ Tests are failing as expected (RED phase)"
            return 0
          }
          echo "‚ùå ERROR: Tests should be failing in RED phase!"
          exit 1
        }

        stage_red_phase() {
          git add .
          git commit -m "test(__FEATURE_NAME_KEBAB_CASE__): add failing tests for __USE_CASE_NAME_KEBAB_CASE__ data layer (RED)"
          echo "‚úÖ RED phase committed"
        }

        run_failing_tests
        stage_red_phase

    # === STEP 5: CREATE DATA IMPLEMENTATION (GREEN PHASE) ===
    - id: 'create-data-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create Remote__USE_CASE_NAME_PASCAL_CASE__ implementation to make tests pass (GREEN)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'clean architecture data layer implementation frontend fetch api'
          url: 'https://github.com/...'
          description: 'Data layer implementation patterns for frontend.'
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: 'Remote*'
          description: 'Consistent with existing Remote implementations.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/remote-__USE_CASE_NAME_KEBAB_CASE__.ts'
      template: |
        import type {
          __USE_CASE_NAME_PASCAL_CASE__,
          __USE_CASE_NAME_PASCAL_CASE__Input,
          __USE_CASE_NAME_PASCAL_CASE__Output
        } from '../../domain/usecases/__USE_CASE_NAME_KEBAB_CASE__'
        import type {
          __USE_CASE_NAME_PASCAL_CASE__HttpClient,
          HttpResponse
        } from '../protocols/__USE_CASE_NAME_KEBAB_CASE__-http-client'

        /**
         * Remote implementation of __USE_CASE_NAME_PASCAL_CASE__ use case
         * Handles HTTP/API communication for frontend data operations
         *
         * @implementation Data Layer - Remote HTTP Implementation
         * @pattern Repository Pattern - Frontend HTTP variant
         * @layer Data Layer - Implements domain use case via HTTP
         */
        export class Remote__USE_CASE_NAME_PASCAL_CASE__ implements __USE_CASE_NAME_PASCAL_CASE__ {
          /**
           * Creates Remote__USE_CASE_NAME_PASCAL_CASE__ with HTTP client dependency
           *
           * @param httpClient - HTTP client for API communication
           */
          constructor(
            private readonly httpClient: __USE_CASE_NAME_PASCAL_CASE__HttpClient
          ) {}

          /**
           * Execute __USE_CASE_NAME_PASCAL_CASE__ via HTTP API call
           *
           * @param input - Use case input parameters
           * @returns Promise with use case output
           * @throws Error if HTTP request fails or API returns error
           */
          async execute(input: __USE_CASE_NAME_PASCAL_CASE__Input): Promise<__USE_CASE_NAME_PASCAL_CASE__Output> {
            try {
              // Validate input before making HTTP request
              this.validateInput(input)

              // Make HTTP request to backend API
              const response = await this.httpClient.request<any>({
                url: `/api/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__`,
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json'
                },
                body: input
              })

              // Handle different HTTP status codes
              this.validateHttpResponse(response)

              // Transform HTTP response to domain output
              return this.transformToDomainOutput(response)

            } catch (error) {
              // Transform infrastructure errors to domain errors
              throw this.handleError(error, input)
            }
          }

          /**
           * Validate input parameters
           *
           * @private
           * @param input - Input to validate
           * @throws Error if validation fails
           */
          private validateInput(input: __USE_CASE_NAME_PASCAL_CASE__Input): void {
            if (!input.__INPUT_FIELD_1__) {
              throw new Error('Missing required field: __INPUT_FIELD_1__')
            }

            if (!input.__INPUT_FIELD_2__) {
              throw new Error('Missing required field: __INPUT_FIELD_2__')
            }

            // Additional validation rules can be added here
          }

          /**
           * Validate HTTP response status
           *
           * @private
           * @param response - HTTP response to validate
           * @throws Error if response indicates error
           */
          private validateHttpResponse(response: HttpResponse<any>): void {
            if (response.status === 404) {
              throw new Error('Resource not found')
            }

            if (response.status === 400) {
              const errorMessage = response.data?.error || 'Validation failed'
              throw new Error(errorMessage)
            }

            if (response.status >= 400) {
              throw new Error(`HTTP Error: ${response.status} ${response.statusText}`)
            }
          }

          /**
           * Transform HTTP response data to domain output type
           *
           * @private
           * @param response - HTTP response from API
           * @returns Domain output object
           */
          private transformToDomainOutput(response: HttpResponse<any>): __USE_CASE_NAME_PASCAL_CASE__Output {
            const data = response.data

            return {
              __OUTPUT_FIELD_1__: data.__OUTPUT_FIELD_1__,
              __OUTPUT_FIELD_2__: data.__OUTPUT_FIELD_2__,
              __OUTPUT_FIELD_3__: data.__OUTPUT_FIELD_3__,
              __TIMESTAMP_FIELD__: new Date(data.__TIMESTAMP_FIELD__),
              success: data.success || true
            }
          }

          /**
           * Handle and transform errors to domain-appropriate errors
           *
           * @private
           * @param error - Original error from HTTP operation
           * @param input - Original input for context
           * @returns Domain-appropriate error
           */
          private handleError(error: any, input: __USE_CASE_NAME_PASCAL_CASE__Input): Error {
            // Log error for debugging (in development)
            if (process.env.NODE_ENV === 'development') {
              console.error('Remote__USE_CASE_NAME_PASCAL_CASE__ error:', error, 'Input:', input)
            }

            // Return domain-appropriate error
            if (error.message.includes('Network')) {
              return new Error('Network error occurred. Please check your connection.')
            }

            if (error.message.includes('404')) {
              return new Error('Resource not found')
            }

            if (error.message.includes('Validation')) {
              return new Error('Validation failed')
            }

            // Default error transformation
            return new Error(`Failed to execute __USE_CASE_NAME_PASCAL_CASE__: ${error.message}`)
          }
        }

    # === STEP 6: RUN PASSING TESTS (GREEN PHASE) ===
    - id: 'run-passing-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Verify all tests pass with implementation (GREEN phase)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      run_scripts:
        description: 'Run tests to verify GREEN phase completion'
        scripts:
          - name: 'Run passing tests'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data --coverage'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Commit GREEN phase'
            command: 'git add . && git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): implement __USE_CASE_NAME_KEBAB_CASE__ data layer (GREEN)"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 7: REFACTOR IMPLEMENTATION (REFACTOR PHASE) ===
    - id: 'refactor-data-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Refactor Remote__USE_CASE_NAME_PASCAL_CASE__ for better design (REFACTOR)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'refactoring patterns clean code frontend typescript'
          url: 'https://github.com/...'
          description: 'Refactoring patterns for cleaner code.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/remote-__USE_CASE_NAME_KEBAB_CASE__.ts'
      template: |
        import type {
          __USE_CASE_NAME_PASCAL_CASE__,
          __USE_CASE_NAME_PASCAL_CASE__Input,
          __USE_CASE_NAME_PASCAL_CASE__Output
        } from '../../domain/usecases/__USE_CASE_NAME_KEBAB_CASE__'
        import type {
          __USE_CASE_NAME_PASCAL_CASE__HttpClient,
          HttpResponse
        } from '../protocols/__USE_CASE_NAME_KEBAB_CASE__-http-client'

        /**
         * Remote implementation of __USE_CASE_NAME_PASCAL_CASE__ use case
         * Refactored for better maintainability and error handling
         *
         * @implementation Data Layer - Remote HTTP Implementation (Refactored)
         * @pattern Repository Pattern - Frontend HTTP variant with improved design
         * @layer Data Layer - Clean, testable, maintainable implementation
         */
        export class Remote__USE_CASE_NAME_PASCAL_CASE__ implements __USE_CASE_NAME_PASCAL_CASE__ {
          private static readonly API_ENDPOINT = '/api/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__'
          private static readonly REQUEST_HEADERS = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          } as const

          /**
           * Creates Remote__USE_CASE_NAME_PASCAL_CASE__ with HTTP client dependency
           *
           * @param httpClient - HTTP client for API communication
           */
          constructor(
            private readonly httpClient: __USE_CASE_NAME_PASCAL_CASE__HttpClient
          ) {}

          /**
           * Execute __USE_CASE_NAME_PASCAL_CASE__ via HTTP API call
           *
           * @param input - Use case input parameters
           * @returns Promise with use case output
           * @throws Error if HTTP request fails or API returns error
           */
          async execute(input: __USE_CASE_NAME_PASCAL_CASE__Input): Promise<__USE_CASE_NAME_PASCAL_CASE__Output> {
            // Input validation
            InputValidator.validate(input)

            try {
              // Make HTTP request
              const response = await this.makeHttpRequest(input)

              // Validate and transform response
              return ResponseTransformer.transform(response)

            } catch (error) {
              throw ErrorHandler.handle(error, input)
            }
          }

          /**
           * Make HTTP request to backend API
           *
           * @private
           * @param input - Request input
           * @returns HTTP response
           */
          private async makeHttpRequest(input: __USE_CASE_NAME_PASCAL_CASE__Input): Promise<HttpResponse<any>> {
            const response = await this.httpClient.request<any>({
              url: Remote__USE_CASE_NAME_PASCAL_CASE__.API_ENDPOINT,
              method: 'POST',
              headers: Remote__USE_CASE_NAME_PASCAL_CASE__.REQUEST_HEADERS,
              body: input
            })

            ResponseValidator.validate(response)
            return response
          }
        }

        /**
         * Input validation utilities (Refactored)
         */
        class InputValidator {
          static validate(input: __USE_CASE_NAME_PASCAL_CASE__Input): void {
            const errors: string[] = []

            if (!input.__INPUT_FIELD_1__?.trim()) {
              errors.push('__INPUT_FIELD_1__ is required and cannot be empty')
            }

            if (!input.__INPUT_FIELD_2__?.trim()) {
              errors.push('__INPUT_FIELD_2__ is required and cannot be empty')
            }

            if (input.__INPUT_FIELD_3__ && input.__INPUT_FIELD_3__.length > 100) {
              errors.push('__INPUT_FIELD_3__ cannot exceed 100 characters')
            }

            if (errors.length > 0) {
              throw new ValidationError(`Input validation failed: ${errors.join(', ')}`)
            }
          }
        }

        /**
         * HTTP response validation utilities (Refactored)
         */
        class ResponseValidator {
          static validate(response: HttpResponse<any>): void {
            if (response.status === 404) {
              throw new NotFoundError('Resource not found')
            }

            if (response.status === 400) {
              const errorMessage = response.data?.error || 'Bad request'
              throw new ValidationError(errorMessage)
            }

            if (response.status === 401) {
              throw new UnauthorizedError('Authentication required')
            }

            if (response.status === 403) {
              throw new ForbiddenError('Access denied')
            }

            if (response.status >= 500) {
              throw new ServerError(`Server error: ${response.status} ${response.statusText}`)
            }

            if (response.status >= 400) {
              throw new HttpError(`HTTP error: ${response.status} ${response.statusText}`)
            }
          }
        }

        /**
         * Response transformation utilities (Refactored)
         */
        class ResponseTransformer {
          static transform(response: HttpResponse<any>): __USE_CASE_NAME_PASCAL_CASE__Output {
            const data = response.data

            // Validate required response fields
            if (!data) {
              throw new Error('Empty response data received')
            }

            return {
              __OUTPUT_FIELD_1__: String(data.__OUTPUT_FIELD_1__ || ''),
              __OUTPUT_FIELD_2__: String(data.__OUTPUT_FIELD_2__ || ''),
              __OUTPUT_FIELD_3__: Number(data.__OUTPUT_FIELD_3__ || 0),
              __TIMESTAMP_FIELD__: data.__TIMESTAMP_FIELD__
                ? new Date(data.__TIMESTAMP_FIELD__)
                : new Date(),
              success: Boolean(data.success ?? true)
            }
          }
        }

        /**
         * Error handling utilities (Refactored)
         */
        class ErrorHandler {
          static handle(error: any, input: __USE_CASE_NAME_PASCAL_CASE__Input): Error {
            // Log error in development
            if (process.env.NODE_ENV === 'development') {
              console.error('Remote__USE_CASE_NAME_PASCAL_CASE__ error:', {
                error: error.message,
                stack: error.stack,
                input
              })
            }

            // Return appropriate domain errors
            if (error instanceof ValidationError) return error
            if (error instanceof NotFoundError) return error
            if (error instanceof UnauthorizedError) return error
            if (error instanceof ForbiddenError) return error
            if (error instanceof ServerError) return error
            if (error instanceof HttpError) return error

            // Handle network errors
            if (error.message.includes('fetch') || error.message.includes('network')) {
              return new NetworkError('Network connection failed. Please check your internet connection.')
            }

            // Default error
            return new Error(`__USE_CASE_NAME_PASCAL_CASE__ execution failed: ${error.message}`)
          }
        }

        /**
         * Domain-specific error types for better error handling
         */
        export class ValidationError extends Error {
          constructor(message: string) {
            super(message)
            this.name = 'ValidationError'
          }
        }

        export class NotFoundError extends Error {
          constructor(message: string) {
            super(message)
            this.name = 'NotFoundError'
          }
        }

        export class UnauthorizedError extends Error {
          constructor(message: string) {
            super(message)
            this.name = 'UnauthorizedError'
          }
        }

        export class ForbiddenError extends Error {
          constructor(message: string) {
            super(message)
            this.name = 'ForbiddenError'
          }
        }

        export class ServerError extends Error {
          constructor(message: string) {
            super(message)
            this.name = 'ServerError'
          }
        }

        export class NetworkError extends Error {
          constructor(message: string) {
            super(message)
            this.name = 'NetworkError'
          }
        }

        export class HttpError extends Error {
          constructor(message: string) {
            super(message)
            this.name = 'HttpError'
          }
        }

    # === STEP 8: CREATE INTEGRATION TESTS (REFACTOR PHASE) ===
    - id: 'create-integration-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create integration tests for complete data layer (REFACTOR)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'integration testing frontend data layer http mocking vitest'
          url: 'https://github.com/...'
          description: 'Integration testing patterns for frontend data layer.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/remote-__USE_CASE_NAME_KEBAB_CASE__.integration.spec.ts'
      template: |
        import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
        import type {
          __USE_CASE_NAME_PASCAL_CASE__Input,
          __USE_CASE_NAME_PASCAL_CASE__Output
        } from '../../domain/usecases/__USE_CASE_NAME_KEBAB_CASE__'
        import { Remote__USE_CASE_NAME_PASCAL_CASE__ } from './remote-__USE_CASE_NAME_KEBAB_CASE__'
        import type { __USE_CASE_NAME_PASCAL_CASE__HttpClient } from '../protocols/__USE_CASE_NAME_KEBAB_CASE__-http-client'

        /**
         * Integration tests for Remote__USE_CASE_NAME_PASCAL_CASE__
         * Tests complete data layer functionality with realistic scenarios
         *
         * @testType Integration Test - Complete Data Layer Flow
         * @coverage End-to-end data layer functionality
         */
        describe('Remote__USE_CASE_NAME_PASCAL_CASE__ Integration', () => {
          let sut: Remote__USE_CASE_NAME_PASCAL_CASE__
          let mockFetch: ReturnType<typeof vi.fn>
          let httpClient: __USE_CASE_NAME_PASCAL_CASE__HttpClient

          beforeEach(() => {
            mockFetch = vi.fn()
            global.fetch = mockFetch

            // Create real HTTP client implementation for integration testing
            httpClient = {
              async request(req) {
                const response = await fetch(req.url, {
                  method: req.method,
                  headers: req.headers,
                  body: req.body ? JSON.stringify(req.body) : undefined
                })

                return {
                  data: await response.json(),
                  status: response.status,
                  statusText: response.statusText,
                  headers: Object.fromEntries(response.headers.entries())
                }
              }
            }

            sut = new Remote__USE_CASE_NAME_PASCAL_CASE__(httpClient)
          })

          afterEach(() => {
            vi.restoreAllMocks()
          })

          describe('Success Scenarios', () => {
            it('should handle successful API response', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'integration-test-1',
                __INPUT_FIELD_2__: 'integration-test-2',
                __INPUT_FIELD_3__: 'optional-field'
              }

              const apiResponse = {
                __OUTPUT_FIELD_1__: 'api-result-1',
                __OUTPUT_FIELD_2__: 'api-result-2',
                __OUTPUT_FIELD_3__: 789,
                __TIMESTAMP_FIELD__: '2024-01-15T10:30:00.000Z',
                success: true
              }

              mockFetch.mockResolvedValueOnce({
                ok: true,
                status: 200,
                statusText: 'OK',
                json: () => Promise.resolve(apiResponse),
                headers: new Headers({
                  'content-type': 'application/json'
                })
              })

              const result = await sut.execute(input)

              const expectedOutput: __USE_CASE_NAME_PASCAL_CASE__Output = {
                __OUTPUT_FIELD_1__: 'api-result-1',
                __OUTPUT_FIELD_2__: 'api-result-2',
                __OUTPUT_FIELD_3__: 789,
                __TIMESTAMP_FIELD__: new Date('2024-01-15T10:30:00.000Z'),
                success: true
              }

              expect(result).toEqual(expectedOutput)
              expect(mockFetch).toHaveBeenCalledWith(
                '/api/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__',
                {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                  },
                  body: JSON.stringify(input)
                }
              )
            })

            it('should handle minimal valid input', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'minimal',
                __INPUT_FIELD_2__: 'test'
              }

              const apiResponse = {
                __OUTPUT_FIELD_1__: 'minimal-result',
                __OUTPUT_FIELD_2__: 'test-result',
                __OUTPUT_FIELD_3__: 0,
                __TIMESTAMP_FIELD__: '2024-01-15T10:30:00.000Z',
                success: true
              }

              mockFetch.mockResolvedValueOnce({
                ok: true,
                status: 200,
                statusText: 'OK',
                json: () => Promise.resolve(apiResponse),
                headers: new Headers()
              })

              const result = await sut.execute(input)

              expect(result.success).toBe(true)
              expect(result.__OUTPUT_FIELD_1__).toBe('minimal-result')
            })
          })

          describe('Error Scenarios', () => {
            it('should handle 404 not found errors', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'not-found',
                __INPUT_FIELD_2__: 'test'
              }

              mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 404,
                statusText: 'Not Found',
                json: () => Promise.resolve({ error: 'Resource not found' }),
                headers: new Headers()
              })

              await expect(sut.execute(input)).rejects.toThrow('Resource not found')
            })

            it('should handle 400 validation errors', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: '',
                __INPUT_FIELD_2__: 'test'
              }

              mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                statusText: 'Bad Request',
                json: () => Promise.resolve({
                  error: 'Validation failed',
                  details: ['__INPUT_FIELD_1__ is required']
                }),
                headers: new Headers()
              })

              await expect(sut.execute(input)).rejects.toThrow('Validation failed')
            })

            it('should handle 401 authentication errors', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'unauthorized',
                __INPUT_FIELD_2__: 'test'
              }

              mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 401,
                statusText: 'Unauthorized',
                json: () => Promise.resolve({ error: 'Authentication required' }),
                headers: new Headers()
              })

              await expect(sut.execute(input)).rejects.toThrow('Authentication required')
            })

            it('should handle 500 server errors', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'server-error',
                __INPUT_FIELD_2__: 'test'
              }

              mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 500,
                statusText: 'Internal Server Error',
                json: () => Promise.resolve({ error: 'Internal server error' }),
                headers: new Headers()
              })

              await expect(sut.execute(input)).rejects.toThrow('Server error: 500 Internal Server Error')
            })

            it('should handle network errors', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'network-error',
                __INPUT_FIELD_2__: 'test'
              }

              mockFetch.mockRejectedValueOnce(new Error('fetch failed'))

              await expect(sut.execute(input)).rejects.toThrow('Network connection failed')
            })
          })

          describe('Data Transformation', () => {
            it('should correctly transform API response to domain output', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'transform-test',
                __INPUT_FIELD_2__: 'test'
              }

              const apiResponse = {
                __OUTPUT_FIELD_1__: 'api-string',
                __OUTPUT_FIELD_2__: 'another-string',
                __OUTPUT_FIELD_3__: '123', // String in API
                __TIMESTAMP_FIELD__: '2024-01-15T10:30:00.000Z',
                success: 'true' // String in API
              }

              mockFetch.mockResolvedValueOnce({
                ok: true,
                status: 200,
                statusText: 'OK',
                json: () => Promise.resolve(apiResponse),
                headers: new Headers()
              })

              const result = await sut.execute(input)

              // Verify type transformations
              expect(typeof result.__OUTPUT_FIELD_1__).toBe('string')
              expect(typeof result.__OUTPUT_FIELD_2__).toBe('string')
              expect(typeof result.__OUTPUT_FIELD_3__).toBe('number')
              expect(result.__OUTPUT_FIELD_3__).toBe(123)
              expect(result.__TIMESTAMP_FIELD__).toBeInstanceOf(Date)
              expect(typeof result.success).toBe('boolean')
              expect(result.success).toBe(true)
            })

            it('should handle missing optional fields gracefully', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'missing-fields',
                __INPUT_FIELD_2__: 'test'
              }

              const apiResponse = {
                // Missing some optional fields
                __OUTPUT_FIELD_1__: 'present',
                success: true
              }

              mockFetch.mockResolvedValueOnce({
                ok: true,
                status: 200,
                statusText: 'OK',
                json: () => Promise.resolve(apiResponse),
                headers: new Headers()
              })

              const result = await sut.execute(input)

              expect(result.__OUTPUT_FIELD_1__).toBe('present')
              expect(result.__OUTPUT_FIELD_2__).toBe('') // Default empty string
              expect(result.__OUTPUT_FIELD_3__).toBe(0) // Default number
              expect(result.__TIMESTAMP_FIELD__).toBeInstanceOf(Date)
              expect(result.success).toBe(true)
            })
          })
        })

    # === STEP 9: FINAL VALIDATION (REFACTOR PHASE) ===
    - id: 'validate-refactored-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Run all tests and validations after refactoring (REFACTOR phase complete)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      run_scripts:
        description: 'Complete TDD cycle validation and commit refactored code'
        scripts:
          - name: 'Run all data layer tests'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data --coverage --reporter=verbose'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'TypeScript compilation check'
            command: 'npx tsc --noEmit --project tsconfig.json'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'ESLint validation'
            command: 'npm run lint -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Commit refactored implementation'
            command: 'git add . && git commit -m "refactor(__FEATURE_NAME_KEBAB_CASE__): improve __USE_CASE_NAME_KEBAB_CASE__ data layer design (REFACTOR)"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 10: CREATE INFRASTRUCTURE ADAPTER (OPTIONAL) ===
    - id: 'create-http-adapter-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Create Fetch API adapter implementation for HTTP client protocol'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: 'check_if_http_adapter_needed'
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'fetch api adapter pattern typescript frontend http client'
          url: 'https://github.com/...'
          description: 'Fetch API adapter implementation patterns.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/http/fetch-__USE_CASE_NAME_KEBAB_CASE__-client.ts'
      template: |
        import type {
          __USE_CASE_NAME_PASCAL_CASE__HttpClient,
          HttpRequest,
          HttpResponse
        } from '../../data/protocols/__USE_CASE_NAME_KEBAB_CASE__-http-client'

        /**
         * Fetch API implementation of __USE_CASE_NAME_PASCAL_CASE__HttpClient
         * Concrete adapter for HTTP operations using native Fetch API
         *
         * @implementation Infrastructure Layer - HTTP Adapter
         * @pattern Adapter Pattern - Fetch API implementation
         * @layer Infrastructure - External service communication
         */
        export class Fetch__USE_CASE_NAME_PASCAL_CASE__Client implements __USE_CASE_NAME_PASCAL_CASE__HttpClient {
          private readonly baseUrl: string
          private readonly defaultTimeout: number
          private readonly defaultHeaders: Record<string, string>

          constructor(
            baseUrl: string = process.env.NEXT_PUBLIC_API_BASE_URL || '',
            timeout: number = 30000
          ) {
            this.baseUrl = baseUrl.replace(/\/$/, '') // Remove trailing slash
            this.defaultTimeout = timeout
            this.defaultHeaders = {
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            }
          }

          /**
           * Execute HTTP request using Fetch API
           *
           * @param request - HTTP request configuration
           * @returns Promise with HTTP response
           * @throws Error if request fails or times out
           */
          async request<T = unknown>(request: HttpRequest): Promise<HttpResponse<T>> {
            const url = this.buildUrl(request.url)
            const config = this.buildRequestConfig(request)

            try {
              const response = await this.executeWithTimeout(fetch(url, config))

              const data = await this.parseResponse<T>(response)

              return {
                data,
                status: response.status,
                statusText: response.statusText,
                headers: this.extractHeaders(response)
              }
            } catch (error) {
              throw this.handleRequestError(error, request)
            }
          }

          /**
           * Build complete URL from base URL and request path
           *
           * @private
           * @param path - Request path
           * @returns Complete URL
           */
          private buildUrl(path: string): string {
            // Handle absolute URLs
            if (path.startsWith('http://') || path.startsWith('https://')) {
              return path
            }

            // Handle relative paths
            const cleanPath = path.startsWith('/') ? path : `/${path}`
            return `${this.baseUrl}${cleanPath}`
          }

          /**
           * Build Fetch API request configuration
           *
           * @private
           * @param request - HTTP request
           * @returns Fetch request configuration
           */
          private buildRequestConfig(request: HttpRequest): RequestInit {
            const headers = {
              ...this.defaultHeaders,
              ...request.headers
            }

            const config: RequestInit = {
              method: request.method,
              headers,
              signal: request.signal
            }

            // Add body for non-GET requests
            if (request.body && request.method !== 'GET') {
              config.body = typeof request.body === 'string'
                ? request.body
                : JSON.stringify(request.body)
            }

            return config
          }

          /**
           * Execute request with timeout
           *
           * @private
           * @param fetchPromise - Fetch promise
           * @returns Response with timeout handling
           */
          private async executeWithTimeout(fetchPromise: Promise<Response>): Promise<Response> {
            const timeoutPromise = new Promise<never>((_, reject) => {
              setTimeout(() => reject(new Error('Request timeout')), this.defaultTimeout)
            })

            return Promise.race([fetchPromise, timeoutPromise])
          }

          /**
           * Parse HTTP response data
           *
           * @private
           * @param response - Fetch response
           * @returns Parsed response data
           */
          private async parseResponse<T>(response: Response): Promise<T> {
            const contentType = response.headers.get('content-type') || ''

            if (contentType.includes('application/json')) {
              return await response.json()
            }

            if (contentType.includes('text/')) {
              return await response.text() as unknown as T
            }

            // For other content types, return as blob
            const blob = await response.blob()
            return blob as unknown as T
          }

          /**
           * Extract headers from Fetch response
           *
           * @private
           * @param response - Fetch response
           * @returns Headers object
           */
          private extractHeaders(response: Response): Record<string, string> {
            const headers: Record<string, string> = {}

            response.headers.forEach((value, key) => {
              headers[key] = value
            })

            return headers
          }

          /**
           * Handle and transform request errors
           *
           * @private
           * @param error - Original error
           * @param request - Original request for context
           * @returns Transformed error
           */
          private handleRequestError(error: any, request: HttpRequest): Error {
            if (error.name === 'AbortError') {
              return new Error('Request was cancelled')
            }

            if (error.message.includes('timeout')) {
              return new Error(`Request timeout after ${this.defaultTimeout}ms`)
            }

            if (error.message.includes('fetch')) {
              return new Error(`Network error: ${error.message}`)
            }

            // Log error for debugging in development
            if (process.env.NODE_ENV === 'development') {
              console.error('HTTP Client Error:', {
                error: error.message,
                url: request.url,
                method: request.method
              })
            }

            return new Error(`HTTP request failed: ${error.message}`)
          }
        }

    # === STEP 11: VALIDATE COMPLETE DATA LAYER ===
    - id: 'validate-complete-data-layer-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Final validation of complete frontend data layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      run_scripts:
        description: 'Run comprehensive validation of frontend data layer'
        scripts:
          - name: 'Complete test suite'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data --coverage --run'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'TypeScript strict compilation'
            command: 'npx tsc --noEmit --strict --project tsconfig.json'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'ESLint with strict rules'
            command: 'npm run lint -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data --max-warnings 0'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Clean Architecture validation'
            command: 'npm run arch:check -- --layer=data --feature=__FEATURE_NAME_KEBAB_CASE__ --use-case=__USE_CASE_NAME_KEBAB_CASE__'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Bundle size analysis'
            command: 'npm run analyze -- --feature=__FEATURE_NAME_KEBAB_CASE__'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Final commit'
            command: 'git add . && git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): complete __USE_CASE_NAME_KEBAB_CASE__ frontend data layer with TDD"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 12: OPEN PULL REQUEST ===
    - id: 'open-pull-request-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Open Pull Request for frontend data layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'PULL_REQUEST_TEMPLATE.md'
          description: 'Following PR template and code review guidelines.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'pull request best practices code review checklist'
          url: 'https://github.com/...'
          description: 'PR and code review best practices.'
      run_scripts:
        description: 'Create pull request with comprehensive description and checklist'
        scripts:
          - name: 'Push final changes'
            command: 'git push origin feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Create Pull Request'
            command: |
              gh pr create \
                --title "feat(__FEATURE_NAME_KEBAB_CASE__): implement __USE_CASE_NAME_KEBAB_CASE__ frontend data layer with TDD" \
                --body "## Summary

              Implements complete frontend data layer for __USE_CASE_NAME_PASCAL_CASE__ use case following Clean Architecture and TDD methodology.

              ### üöÄ Features Implemented
              - ‚úÖ Remote__USE_CASE_NAME_PASCAL_CASE__ implementation with HTTP/API communication
              - ‚úÖ Protocol interfaces for dependency inversion (__USE_CASE_NAME_PASCAL_CASE__HttpClient)
              - ‚úÖ Complete TDD cycle (RED-GREEN-REFACTOR) with comprehensive tests
              - ‚úÖ Error handling with domain-appropriate error types
              - ‚úÖ Type-safe implementation with TypeScript
              - ‚úÖ Fetch API adapter for HTTP operations
              - ‚úÖ Integration tests with realistic scenarios
              - ‚úÖ Input validation and data transformation
              - ‚úÖ Network error handling and retry logic

              ### üß™ Test Coverage
              - Unit tests for Remote__USE_CASE_NAME_PASCAL_CASE__ implementation
              - Integration tests with mocked HTTP client
              - Error scenario testing (404, 400, 401, 500, network errors)
              - Type safety and data transformation tests
              - Complete TDD methodology validation

              ### üèóÔ∏è Architecture Compliance
              - ‚úÖ Clean Architecture layers respected
              - ‚úÖ Dependency inversion with protocol interfaces
              - ‚úÖ Frontend-specific patterns (Remote prefix, Fetch API)
              - ‚úÖ Domain types returned (not infrastructure types)
              - ‚úÖ Error boundaries and graceful degradation

              ### üìã Code Review Checklist
              - [ ] All tests passing (npm run test)
              - [ ] TypeScript compilation clean (npx tsc --noEmit)
              - [ ] ESLint validation passed (npm run lint)
              - [ ] Clean Architecture principles followed
              - [ ] No dependency violations between layers
              - [ ] Error handling comprehensive and appropriate
              - [ ] Code follows project conventions and patterns
              - [ ] Documentation and JSDoc comments present
              - [ ] Performance considerations addressed
              - [ ] Security best practices followed

              ### üîç Review Focus Areas
              1. **Data Layer Implementation**: Review Remote__USE_CASE_NAME_PASCAL_CASE__ class structure and HTTP communication logic
              2. **Error Handling**: Validate error transformation and domain-appropriate error types
              3. **Test Quality**: Ensure comprehensive test coverage and realistic scenarios
              4. **Type Safety**: Verify TypeScript types and data transformations
              5. **Architecture**: Confirm Clean Architecture compliance and dependency directions

              ### üìä Metrics
              - Test Coverage: Aiming for >95% coverage
              - TypeScript: Strict compilation with no any types
              - ESLint: Zero warnings/errors
              - Bundle Size Impact: Minimal (data layer only)

              ---
              ü§ñ Generated with TDD methodology and Clean Architecture best practices" \
                --draft
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Display PR URL'
            command: 'gh pr view --web'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 13: AI CODE REVIEW ===
    - id: 'ai-code-review-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'AI-powered code review and quality analysis for frontend data layer'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'CODE_REVIEW_GUIDELINES.md'
          description: 'Automated code review standards and quality gates.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'automated code review frontend clean architecture typescript'
          url: 'https://github.com/...'
          description: 'AI code review patterns and quality metrics.'
      ai_review_prompts:
        architecture_review: |
          Please review this frontend data layer implementation for Clean Architecture compliance:

          üìÅ Files to Review:
          - src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases/remote-__USE_CASE_NAME_KEBAB_CASE__.ts
          - src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/protocols/__USE_CASE_NAME_KEBAB_CASE__-http-client.ts
          - src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/http/fetch-__USE_CASE_NAME_KEBAB_CASE__-client.ts

          üéØ Review Criteria:
          1. **Clean Architecture Compliance**: Verify dependency direction (data ‚Üí domain, infra ‚Üí data)
          2. **Frontend Patterns**: Confirm Remote prefix, Fetch API usage, Next.js compatibility
          3. **Error Handling**: Evaluate error transformation and domain-appropriate errors
          4. **Type Safety**: Check TypeScript usage and data transformations
          5. **Testing Strategy**: Review TDD implementation and test coverage

          üîç Focus Areas:
          - No imports from outer layers (domain should not import data/infra)
          - Protocol interfaces properly abstract HTTP dependencies
          - Error handling transforms infrastructure errors to domain errors
          - Data transformations preserve type safety
          - HTTP client follows frontend best practices (timeout, retry, cancellation)

          Please provide specific feedback on architecture violations and improvement suggestions.

        code_quality_review: |
          Please perform a comprehensive code quality review for this frontend data layer:

          üéØ Quality Metrics:
          1. **Code Structure**: Classes, methods, separation of concerns
          2. **Error Handling**: Comprehensive error scenarios and user-friendly messages
          3. **Performance**: Network requests, caching, memory usage
          4. **Security**: Input validation, data sanitization, error exposure
          5. **Maintainability**: Code readability, documentation, extensibility

          üîç Specific Checks:
          - Input validation covers all required fields and edge cases
          - HTTP timeout and retry logic implemented properly
          - Error messages don't expose sensitive information
          - Data transformation handles missing/malformed responses
          - Memory leaks prevented (event listeners, timeouts, promises)
          - Network cancellation supported for component unmounting

          Please provide actionable feedback with specific code examples and improvement suggestions.

        test_quality_review: |
          Please review the test suite for this frontend data layer implementation:

          üìã Test Categories to Evaluate:
          1. **Unit Tests**: Remote__USE_CASE_NAME_PASCAL_CASE__ implementation testing
          2. **Integration Tests**: HTTP client interaction testing
          3. **Error Scenarios**: Network failures, HTTP errors, validation errors
          4. **Edge Cases**: Empty responses, malformed data, timeout scenarios
          5. **Type Safety**: TypeScript compilation and type checking

          üéØ Test Quality Criteria:
          - TDD methodology properly followed (RED-GREEN-REFACTOR)
          - Test coverage >95% for data layer components
          - Realistic test scenarios that mirror production usage
          - Proper mocking of HTTP dependencies
          - Error scenarios comprehensively covered
          - Integration tests validate complete data flow

          Please provide feedback on test completeness, quality, and suggest additional test cases if needed.

      run_scripts:
        description: 'Execute AI code review process'
        scripts:
          - name: 'Run automated architecture validation'
            command: 'npm run arch:validate -- --layer=data --feature=__FEATURE_NAME_KEBAB_CASE__ --use-case=__USE_CASE_NAME_KEBAB_CASE__'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Generate code coverage report'
            command: 'npm run test:coverage -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Static code analysis'
            command: 'npm run analyze:code -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Bundle size impact analysis'
            command: 'npm run analyze:bundle -- --feature=__FEATURE_NAME_KEBAB_CASE__'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 14: CLEANUP AND MERGE ===
    - id: 'cleanup-and-merge-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Final cleanup, review approval, and merge frontend data layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'MERGE_GUIDELINES.md'
          description: 'Merge process and cleanup procedures.'
      run_scripts:
        description: 'Complete PR merge and cleanup process'
        scripts:
          - name: 'Final validation before merge'
            command: 'npm run validate:all -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Merge Pull Request'
            command: 'gh pr merge --squash --delete-branch'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Switch back to main branch'
            command: 'git checkout main'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Pull latest changes'
            command: 'git pull origin main'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Cleanup local branch'
            command: 'git branch -d feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'
      validation_script: |
        echo "‚úÖ Verifying merge completion..."
        current_branch=$(git branch --show-current)
        if [ "$current_branch" != "main" ]; then
          echo "‚ùå ERROR: Not on main branch after merge"
          exit 1
        fi

        if git show-branch feat/__FEATURE_NAME_KEBAB_CASE__-data-__USE_CASE_NAME_KEBAB_CASE__-frontend 2>/dev/null; then
          echo "‚ùå ERROR: Feature branch still exists after cleanup"
          exit 1
        fi

        echo "‚úÖ Frontend data layer implementation successfully merged and cleaned up"
        echo "üéâ __USE_CASE_NAME_PASCAL_CASE__ data layer is ready for use!"

    # === OPTIONAL: BROWNFIELD REFACTORING STEPS ===
    # These steps can be used to refactor existing frontend code to Clean Architecture
    - id: 'refactor-existing-__USE_CASE_NAME_KEBAB_CASE__-data-1'
      type: 'conditional_refactor'
      description: 'Refactor existing HTTP calls to use data layer pattern'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: 'check_existing_http_calls'
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'refactoring legacy code to clean architecture frontend'
          url: 'https://github.com/...'
          description: 'Brownfield refactoring patterns for frontend.'
      refactor_pattern:
        find_pattern: |
          <<<FIND>>>
          // Legacy direct HTTP call pattern
          const response = await fetch('/api/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(__INPUT_DATA__)
          })
          const data = await response.json()
          <<</FIND>>>
        replace_pattern: |
          <<<REPLACE>>>
          // Refactored to use Clean Architecture data layer
          const __USE_CASE_NAME_CAMEL_CASE__ = new Remote__USE_CASE_NAME_PASCAL_CASE__(
            new Fetch__USE_CASE_NAME_PASCAL_CASE__Client()
          )
          const data = await __USE_CASE_NAME_CAMEL_CASE__.execute(__INPUT_DATA__)
          <<</REPLACE>>>

    - id: 'refactor-existing-__USE_CASE_NAME_KEBAB_CASE__-data-2'
      type: 'conditional_refactor'
      description: 'Refactor inline error handling to use domain errors'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: 'check_inline_error_handling'
      refactor_pattern:
        find_pattern: |
          <<<FIND>>>
          // Legacy inline error handling
          if (!response.ok) {
            if (response.status === 404) {
              throw new Error('Not found')
            } else if (response.status === 400) {
              throw new Error('Bad request')
            } else {
              throw new Error('Something went wrong')
            }
          }
          <<</FIND>>>
        replace_pattern: |
          <<<REPLACE>>>
          // Refactored to use domain-appropriate error handling
          // Error handling now managed by Remote__USE_CASE_NAME_PASCAL_CASE__
          // Domain errors: ValidationError, NotFoundError, etc.
          try {
            const result = await __USE_CASE_NAME_CAMEL_CASE__.execute(input)
            return result
          } catch (error) {
            // Handle domain-specific errors
            if (error instanceof ValidationError) {
              // Handle validation errors appropriately for UI
            } else if (error instanceof NotFoundError) {
              // Handle not found errors appropriately for UI
            } else {
              // Handle general errors
            }
            throw error
          }
          <<</REPLACE>>>

    - id: 'refactor-existing-__USE_CASE_NAME_KEBAB_CASE__-data-3'
      type: 'conditional_refactor'
      description: 'Refactor component props to use domain types'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: 'check_api_types_in_components'
      refactor_pattern:
        find_pattern: |
          <<<FIND>>>
          // Legacy API response types used in components
          interface ComponentProps {
            data: {
              id: string
              name: string
              status: string
              created_at: string // API snake_case
              updated_at: string // API snake_case
            }
          }
          <<</FIND>>>
        replace_pattern: |
          <<<REPLACE>>>
          // Refactored to use domain types
          import type { __USE_CASE_NAME_PASCAL_CASE__Output } from '../domain/usecases/__USE_CASE_NAME_KEBAB_CASE__'

          interface ComponentProps {
            data: __USE_CASE_NAME_PASCAL_CASE__Output // Clean domain type
          }
          <<</REPLACE>>>

# ============= END DATA STEPS FRONTEND SECTION =============