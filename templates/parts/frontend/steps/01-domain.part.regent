# ============= BEGIN DOMAIN STEPS FRONTEND SECTION =============

  # ------------------------------------------------------------------------------
  # AI-NOTE: DOMAIN LAYER IMPLEMENTATION STEPS FOR FRONTEND
  # These steps create domain interfaces and types following Clean Architecture
  # and Next.js 15 patterns specific to React/TypeScript frontend development
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # DOMAIN LAYER STEPS SECTION
  # Steps for generating domain layer artifacts in frontend features
  # Following "Feature Module with Use Case Slices" architecture for Next.js 15
  # ------------------------------------------------------------------------------

  domain_steps:
    # === STEP 1: CREATE FEATURE BRANCH ===
    - id: 'create-feature-branch-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create feature branch for __USE_CASE_NAME_PASCAL_CASE__ frontend domain layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Following Git Flow pattern for feature development.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'git workflow feature branch naming conventions'
          url: 'https://github.com/...'
          description: 'Git Flow and feature branch best practices.'
      run_scripts:
        description: 'Create and checkout feature branch for domain layer development'
        scripts:
          - name: 'Create feature branch'
            command: 'git checkout -b feat/__FEATURE_NAME_KEBAB_CASE__-domain-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Push feature branch'
            command: 'git push -u origin feat/__FEATURE_NAME_KEBAB_CASE__-domain-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'
      validation_script: |
        current_branch=$(git branch --show-current)
        expected_branch="feat/__FEATURE_NAME_KEBAB_CASE__-domain-__USE_CASE_NAME_KEBAB_CASE__-frontend"
        if [ "$current_branch" != "$expected_branch" ]; then
          echo "‚ùå ERROR: Expected branch $expected_branch, but current branch is $current_branch"
          exit 1
        fi
        echo "‚úÖ Feature branch created successfully: $current_branch"

    # === STEP 2: CREATE DOMAIN STRUCTURE ===
    - id: 'create-domain-structure-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'folder'
      description: 'Create domain layer folder structure for __USE_CASE_NAME_PASCAL_CASE__ use case slice in frontend'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'FRONTEND_ARCHITECTURE.md'
          description: 'Following Clean Architecture domain layer structure for Next.js 15.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'clean architecture domain layer react next.js typescript'
          url: 'https://github.com/...'
          description: 'Domain layer patterns for frontend React development.'
      action:
        create_folders:
          basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain'
          folders:
            - 'usecases'      # Use case interface for this specific frontend use case
      validation_script: |
        # AI-NOTE: Replace placeholders but keep shell variables intact
        BASE_PATH="__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain"
        FOLDERS="$BASE_PATH/usecases"
        echo "‚úÖ Verifying frontend domain folder structure..."
        for folder in $FOLDERS; do
          if [ ! -d "$folder" ]; then
            echo "‚ùå ERROR: Folder $folder was not created."
            exit 1
          fi
        done
        echo "‚úÖ All domain folders exist for __USE_CASE_NAME_PASCAL_CASE__ frontend use case."

    # === STEP 2: CREATE USE CASE INTERFACE ===
    - id: 'create-domain-usecase-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create __USE_CASE_NAME_PASCAL_CASE__ use case interface in frontend domain layer'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'clean architecture use case interface typescript react'
          url: 'https://github.com/...'
          description: 'Following Clean Architecture use case pattern for frontend.'
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '*UseCase'
          description: 'Consistent with existing frontend use case interfaces.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain/usecases/__USE_CASE_NAME_KEBAB_CASE__.ts'
      template: |
        /**
         * Input parameters for __USE_CASE_NAME_PASCAL_CASE__ use case
         * Following Clean Architecture principles - pure domain types for frontend
         *
         * @domainConcept __UBIQUITOUS_LANGUAGE_TERM__
         * @layer Domain Layer - Framework agnostic business interface
         * @pattern Single Responsibility - One use case, one operation
         */
        export type __USE_CASE_NAME_PASCAL_CASE__Input = {
          __INPUT_FIELD_1__: string
          __INPUT_FIELD_2__: string
          __INPUT_FIELD_3__?: string // Optional field example
        }

        /**
         * Output type for __USE_CASE_NAME_PASCAL_CASE__ use case
         * Represents the business outcome of the frontend operation
         *
         * @domainConcept __UBIQUITOUS_LANGUAGE_TERM__
         * @layer Domain Layer - Pure business data structure
         * @pattern Data Transfer Object - Simple data container
         */
        export type __USE_CASE_NAME_PASCAL_CASE__Output = {
          __OUTPUT_FIELD_1__: string
          __OUTPUT_FIELD_2__: string
          __OUTPUT_FIELD_3__: number
          __TIMESTAMP_FIELD__: Date
          success: boolean
        }

        /**
         * __USE_CASE_NAME_PASCAL_CASE__ use case interface for frontend
         *
         * @description __USE_CASE_DESCRIPTION__
         * @pattern Command Pattern - Single execute method
         * @layer Domain Layer - Framework agnostic business interface
         * @architecture Clean Architecture - Use Case Interface
         *
         * @example
         * ```typescript
         * const useCase: __USE_CASE_NAME_PASCAL_CASE__ = new Remote__USE_CASE_NAME_PASCAL_CASE__(httpClient)
         * const result = await useCase.execute({ field1: 'value' })
         * ```
         */
        export interface __USE_CASE_NAME_PASCAL_CASE__ {
          /**
           * Execute the __USE_CASE_NAME_LOWER_CASE__ business operation
           *
           * @param input - The input parameters for the use case
           * @returns Promise with the operation result
           * @throws Will throw an error if the operation fails
           */
          execute: (input: __USE_CASE_NAME_PASCAL_CASE__Input) => Promise<__USE_CASE_NAME_PASCAL_CASE__Output>
        }

    # === STEP 3: CREATE DOMAIN MODELS (IF NEEDED) ===
    - id: 'create-domain-models-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Create domain models specific to __USE_CASE_NAME_PASCAL_CASE__ if complex data structures are needed'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: 'check_if_complex_model_needed'
      references:
        - type: 'internal_guideline'
          source: 'FRONTEND_RULES.md'
          description: 'Domain models should be simple data structures without behavior.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain/models/__USE_CASE_NAME_KEBAB_CASE__-model.ts'
      template: |
        /**
         * Domain model for __USE_CASE_NAME_PASCAL_CASE__ use case
         * Simple data structure without behavior (anemic model pattern for frontend)
         *
         * @domainConcept __UBIQUITOUS_LANGUAGE_TERM__
         * @layer Domain Layer - Pure data model
         * @pattern Anemic Domain Model - Data only, no behavior
         */
        export type __USE_CASE_NAME_PASCAL_CASE__Model = {
          id: string
          __MODEL_FIELD_1__: string
          __MODEL_FIELD_2__: string
          __MODEL_FIELD_3__: number
          status: __USE_CASE_NAME_PASCAL_CASE__Status
          metadata: __USE_CASE_NAME_PASCAL_CASE__Metadata
          createdAt: Date
          updatedAt: Date
        }

        /**
         * Status enum for __USE_CASE_NAME_PASCAL_CASE__
         */
        export enum __USE_CASE_NAME_PASCAL_CASE__Status {
          PENDING = 'PENDING',
          ACTIVE = 'ACTIVE',
          COMPLETED = 'COMPLETED',
          FAILED = 'FAILED',
          CANCELLED = 'CANCELLED'
        }

        /**
         * Metadata type for additional __USE_CASE_NAME_PASCAL_CASE__ information
         */
        export type __USE_CASE_NAME_PASCAL_CASE__Metadata = {
          version: string
          source: string
          tags: string[]
          [key: string]: unknown // Allow extension
        }

    # === STEP 4: CREATE DOMAIN TESTS ===
    - id: 'create-domain-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create unit tests for __USE_CASE_NAME_PASCAL_CASE__ domain interface (TDD approach)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'vitest unit testing typescript react next.js'
          url: 'https://github.com/...'
          description: 'Testing patterns for frontend domain layer.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain/usecases/__USE_CASE_NAME_KEBAB_CASE__.spec.ts'
      template: |
        import { describe, it, expect, beforeEach, vi } from 'vitest'
        import type {
          __USE_CASE_NAME_PASCAL_CASE__,
          __USE_CASE_NAME_PASCAL_CASE__Input,
          __USE_CASE_NAME_PASCAL_CASE__Output
        } from './__USE_CASE_NAME_KEBAB_CASE__'

        /**
         * Domain layer tests for __USE_CASE_NAME_PASCAL_CASE__ use case
         * Tests the interface contract, not the implementation
         *
         * @testType Unit Test - Domain Interface Contract
         * @coverage Interface contract validation
         */
        describe('__USE_CASE_NAME_PASCAL_CASE__ Domain Interface', () => {
          let sut: __USE_CASE_NAME_PASCAL_CASE__
          let mockExecute: ReturnType<typeof vi.fn>

          beforeEach(() => {
            mockExecute = vi.fn()
            // Mock implementation for testing the interface contract
            sut = {
              execute: mockExecute
            }
          })

          describe('Interface Contract', () => {
            it('should have an execute method', () => {
              expect(sut.execute).toBeDefined()
              expect(typeof sut.execute).toBe('function')
            })

            it('should accept valid input parameters', async () => {
              const validInput: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'test-value-1',
                __INPUT_FIELD_2__: 'test-value-2',
                __INPUT_FIELD_3__: 'optional-value'
              }

              const expectedOutput: __USE_CASE_NAME_PASCAL_CASE__Output = {
                __OUTPUT_FIELD_1__: 'result-1',
                __OUTPUT_FIELD_2__: 'result-2',
                __OUTPUT_FIELD_3__: 123,
                __TIMESTAMP_FIELD__: new Date(),
                success: true
              }

              mockExecute.mockResolvedValueOnce(expectedOutput)

              const result = await sut.execute(validInput)

              expect(mockExecute).toHaveBeenCalledWith(validInput)
              expect(mockExecute).toHaveBeenCalledTimes(1)
              expect(result).toEqual(expectedOutput)
            })

            it('should handle optional input parameters', async () => {
              const minimalInput: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'test-value-1',
                __INPUT_FIELD_2__: 'test-value-2'
                // __INPUT_FIELD_3__ is optional
              }

              const expectedOutput: __USE_CASE_NAME_PASCAL_CASE__Output = {
                __OUTPUT_FIELD_1__: 'result-1',
                __OUTPUT_FIELD_2__: 'result-2',
                __OUTPUT_FIELD_3__: 0,
                __TIMESTAMP_FIELD__: new Date(),
                success: true
              }

              mockExecute.mockResolvedValueOnce(expectedOutput)

              const result = await sut.execute(minimalInput)

              expect(mockExecute).toHaveBeenCalledWith(minimalInput)
              expect(result).toEqual(expectedOutput)
            })

            it('should return Promise<__USE_CASE_NAME_PASCAL_CASE__Output>', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'test',
                __INPUT_FIELD_2__: 'test'
              }

              mockExecute.mockResolvedValueOnce({
                __OUTPUT_FIELD_1__: 'result',
                __OUTPUT_FIELD_2__: 'result',
                __OUTPUT_FIELD_3__: 1,
                __TIMESTAMP_FIELD__: new Date(),
                success: true
              })

              const resultPromise = sut.execute(input)

              expect(resultPromise).toBeInstanceOf(Promise)

              const result = await resultPromise
              expect(result).toHaveProperty('success')
              expect(result).toHaveProperty('__OUTPUT_FIELD_1__')
              expect(result).toHaveProperty('__TIMESTAMP_FIELD__')
            })

            it('should handle error scenarios', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'error-trigger',
                __INPUT_FIELD_2__: 'test'
              }

              const error = new Error('__USE_CASE_NAME_PASCAL_CASE__ execution failed')
              mockExecute.mockRejectedValueOnce(error)

              await expect(sut.execute(input)).rejects.toThrow('__USE_CASE_NAME_PASCAL_CASE__ execution failed')
              expect(mockExecute).toHaveBeenCalledWith(input)
            })
          })

          describe('Type Safety', () => {
            it('should ensure input type safety at compile time', () => {
              // This test verifies TypeScript compilation
              // If this compiles, the types are correct
              const typedInput: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: 'string-value',
                __INPUT_FIELD_2__: 'another-string',
                __INPUT_FIELD_3__: undefined // Optional can be undefined
              }

              expect(typedInput).toBeDefined()
            })

            it('should ensure output type safety at compile time', () => {
              // This test verifies TypeScript compilation
              const typedOutput: __USE_CASE_NAME_PASCAL_CASE__Output = {
                __OUTPUT_FIELD_1__: 'string-result',
                __OUTPUT_FIELD_2__: 'another-result',
                __OUTPUT_FIELD_3__: 42,
                __TIMESTAMP_FIELD__: new Date(),
                success: true
              }

              expect(typedOutput.success).toBe(true)
              expect(typeof typedOutput.__OUTPUT_FIELD_3__).toBe('number')
              expect(typedOutput.__TIMESTAMP_FIELD__).toBeInstanceOf(Date)
            })
          })
        })

      validation_script: |
        run_domain_unit_tests() {
          echo "üß™ Running frontend domain layer unit tests..."
          npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain --coverage || exit 1
          echo "‚úÖ Frontend domain unit tests passed with coverage"
        }

        check_test_coverage() {
          echo "üìä Checking frontend domain test coverage..."
          COVERAGE_RESULT=$(npm run test:coverage -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain --json)
          echo "‚úÖ Frontend domain coverage meets requirements"
        }

        stage_and_commit_tests() {
          local commit_message="$1"
          git add .
          git status
          git commit -m "$commit_message" || exit 1
          echo "‚úÖ Committed: $commit_message"
        }

        run_domain_unit_tests
        check_test_coverage
        stage_and_commit_tests "test(__FEATURE_NAME_KEBAB_CASE__): add __USE_CASE_NAME_KEBAB_CASE__ frontend domain tests"

    # === STEP 5: UPDATE FEATURE SHARED DOMAIN (IF NEEDED) ===
    - id: 'update-feature-shared-domain-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Update feature shared domain entities/models if needed for __USE_CASE_NAME_PASCAL_CASE__'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: 'check_if_shared_entity_needed'
      references:
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '__FEATURE_NAME_PASCAL_CASE__Entity'
          description: 'Check if feature entity needs updating.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared/domain/entities/__FEATURE_NAME_KEBAB_CASE__-entity.ts'
      template: |
        /**
         * Shared entity for __FEATURE_NAME_PASCAL_CASE__ feature
         * Used across multiple use cases in the feature module
         *
         * @domainConcept __FEATURE_NAME_PASCAL_CASE__
         * @layer Domain Layer - Shared Feature Entity
         * @pattern Entity - Identified by ID
         */
        export type __FEATURE_NAME_PASCAL_CASE__Entity = {
          id: string
          // Existing fields...
          __EXISTING_FIELD_1__: string
          __EXISTING_FIELD_2__: string

          // New fields added for __USE_CASE_NAME_PASCAL_CASE__ use case
          __NEW_FIELD_1__?: string // Added for __USE_CASE_NAME_PASCAL_CASE__
          __NEW_FIELD_2__?: number // Added for __USE_CASE_NAME_PASCAL_CASE__

          // Metadata
          createdAt: Date
          updatedAt: Date
          createdBy?: string
          updatedBy?: string
        }

        /**
         * Type guard for __FEATURE_NAME_PASCAL_CASE__Entity
         */
        export function is__FEATURE_NAME_PASCAL_CASE__Entity(value: unknown): value is __FEATURE_NAME_PASCAL_CASE__Entity {
          return (
            typeof value === 'object' &&
            value !== null &&
            'id' in value &&
            typeof (value as any).id === 'string' &&
            '__EXISTING_FIELD_1__' in value &&
            'createdAt' in value
          )
        }

    # === STEP 6: VALIDATE DOMAIN LAYER ===
    - id: 'validate-domain-layer-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Validate frontend domain layer implementation for __USE_CASE_NAME_PASCAL_CASE__'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      run_scripts:
        description: 'Run all frontend domain layer validation checks'
        scripts:
          - name: 'TypeScript Compilation'
            command: 'npx tsc --noEmit --project tsconfig.json'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'ESLint Check'
            command: 'npm run lint -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Unit Tests'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Clean Architecture Rules Check'
            command: 'npm run arch:check -- --layer=domain --feature=__FEATURE_NAME_KEBAB_CASE__'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Commit Domain Layer'
            command: 'git add . && git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): implement __USE_CASE_NAME_KEBAB_CASE__ frontend domain layer"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 7: CREATE FEATURE BRANCH ===
    - id: 'create-feature-branch-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create and checkout feature branch for __USE_CASE_NAME_PASCAL_CASE__ implementation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Git branching strategy and naming conventions'
      run_scripts:
        description: 'Create feature branch with proper naming convention'
        scripts:
          - name: 'Create feature branch'
            command: |
              # Stash any uncommitted changes
              git stash save "WIP: Before creating __FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__ branch"

              # Ensure we're on the main branch and up to date
              git checkout main || git checkout master
              git pull origin main || git pull origin master

              # Create and checkout new feature branch
              BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__"
              git checkout -b "$BRANCH_NAME" || {
                echo "‚ùå Failed to create branch: $BRANCH_NAME"
                exit 1
              }

              echo "‚úÖ Created and checked out branch: $BRANCH_NAME"
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 8: REFACTOR FOR BROWNFIELD (CONDITIONAL MULTI-STEP) ===
    # AI-NOTE: When brownfield refactoring is needed, the AI should dynamically generate
    # multiple steps based on the specific components/files that need refactoring.
    # Each file should have its own step for better tracking and granular control.
    #
    # RULE: For each file requiring refactoring, create a separate step with:
    # - Unique ID: refactor-{index}-{component/filename}
    # - Clear description of what changes are needed
    # - Specific validation for that file's refactoring
    # - Component-specific refactoring patterns
    #
    # EXAMPLE PATTERN:
    # If 4 components need refactoring, generate:
    # Step 8a: refactor-1-user-list-component
    # Step 8b: refactor-2-user-form-component
    # Step 8c: refactor-3-user-profile-page
    # Step 8d: refactor-4-user-context

    - id: 'refactor-rollback-point-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create rollback point before starting brownfield refactoring'
      condition: 'check_if_brownfield_refactor_needed'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'REFACTORING_GUIDE.md'
          description: 'Best practices for safe React component refactoring'
      run_scripts:
        description: 'Create git tag for rollback before any refactoring'
        scripts:
          - name: 'Create rollback tag'
            command: |
              # Create rollback point before refactoring
              git tag "before-refactor-__USE_CASE_NAME_KEBAB_CASE__" || {
                echo "‚ö†Ô∏è  Failed to create rollback tag"
                exit 1
              }
              echo "‚úÖ Created rollback point: before-refactor-__USE_CASE_NAME_KEBAB_CASE__"
              echo "   To rollback: git reset --hard before-refactor-__USE_CASE_NAME_KEBAB_CASE__"

              # Document components that need refactoring
              echo "üìã Components identified for refactoring:"
              # AI should list components here based on analysis
            workingDirectory: '__PROJECT_NAME__'

    # AI-NOTE: The following is a template that should be duplicated for each component
    # that needs refactoring. The AI should generate one step per component/file.
    - id: 'refactor-__INDEX__-__FILE_TO_MODIFY_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Refactor __FILE_TO_MODIFY_KEBAB_CASE__ to Clean Architecture'
      condition: 'check_if_component_needs_refactoring'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'REFACTORING_GUIDE.md'
          description: 'Clean Architecture patterns for React components'
        - type: 'internal_code_analysis'
          source: 'serena'
          description: 'Analyze component structure and dependencies'
        - type: 'external_pattern'
          source: 'context7'
          query: 'react clean architecture refactoring patterns'
          url: 'https://...'
          description: 'React refactoring best practices'
      path: '__PROJECT_NAME__/src/__PATH_TO_FILE__/__FILE_TO_MODIFY_KEBAB_CASE__.tsx'
      template: |
        <<<FIND>>>
        // The AI should identify the exact component code that needs refactoring
        // This will be the original component that violates Clean Architecture
        [ORIGINAL_COMPONENT_CODE_TO_BE_REPLACED]
        <<</FIND>>>
        <<<REPLACE>>>
        // TODO: Refactor this component to comply with Clean Architecture
        // Component: __FILE_TO_MODIFY_KEBAB_CASE__.tsx
        // Type: __COMPONENT_TYPE__ (Page/Component/Hook/Context)
        // Priority: __PRIORITY__ (high/medium/low)
        // Estimated effort: __EFFORT__ (hours)

        // SPECIFIC REFACTORING TASKS FOR THIS COMPONENT:
        // 1. Extract business logic to custom hooks
        // 2. Separate data fetching to repository layer
        // 3. Move UI logic to presentation components
        // 4. Add proper error boundaries
        // 5. Implement proper state management (Zustand/Context)
        // 6. Extract reusable UI components
        // 7. Add proper TypeScript types
        // 8. Implement loading and error states
        // 9. Add accessibility attributes
        // 10. Add unit and component tests

        // DEPENDENCIES TO UPDATE:
        // - [AI should list specific dependencies]

        // COMPONENTS THAT USE THIS:
        // - [AI should list parent components]

        // HOOKS/CONTEXT CONSUMED:
        // - [AI should list hooks and context]

        /* TEMPORARY: Original component preserved for reference
        [ORIGINAL_COMPONENT_CODE_TO_BE_REPLACED]
        */

        // NEW REFACTORED COMPONENT:
        [REFACTORED_COMPONENT_FOLLOWING_CLEAN_ARCHITECTURE]
        <<</REPLACE>>>

    # === STEP 9: DELETE OBSOLETE FILES (CONDITIONAL) ===
    - id: 'delete-file-__FILE_TO_DELETE_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Delete obsolete files when refactoring to Clean Architecture'
      condition: 'check_if_file_deletion_needed'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'MIGRATION_GUIDE.md'
          description: 'Guidelines for safely removing obsolete code'
      validation_script: |
        FILE_TO_DELETE="__PROJECT_NAME__/src/__PATH_TO_FILE__/__FILE_TO_DELETE_KEBAB_CASE__"

        if [ -f "$FILE_TO_DELETE" ]; then
          # Extract filename without extension consistently
          FILE_NAME=$(basename "$FILE_TO_DELETE" | sed 's/\.[^.]*$//')

          # Check for references to this file
          echo "üîç Checking for references to $FILE_NAME..."
          REFERENCES=$(grep -r "$FILE_NAME" __PROJECT_NAME__/src --exclude-dir=node_modules | wc -l)

          if [ "$REFERENCES" -gt 0 ]; then
            echo "‚ö†Ô∏è  WARNING: Found $REFERENCES references to this file. Review before deletion."
            exit 1
          fi

          # Backup before deletion
          cp "$FILE_TO_DELETE" "$FILE_TO_DELETE.backup"
          rm "$FILE_TO_DELETE"
          echo "‚úÖ File deleted and backed up: $FILE_TO_DELETE.backup"
        fi

    # === STEP 10: CREATE PULL REQUEST ===
    - id: 'create-pull-request-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create pull request for __USE_CASE_NAME_PASCAL_CASE__ implementation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'PR_TEMPLATE.md'
          description: 'Pull request template and review checklist'
      run_scripts:
        description: 'Push branch and create pull request'
        scripts:
          - name: 'Push and create PR'
            command: |
              BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__"

              # Push the branch
              git push -u origin "$BRANCH_NAME" || {
                echo "‚ùå Failed to push branch to remote"
                exit 1
              }

              # Create PR using GitHub CLI if available
              if command -v gh &> /dev/null; then
                gh pr create \
                  --title "feat(__FEATURE_NAME_KEBAB_CASE__): implement __USE_CASE_NAME_KEBAB_CASE__ use case (Frontend)" \
                  --body "## Summary

                Implements __USE_CASE_NAME_PASCAL_CASE__ use case frontend following Clean Architecture principles.

                ## Changes
                - ‚úÖ Domain layer with models and interfaces
                - ‚úÖ Data layer with repositories
                - ‚úÖ Infrastructure layer with API clients
                - ‚úÖ Presentation layer with components and hooks
                - ‚úÖ Comprehensive test coverage with Vitest
                - ‚úÖ Zod validation schemas

                ## Testing
                - [ ] Unit tests pass
                - [ ] Component tests pass
                - [ ] E2E tests pass
                - [ ] Manual testing completed

                ## Metrics
                - [ ] Code coverage: __COVERAGE__%
                - [ ] Bundle size impact: __SIZE_IMPACT__
                - [ ] Lighthouse score: __LIGHTHOUSE_SCORE__
                - [ ] Performance benchmarks: __PERF_STATUS__

                ## Checklist
                - [ ] Code follows Clean Architecture principles
                - [ ] Tests have adequate coverage
                - [ ] Documentation is updated
                - [ ] No breaking changes
                - [ ] Accessibility standards met
                - [ ] Performance impact assessed" \
                  --assignee @me \
                  --label "enhancement,frontend,clean-architecture"

                echo "‚úÖ Pull request created successfully"
              else
                echo "üìù Push successful. Please create PR manually at:"
                echo "   https://github.com/__GITHUB_ORG__/__PROJECT_NAME__/compare/$BRANCH_NAME"
              fi
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 11: TRIGGER AI CODE REVIEW ===
    - id: 'trigger-ai-review-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Trigger AI-powered code review with Claude'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'claude-cli'
          query: 'claude code review clean architecture frontend react'
          url: 'https://claude.ai/docs/code-review'
          description: 'AI-powered code review using Claude'
      run_scripts:
        description: 'Run Claude AI code review on the frontend implementation'
        scripts:
          - name: 'Trigger Claude review'
            command: |
              BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__"

              # Check if Claude CLI is available
              if command -v claude &> /dev/null; then
                echo "ü§ñ Starting AI code review with Claude..."

                claude /review \
                  --branch "$BRANCH_NAME" \
                  --focus "clean-architecture,react,typescript" \
                  --checklist ".github/frontend_checklist.md" \
                  --output "review-frontend-__USE_CASE_NAME_KEBAB_CASE__.md"

                echo "‚úÖ AI review complete. Check review-frontend-__USE_CASE_NAME_KEBAB_CASE__.md for details."

                # Add review as PR comment if gh CLI is available
                if command -v gh &> /dev/null && [ -f "review-frontend-__USE_CASE_NAME_KEBAB_CASE__.md" ]; then
                  gh pr comment --body-file "review-frontend-__USE_CASE_NAME_KEBAB_CASE__.md"
                  echo "‚úÖ Review posted to PR"
                fi
              else
                echo "‚ö†Ô∏è  Claude CLI not installed. Skipping AI review."
                echo "   Install with: npm install -g @anthropic/claude-cli"
              fi
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 12: POST-MERGE CLEANUP ===
    - id: 'post-merge-cleanup-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Cleanup after PR merge'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Post-merge cleanup procedures'
      run_scripts:
        description: 'Clean up local and remote branches after merge'
        scripts:
          - name: 'Post-merge cleanup'
            command: |
              BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__"

              # Check if PR is merged
              if command -v gh &> /dev/null; then
                PR_STATE=$(gh pr view "$BRANCH_NAME" --json state -q .state)

                if [ "$PR_STATE" = "MERGED" ]; then
                  echo "üßπ Starting post-merge cleanup..."

                  # Switch to main branch
                  git checkout main || git checkout master
                  git pull origin main || git pull origin master

                  # Delete local branch
                  git branch -d "$BRANCH_NAME"

                  # Delete remote branch
                  git push origin --delete "$BRANCH_NAME"

                  echo "‚úÖ Cleanup complete. Branch deleted locally and remotely."
                else
                  echo "‚è≥ PR not yet merged. Skipping cleanup."
                fi
              else
                echo "‚ö†Ô∏è  GitHub CLI not available. Please clean up branches manually after merge."
              fi
            workingDirectory: '__PROJECT_NAME__'

# ============= END DOMAIN STEPS FRONTEND SECTION =============