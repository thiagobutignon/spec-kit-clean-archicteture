# Domain Layer Template (Clean Architecture)

This document outlines the structure, rules, and automated workflow for creating the domain layer of a new feature. The primary source of truth for automation is `TODO_DOMAIN_TEMPLATE.yaml`. This Markdown file serves as human-readable documentation for that process.

## 1. Feature-Based Domain Structure

The domain layer for each feature is self-contained and follows this structure:

```````
src/
└── features/
    └── __FEATURE_NAME_KEBAB_CASE__/
        └── domain/
            ├── errors/         # Feature-specific, typed errors
            ├── use-cases/      # Feature use case interfaces (contracts)
            └── test/           # Mock implementations and test helpers```

## 2. Layer Dependencies

The domain layer is the core of the architecture and must remain independent of all other layers.

#### ✅ Layers that CAN import from Domain:
- **Data Layer:** Implements the use case interfaces defined in the domain.
- **Presentation Layer:** Uses domain types and calls use cases.
- **Infrastructure Layer:** May use domain types for adapters.

#### ❌ Domain CANNOT import from:
- **Any other layer:** The domain must be completely independent.
- **External Libraries:** No third-party dependencies (e.g., `axios`, database clients).
- **Frameworks:** No framework-specific code (e.g., React, Express).

## 3. Domain Layer Rules

#### ✅ What CAN be in the Domain Layer:
- **Type Definitions:** `Input` and `Output` types for use cases.
- **Use Case Interfaces:** Contracts defining business operations.
- **Domain-Specific Errors:** Custom error classes extending the native `Error`.
- **Test Helpers:** Mock functions and data for testing purposes.

#### ❌ What CANNOT be in the Domain Layer:
- **Business Logic:** No implementation details, validation logic, or calculations.
- **External Dependencies:** No `import` statements from external libraries.
- **I/O Operations:** No `console.log`, database, or file system operations.
- **Frameworks or UI Components.**

---

## 4. Automated Generation Workflow

The creation of a new feature's domain layer is a two-step process driven by an AI assistant.

### Step 1: Plan Generation (AI Task)

The developer invokes the AI with a structured JSON payload describing the feature. The AI's **only** task is to generate a valid `[feature-name]-implementation.yaml` file.

#### AI Prompt Structure

The AI is guided by a master prompt that defines its behavior:
1.  **Read `TODO_DOMAIN_TEMPLATE.yaml`:** Use the template as the source of truth.
2.  **Parse JSON Input:** Understand the feature requirements from the user's JSON payload.
3.  **Generate YAML:** Create a new YAML file by replacing all `__PLACEHOLDER__` variables in the template with the data from the JSON.
4.  **Validate:** Run `npx tsx validate-implementation.ts` on the generated file.
5.  **Self-Correct:** If validation fails, read the error messages, fix the YAML, and re-validate until it passes.
6.  **Deliver:** The final output is the validated YAML file, ready for user review.

#### Example Invocation with JSON

```bash
/tasks-domain create feature from json:
``````json
{
  "featureName": "User Account",
  "useCases": [
    {
      "name": "Create User Account",
      "description": "Creates a new user account",
      "input": [
        { "name": "email", "type": "string" },
        { "name": "password", "type": "string" }
      ],
      "output": [
        { "name": "id", "type": "string" },
        { "name": "email", "type": "string" }
      ],
      "mockInput": [
        { "name": "email", "value": "'test@example.com'" },
        { "name": "password", "value": "'SecurePassword123!'" }
      ],
      "mockOutput": [
        { "name": "id", "value": "'user-123'" },
        { "name": "email", "value": "'test@example.com'" }
      ]
    }
  ],
  "errors": [
    {
      "name": "User Already Exists",
      "description": "when the email is already registered",
      "message": "User with this email already exists"
    }
  ]
}
```````

### Step 2: Plan Execution (User Task)

After reviewing and approving the YAML file generated by the AI, the developer executes the plan.

```bash
npx tsx execute-steps.ts [feature-name]-implementation.yaml
```

The `execute-steps.ts` script will then:

1.  Read the YAML file.
2.  Iterate through each item in the `steps` array.
3.  Create the specified files and folders.
4.  Run the `validation_script` for each step, which performs linting, testing, and an atomic `git commit`.

---

## 5. Template Snippets

These are the core templates used by the automation. They are defined in `TODO_DOMAIN_TEMPLATE.yaml`.

### Feature Use Case Template

```typescript
// src/features/__FEATURE_NAME_KEBAB_CASE__/domain/use-cases/__ACTION_ENTITY_KEBAB_CASE__.ts

/**
 * Input parameters for __ACTION_ENTITY_PASCAL_CASE__UseCase
 */
export type __ACTION_ENTITY_PASCAL_CASE__Input = {
  __USE_CASE_INPUT_FIELDS__;
};

/**
 * Output type for __ACTION_ENTITY_PASCAL_CASE__UseCase
 */
export type __ACTION_ENTITY_PASCAL_CASE__Output = {
  __USE_CASE_OUTPUT_FIELDS__;
};

/**
 * __ACTION_ENTITY_PASCAL_CASE__UseCase interface
 * @description __USE_CASE_DESCRIPTION__
 */
export interface __ACTION_ENTITY_PASCAL_CASE__UseCase {
  /**
   * Execute the __ACTION_ENTITY_LOWER_CASE__ operation
   * @param input - The input parameters
   * @returns Promise with the operation output
   */
  execute: (
    input: __ACTION_ENTITY_PASCAL_CASE__Input
  ) => Promise<__ACTION_ENTITY_PASCAL_CASE__Output>;
}
```

### Feature Error Template

```typescript
// src/features/__FEATURE_NAME_KEBAB_CASE__/domain/errors/__ERROR_NAME_KEBAB_CASE__.ts

/**
 * Error thrown when __ERROR_DESCRIPTION__
 * @extends Error
 */
export class __ERROR_NAME_PASCAL_CASE__Error extends Error {
  constructor() {
    super("__ERROR_MESSAGE__");
    this.name = "__ERROR_NAME_PASCAL_CASE__Error";
  }
}
```

### Feature Test Helper Template

```typescript
// src/features/__FEATURE_NAME_KEBAB_CASE__/domain/test/mock-__ACTION_ENTITY_KEBAB_CASE__-use-case.ts
import { vi } from "vitest";
import type {
  __ACTION_ENTITY_PASCAL_CASE__UseCase,
  __ACTION_ENTITY_PASCAL_CASE__Input,
  __ACTION_ENTITY_PASCAL_CASE__Output,
} from "../use-cases/__ACTION_ENTITY_KEBAB_CASE__";

/**
 * Creates a mock instance of __ACTION_ENTITY_PASCAL_CASE__Input
 */
export const mock__ACTION_ENTITY_PASCAL_CASE__Input =
  (): __ACTION_ENTITY_PASCAL_CASE__Input => ({
    __MOCK_INPUT_DATA__,
  });

/**
 * Creates a mock instance of __ACTION_ENTITY_PASCAL_CASE__Output
 */
export const mock__ACTION_ENTITY_PASCAL_CASE__Output =
  (): __ACTION_ENTITY_PASCAL_CASE__Output => ({
    __MOCK_OUTPUT_DATA__,
  });

/**
 * Creates a mock instance of __ACTION_ENTITY_PASCAL_CASE__UseCase
 */
export const mock__ACTION_ENTITY_PASCAL_CASE__UseCase =
  (): __ACTION_ENTITY_PASCAL_CASE__UseCase => ({
    execute: vi.fn(),
  });
```

### Validation Script Template (for each step)

This script is executed after each file is created, ensuring quality at every step.

```bash
# AI-NOTE: This script is immutable. Only the commit message placeholder is replaced.
echo "🔍 Running lint check..."
yarn lint
if [ $? -ne 0 ]; then
  # ... (auto-fix logic)
fi
echo "✅ Lint passed"

echo "🧪 Running tests with coverage..."
yarn test --coverage
if [ $? -ne 0 ]; then
  # ... (error reporting logic)
fi
echo "✅ Tests passed"

echo "📦 Staging changes..."
git add .

echo "💾 Creating commit..."
git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): add __ACTION_ENTITY_KEBAB_CASE__ use case"
if [ $? -ne 0 ]; then
  # ... (error reporting logic)
fi
echo "✅ Successfully committed"
```
