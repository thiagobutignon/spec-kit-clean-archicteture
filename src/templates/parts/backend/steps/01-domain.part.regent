# ============= BEGIN DOMAIN STEPS BACKEND SECTION =============

  # ------------------------------------------------------------------------------
  # AI-NOTE: DOMAIN LAYER IMPLEMENTATION STEPS FOR BACKEND
  # These steps create domain interfaces and types following Clean Architecture
  # and Vertical Slice Architecture patterns specific to Node.js backend development
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # DOMAIN LAYER STEPS SECTION
  # Steps for generating domain layer artifacts in backend features
  # Following "Feature Module with Use Case Slices" architecture
  # ------------------------------------------------------------------------------

  domain_steps:
    # === STEP 1: CREATE DOMAIN STRUCTURE ===
    - id: 'create-domain-structure-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'folder'
      description: 'Create domain layer folder structure for __USE_CASE_NAME_PASCAL_CASE__ use case slice'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'BACKEND_ARCHITECTURE.md'
          description: 'Following Clean Architecture domain layer structure for backend.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'clean architecture domain layer backend node.js'
          url: 'https://github.com/...'
          description: 'Domain layer patterns for backend development.'
      action:
        create_folders:
          basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain'
          folders:
            - 'usecases'      # Use case interface for this specific use case
            - 'errors'        # Domain errors specific to this use case

    # === STEP 2: CREATE USE CASE INTERFACE ===
    - id: 'create-domain-usecase-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create __USE_CASE_NAME_PASCAL_CASE__ use case interface in domain layer'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'clean architecture use case interface backend'
          url: 'https://github.com/...'
          description: 'Following Clean Architecture use case pattern for backend.'
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '*UseCase'
          description: 'Consistent with existing backend use case interfaces.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain/usecases/__USE_CASE_NAME_KEBAB_CASE__.ts'
      template: |
        /**
        * Input parameters for __USE_CASE_NAME_PASCAL_CASE__ use case
        * Following Clean Architecture principles - pure domain types for backend
        * @domainConcept __UBIQUITOUS_LANGUAGE_TERM__
        * @layer Domain Layer - Framework agnostic business interface
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Input = {
          __INPUT_FIELD_1__: string
          __INPUT_FIELD_2__: string
          __INPUT_FIELD_3__: string
        }

        /**
        * Output type for __USE_CASE_NAME_PASCAL_CASE__ use case
        * Represents the business outcome of the backend operation
        * @domainConcept __UBIQUITOUS_LANGUAGE_TERM__
        * @layer Domain Layer - Pure business data structure
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Output = {
          __OUTPUT_FIELD_1__: string
          __OUTPUT_FIELD_2__: string
          __OUTPUT_FIELD_3__: string
          __TIMESTAMP_FIELD__: Date
        }

        /**
        * __USE_CASE_NAME_PASCAL_CASE__ use case interface for backend
        * @description __USE_CASE_DESCRIPTION__
        * @pattern Command Pattern - Single Responsibility Principle
        * @layer Domain Layer - Framework agnostic business interface
        * @architecture Vertical Slice - Self-contained use case slice
        */
        export interface __USE_CASE_NAME_PASCAL_CASE__ {
          /**
          * Execute the __USE_CASE_NAME_LOWER_CASE__ operation in backend
          * @param input - The input parameters for backend processing
          * @returns Promise with the operation output
          * @throws Domain errors when business rules are violated
          */
          execute: (input: __USE_CASE_NAME_PASCAL_CASE__Input) => Promise<__USE_CASE_NAME_PASCAL_CASE__Output>
        }

    # === STEP 3: CREATE DOMAIN ERRORS ===
    - id: 'create-domain-errors-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create domain errors specific to __USE_CASE_NAME_PASCAL_CASE__ use case'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'domain driven design error handling backend'
          url: 'https://github.com/...'
          description: 'Following DDD error handling patterns for backend.'
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '*Error'
          description: 'Consistent with existing backend domain errors.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain/errors/__USE_CASE_NAME_KEBAB_CASE__-errors.ts'
      template: |
        /**
        * Domain error for __USE_CASE_NAME_PASCAL_CASE__ use case
        * @domainConcept __UBIQUITOUS_LANGUAGE_TERM__
        * @layer Domain Layer - Business rule violation for backend
        */
        export class __ERROR_NAME_PASCAL_CASE__Error extends Error {
          constructor(message: string = '__DEFAULT_ERROR_MESSAGE__') {
            super(message)
            this.name = '__ERROR_NAME_PASCAL_CASE__Error'
          }
        }

        /**
        * Validation error specific to __USE_CASE_NAME_PASCAL_CASE__ input
        * @domainConcept Input validation in backend domain layer
        */
        export class __USE_CASE_NAME_PASCAL_CASE__ValidationError extends Error {
          constructor(field: string, value: unknown) {
            super(`Invalid __USE_CASE_NAME_LOWER_CASE__ input: ${field} = ${value}`)
            this.name = '__USE_CASE_NAME_PASCAL_CASE__ValidationError'
          }
        }

        /**
        * Business rule violation error for __USE_CASE_NAME_PASCAL_CASE__
        * @domainConcept Business invariant protection in backend
        */
        export class __USE_CASE_NAME_PASCAL_CASE__BusinessRuleError extends Error {
          constructor(rule: string) {
            super(`Business rule violation in __USE_CASE_NAME_LOWER_CASE__: ${rule}`)
            this.name = '__USE_CASE_NAME_PASCAL_CASE__BusinessRuleError'
          }
        }

    # === STEP 4: CREATE DOMAIN TESTS ===
    - id: 'create-domain-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create unit tests for __USE_CASE_NAME_PASCAL_CASE__ domain layer'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'test driven development domain layer backend'
          url: 'https://github.com/...'
          description: 'Following TDD patterns for backend domain layer.'
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '*.spec.ts'
          description: 'Consistent with existing backend test patterns.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain/usecases/__USE_CASE_NAME_KEBAB_CASE__.spec.ts'
      template: |
        import { describe, it, expect, beforeEach } from 'vitest'
        import {
          __USE_CASE_NAME_PASCAL_CASE__,
          __USE_CASE_NAME_PASCAL_CASE__Input,
          __USE_CASE_NAME_PASCAL_CASE__Output
        } from './__USE_CASE_NAME_KEBAB_CASE__'
        import {
          __ERROR_NAME_PASCAL_CASE__Error,
          __USE_CASE_NAME_PASCAL_CASE__ValidationError,
          __USE_CASE_NAME_PASCAL_CASE__BusinessRuleError
        } from '../errors/__USE_CASE_NAME_KEBAB_CASE__-errors'

        // Mock implementation for testing the interface contract
        class Mock__USE_CASE_NAME_PASCAL_CASE__ implements __USE_CASE_NAME_PASCAL_CASE__ {
          async execute(input: __USE_CASE_NAME_PASCAL_CASE__Input): Promise<__USE_CASE_NAME_PASCAL_CASE__Output> {
            // Mock implementation - validates interface contract
            if (!input.__INPUT_FIELD_1__) {
              throw new __USE_CASE_NAME_PASCAL_CASE__ValidationError('__INPUT_FIELD_1__', input.__INPUT_FIELD_1__)
            }

            return {
              __OUTPUT_FIELD_1__: `processed-${input.__INPUT_FIELD_1__}`,
              __OUTPUT_FIELD_2__: `result-${input.__INPUT_FIELD_2__}`,
              __OUTPUT_FIELD_3__: `output-${input.__INPUT_FIELD_3__}`,
              __TIMESTAMP_FIELD__: new Date()
            }
          }
        }

        describe('__USE_CASE_NAME_PASCAL_CASE__ Domain Interface', () => {
          let useCase: __USE_CASE_NAME_PASCAL_CASE__

          beforeEach(() => {
            useCase = new Mock__USE_CASE_NAME_PASCAL_CASE__()
          })

          describe('Input Validation', () => {
            it('should accept valid input parameters', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: '__EXAMPLE_VALUE_1__',
                __INPUT_FIELD_2__: '__EXAMPLE_VALUE_2__',
                __INPUT_FIELD_3__: '__EXAMPLE_VALUE_3__'
              }

              const result = await useCase.execute(input)

              expect(result).toBeDefined()
              expect(result.__OUTPUT_FIELD_1__).toBe('processed-__EXAMPLE_VALUE_1__')
              expect(result.__TIMESTAMP_FIELD__).toBeInstanceOf(Date)
            })

            it('should throw validation error for invalid input', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: '', // Invalid empty value
                __INPUT_FIELD_2__: '__EXAMPLE_VALUE_2__',
                __INPUT_FIELD_3__: '__EXAMPLE_VALUE_3__'
              }

              await expect(useCase.execute(input)).rejects.toThrow(__USE_CASE_NAME_PASCAL_CASE__ValidationError)
            })
          })

          describe('Output Contract', () => {
            it('should return output with all required fields', async () => {
              const input: __USE_CASE_NAME_PASCAL_CASE__Input = {
                __INPUT_FIELD_1__: '__EXAMPLE_VALUE_1__',
                __INPUT_FIELD_2__: '__EXAMPLE_VALUE_2__',
                __INPUT_FIELD_3__: '__EXAMPLE_VALUE_3__'
              }

              const result = await useCase.execute(input)

              expect(result).toHaveProperty('__OUTPUT_FIELD_1__')
              expect(result).toHaveProperty('__OUTPUT_FIELD_2__')
              expect(result).toHaveProperty('__OUTPUT_FIELD_3__')
              expect(result).toHaveProperty('__TIMESTAMP_FIELD__')
              expect(typeof result.__OUTPUT_FIELD_1__).toBe('string')
              expect(typeof result.__OUTPUT_FIELD_2__).toBe('string')
              expect(typeof result.__OUTPUT_FIELD_3__).toBe('string')
              expect(result.__TIMESTAMP_FIELD__).toBeInstanceOf(Date)
            })
          })
        })

        describe('__USE_CASE_NAME_PASCAL_CASE__ Domain Errors', () => {
          describe('__ERROR_NAME_PASCAL_CASE__Error', () => {
            it('should create error with default message', () => {
              const error = new __ERROR_NAME_PASCAL_CASE__Error()

              expect(error).toBeInstanceOf(Error)
              expect(error.name).toBe('__ERROR_NAME_PASCAL_CASE__Error')
              expect(error.message).toBe('__DEFAULT_ERROR_MESSAGE__')
            })

            it('should create error with custom message', () => {
              const customMessage = 'Custom error message'
              const error = new __ERROR_NAME_PASCAL_CASE__Error(customMessage)

              expect(error.message).toBe(customMessage)
            })
          })

          describe('__USE_CASE_NAME_PASCAL_CASE__ValidationError', () => {
            it('should create validation error with field and value', () => {
              const error = new __USE_CASE_NAME_PASCAL_CASE__ValidationError('testField', 'invalidValue')

              expect(error).toBeInstanceOf(Error)
              expect(error.name).toBe('__USE_CASE_NAME_PASCAL_CASE__ValidationError')
              expect(error.message).toContain('testField')
              expect(error.message).toContain('invalidValue')
            })
          })

          describe('__USE_CASE_NAME_PASCAL_CASE__BusinessRuleError', () => {
            it('should create business rule error with rule description', () => {
              const rule = 'User must be active to perform this operation'
              const error = new __USE_CASE_NAME_PASCAL_CASE__BusinessRuleError(rule)

              expect(error).toBeInstanceOf(Error)
              expect(error.name).toBe('__USE_CASE_NAME_PASCAL_CASE__BusinessRuleError')
              expect(error.message).toContain(rule)
            })
          })
        })

    # === STEP 5: UPDATE FEATURE SHARED DOMAIN (IF NEEDED) ===
    - id: 'update-feature-shared-domain-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Update feature shared domain models if needed for __USE_CASE_NAME_PASCAL_CASE__'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      # AI-NOTE: Evaluate if this model will be used across multiple use cases
      # If YES: Place in feature/shared/domain/models
      # If NO: Keep in use-case specific domain folder
      condition: 'check_if_shared_model_needed'
      references:
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '__FEATURE_NAME_PASCAL_CASE__Model'
          description: 'Check if feature shared model exists and needs updating.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared/domain/models/__FEATURE_NAME_KEBAB_CASE__-model.ts'
      template: |
        /**
        * __FEATURE_NAME_PASCAL_CASE__ domain model
        * Shared across all __FEATURE_NAME_LOWER_CASE__ use cases within this feature
        * @domainConcept Core entity for __FEATURE_NAME_LOWER_CASE__ feature
        * @layer Domain Layer - Feature shared model
        */
        export interface __FEATURE_NAME_PASCAL_CASE__Model {
          id: string
          __MODEL_FIELD_1__: string
          __MODEL_FIELD_2__: string
          __MODEL_FIELD_3__: string
          createdAt: Date
          updatedAt: Date
        }

        /**
        * __FEATURE_NAME_PASCAL_CASE__ repository interface
        * Protocol for data persistence operations
        * @domainConcept Repository pattern for __FEATURE_NAME_LOWER_CASE__ aggregate
        */
        export interface __FEATURE_NAME_PASCAL_CASE__Repository {
          findById(id: string): Promise<__FEATURE_NAME_PASCAL_CASE__Model | null>
          save(model: Omit<__FEATURE_NAME_PASCAL_CASE__Model, 'id' | 'createdAt' | 'updatedAt'>): Promise<__FEATURE_NAME_PASCAL_CASE__Model>
          update(id: string, model: Partial<__FEATURE_NAME_PASCAL_CASE__Model>): Promise<__FEATURE_NAME_PASCAL_CASE__Model>
          delete(id: string): Promise<void>
        }

    # === STEP 7: CREATE FEATURE BRANCH ===
    - id: 'create-feature-branch-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create and checkout feature branch for __USE_CASE_NAME_PASCAL_CASE__ implementation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Git branching strategy and naming conventions'
      run_scripts:
        description: 'Create feature branch with proper naming convention'
        scripts:
          - name: 'Create feature branch'
            command: |
              # Stash any uncommitted changes
              git stash save "WIP: Before creating __FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__ branch"

              # Ensure we're on the main branch and up to date
              git checkout main || git checkout master
              git pull origin main || git pull origin master

              # Create and checkout new feature branch
              BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__"
              git checkout -b "$BRANCH_NAME" || {
                echo "‚ùå Failed to create branch: $BRANCH_NAME"
                exit 1
              }

              echo "‚úÖ Created and checked out branch: $BRANCH_NAME"
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 8: REFACTOR FOR BROWNFIELD (CONDITIONAL MULTI-STEP) ===
    # AI-NOTE: When brownfield refactoring is needed, the AI should dynamically generate
    # multiple steps based on the specific files that need refactoring. Each file should
    # have its own step for better tracking and granular control.
    #
    # RULE: For each file requiring refactoring, create a separate step with:
    # - Unique ID: refactor-{index}-{filename}
    # - Clear description of what changes are needed
    # - Specific validation for that file's refactoring
    # - Rollback point for each major refactoring
    #
    # EXAMPLE PATTERN:
    # If 3 files need refactoring, generate:
    # Step 8a: refactor-1-user-controller
    # Step 8b: refactor-2-user-service
    # Step 8c: refactor-3-user-repository

    - id: 'refactor-rollback-point-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create rollback point before starting brownfield refactoring'
      condition: 'check_if_brownfield_refactor_needed'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'REFACTORING_GUIDE.md'
          description: 'Best practices for safe refactoring with rollback points'
      run_scripts:
        description: 'Create git tag for rollback before any refactoring'
        scripts:
          - name: 'Create rollback tag'
            command: |
              # Create rollback point before refactoring
              git tag "before-refactor-__USE_CASE_NAME_KEBAB_CASE__" || {
                echo "‚ö†Ô∏è  Failed to create rollback tag"
                exit 1
              }
              echo "‚úÖ Created rollback point: before-refactor-__USE_CASE_NAME_KEBAB_CASE__"
              echo "   To rollback: git reset --hard before-refactor-__USE_CASE_NAME_KEBAB_CASE__"

              # Document files that need refactoring
              echo "üìã Files identified for refactoring:"
              # AI should list files here based on analysis
            workingDirectory: '__PROJECT_NAME__'

    # AI-NOTE: The following is a template that should be duplicated for each file
    # that needs refactoring. The AI should generate one step per file.
    - id: 'refactor-__INDEX__-__FILE_TO_MODIFY_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Refactor __FILE_TO_MODIFY_KEBAB_CASE__ to Clean Architecture'
      condition: 'check_if_file_needs_refactoring'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'REFACTORING_GUIDE.md'
          description: 'Clean Architecture refactoring patterns for backend'
        - type: 'internal_code_analysis'
          source: 'serena'
          description: 'Analyze current file structure and dependencies'
      path: '__PROJECT_NAME__/src/__PATH_TO_FILE__/__FILE_TO_MODIFY_KEBAB_CASE__.ts'
      template: |
        # AI-NOTE: FIND/REPLACE Pattern for Brownfield Refactoring
        # The AI must identify SPECIFIC code blocks that violate Clean Architecture
        # Look for these common violations:
        # - Business logic in controllers/routes
        # - Database queries outside repositories
        # - Framework types in domain layer
        # - Missing dependency injection

        <<<FIND>>>
        # AI-NOTE: Match the EXACT code including imports if needed
        # Be specific to avoid matching wrong code blocks
        # Include enough context for unique identification
        # The AI should identify the exact code block that needs refactoring
        # This will be the original code that violates Clean Architecture
        [ORIGINAL_CODE_TO_BE_REPLACED]
        <<</FIND>>>
        <<<REPLACE>>>
        # AI-NOTE: Apply Clean Architecture transformation
        # Ensure the refactored code:
        # - Follows dependency rules (domain imports nothing)
        # - Uses dependency injection via constructor
        # - Has NO framework dependencies in domain/data
        # - Uses protocols/interfaces for external services
        # - Is fully testable with mocks/spies

        // TODO: Refactor this file to comply with Clean Architecture
        // File: __FILE_TO_MODIFY_KEBAB_CASE__.ts
        // Priority: __PRIORITY__ (high/medium/low)
        // Estimated effort: __EFFORT__ (hours)

        // SPECIFIC REFACTORING TASKS FOR THIS FILE:
        // 1. Extract business logic to domain layer
        // 2. Move data access to infrastructure layer
        // 3. Separate presentation concerns
        // 4. Add proper error handling
        // 5. Implement dependency injection
        // 6. Update imports to follow Clean Architecture boundaries
        // 7. Add unit tests for refactored code

        // DEPENDENCIES TO UPDATE:
        // - [AI should list specific dependencies]

        // FILES THAT IMPORT THIS:
        // - [AI should list files that will need updates]

        /* TEMPORARY: Original code preserved for reference
        [ORIGINAL_CODE_TO_BE_REPLACED]
        */

        // NEW REFACTORED CODE:
        [REFACTORED_CODE_FOLLOWING_CLEAN_ARCHITECTURE]
        <<</REPLACE>>>

    # === STEP 9: DELETE OBSOLETE FILES (CONDITIONAL) ===
    - id: 'delete-file-__FILE_TO_DELETE_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Delete obsolete files when refactoring to Clean Architecture'
      condition: 'check_if_file_deletion_needed'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'MIGRATION_GUIDE.md'
          description: 'Guidelines for safely removing obsolete code'

    # === STEP 10: CREATE PULL REQUEST ===
    - id: 'create-pull-request-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create pull request for __USE_CASE_NAME_PASCAL_CASE__ implementation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'PR_TEMPLATE.md'
          description: 'Pull request template and review checklist'
      run_scripts:
        description: 'Push branch and create pull request'
        scripts:
          - name: 'Push and create PR'
            command: |
              BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__"

              # Push the branch
              git push -u origin "$BRANCH_NAME" || {
                echo "‚ùå Failed to push branch to remote"
                exit 1
              }

              # Create PR using GitHub CLI if available
              if command -v gh &> /dev/null; then
                gh pr create \
                  --title "feat(__FEATURE_NAME_KEBAB_CASE__): implement __USE_CASE_NAME_KEBAB_CASE__ use case" \
                  --body "## Summary

                Implements __USE_CASE_NAME_PASCAL_CASE__ use case following Clean Architecture principles.

                ## Changes
                - ‚úÖ Domain layer with use case interface and models
                - ‚úÖ Data layer with repositories
                - ‚úÖ Infrastructure layer implementation
                - ‚úÖ Presentation layer with handlers
                - ‚úÖ Comprehensive test coverage
                - ‚úÖ Validation and error handling

                ## Testing
                - [ ] Unit tests pass
                - [ ] Integration tests pass
                - [ ] Manual testing completed

                ## Metrics
                - [ ] Code coverage: __COVERAGE__%
                - [ ] Bundle size impact: __SIZE_IMPACT__
                - [ ] Performance benchmarks: __PERF_STATUS__

                ## Checklist
                - [ ] Code follows Clean Architecture principles
                - [ ] Tests have adequate coverage
                - [ ] Documentation is updated
                - [ ] No breaking changes
                - [ ] Performance impact assessed" \
                  --assignee @me \
                  --label "enhancement,clean-architecture"

                echo "‚úÖ Pull request created successfully"
              else
                echo "üìù Push successful. Please create PR manually at:"
                echo "   https://github.com/__GITHUB_ORG__/__PROJECT_NAME__/compare/$BRANCH_NAME"
              fi
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 11: TRIGGER AI CODE REVIEW ===
    - id: 'trigger-ai-review-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Trigger AI-powered code review with Claude'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'claude-cli'
          query: 'claude code review clean architecture'
          url: 'https://claude.ai/docs/code-review'
          description: 'AI-powered code review using Claude'
      run_scripts:
        description: 'Run Claude AI code review on the implementation'
        scripts:
          - name: 'Trigger Claude review'
            command: |
              BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__"

              # Check if Claude CLI is available
              if command -v claude &> /dev/null; then
                echo "ü§ñ Starting AI code review with Claude..."

                claude /review \
                  --branch "$BRANCH_NAME" \
                  --focus "clean-architecture" \
                  --checklist ".github/clean_architecture_checklist.md" \
                  --output "review-__USE_CASE_NAME_KEBAB_CASE__.md"

                echo "‚úÖ AI review complete. Check review-__USE_CASE_NAME_KEBAB_CASE__.md for details."

                # Add review as PR comment if gh CLI is available
                if command -v gh &> /dev/null && [ -f "review-__USE_CASE_NAME_KEBAB_CASE__.md" ]; then
                  gh pr comment --body-file "review-__USE_CASE_NAME_KEBAB_CASE__.md"
                  echo "‚úÖ Review posted to PR"
                fi
              else
                echo "‚ö†Ô∏è  Claude CLI not installed. Skipping AI review."
                echo "   Install with: npm install -g @anthropic/claude-cli"
              fi
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 12: POST-MERGE CLEANUP ===
    - id: 'post-merge-cleanup-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Cleanup after PR merge'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Post-merge cleanup procedures'
      run_scripts:
        description: 'Clean up local and remote branches after merge'
        scripts:
          - name: 'Post-merge cleanup'
            command: |
              BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__"

              # Check if PR is merged
              if command -v gh &> /dev/null; then
                PR_STATE=$(gh pr view "$BRANCH_NAME" --json state -q .state)

                if [ "$PR_STATE" = "MERGED" ]; then
                  echo "üßπ Starting post-merge cleanup..."

                  # Switch to main branch
                  git checkout main || git checkout master
                  git pull origin main || git pull origin master

                  # Delete local branch
                  git branch -d "$BRANCH_NAME"

                  # Delete remote branch
                  git push origin --delete "$BRANCH_NAME"

                  echo "‚úÖ Cleanup complete. Branch deleted locally and remotely."
                else
                  echo "‚è≥ PR not yet merged. Skipping cleanup."
                fi
              else
                echo "‚ö†Ô∏è  GitHub CLI not available. Please clean up branches manually after merge."
              fi
            workingDirectory: '__PROJECT_NAME__'

# ============= END DOMAIN STEPS BACKEND SECTION =============
