# =============================================
# GENERATED FILE - DO NOT EDIT DIRECTLY
# Target: frontend
# Layer: infra
# Built from parts in templates/parts
# Generated at: 2025-09-30 23:13:55
# To modify, edit the part files and rebuild
# =============================================


# --- From: shared/00-header.part.regent ---

# AI-NOTE: This YAML file is the single source of truth for generating clean architecture layers.
# This is the MASTER TEMPLATE that will evolve to support all architectural layers.
#
# INTELLIGENT RLHF SCORING SYSTEM:
# The system uses Reinforcement Learning from Human Feedback to score execution quality:
# -2: CATASTROPHIC - Architecture violations, incorrect REPLACE/WITH format in refactor steps
# -1: RUNTIME ERROR - Lint failures, test failures, git operation problems
#  0: LOW CONFIDENCE - System is uncertain, avoids hallucinations
# +1: GOOD - Task complete but missing architectural elements
# +2: PERFECT - Exceptional quality with Clean Architecture, DDD principles, ubiquitous language
#
# QUALITY INDICATORS FOR +2 SCORE:
# - Uses ubiquitous language terminology
# - Follows Domain-Driven Design principles
# - Applies Clean Architecture concepts
# - Implements patterns: Aggregate Root, Value Objects, Domain Events
# - Perfect branch naming convention
# - Comprehensive PR descriptions
#
version: '3.0.0'
# AI-NOTE: Update these fields to describe the specific feature and layers.
metadata:
  title: '__FEATURE_NAME_PASCAL_CASE__ Clean Architecture Implementation'
  description: 'Clean Architecture template for __FEATURE_NAME_LOWER_CASE__ feature following master template rules.'
  source: 'TEMPLATE.yaml'
  # AI-NOTE: This should be replaced with the current date, e.g., YYYY-MM-DD.
  lastUpdated: '__CURRENT_DATE__'
  # AI-NOTE: Specify which layers are being implemented
  layers:
    - 'domain'
    # Future layers will be added here:
    # - 'data'
    # - 'infra'
    # - 'presentation'
    # - 'validation'
    # - 'main'
  # AI-NOTE: Define ubiquitous language for +2 RLHF score
  ubiquitousLanguage:
    - term: '__ENTITY_NAME__'
      definition: '__ENTITY_DEFINITION_IN_BUSINESS_CONTEXT__'
    - term: '__VALUE_OBJECT_NAME__'
      definition: '__VALUE_OBJECT_BUSINESS_MEANING__'
    - term: '__DOMAIN_EVENT__'
      definition: '__EVENT_BUSINESS_SIGNIFICANCE__'



# --- From: frontend/01-structure.part.regent ---
# ============= BEGIN STRUCTURE NEXT.JS 15 + CLEAN ARCHITECTURE =============
  # AI-NOTE: Hybrid Architecture - "Feature Module with Use Case Slices"
  # Features are modules containing atomic use case slices for domain cohesion and generation safety

structure:
  # App Router centralized (MUST be in src/app)
  app:
    basePath: '__PROJECT_NAME__/src/app'
    folders:
      - '(features)'              # Route group for features
      - '__FEATURE_NAME__'        # Feature routes
      - 'api/__FEATURE_NAME__'   # Feature API routes
      - '_components'             # Private app components
    files:
      - 'layout.tsx'
      - 'page.tsx'
      - 'loading.tsx'             # File, not folder
      - 'error.tsx'               # File, not folder
      - 'not-found.tsx'           # File, not folder

  # Feature Module: Container for a business domain (e.g., user, product)
  # __FEATURE_NAME_KEBAB_CASE__ = user, product, etc.
  feature_module:
    basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__'

    # 1. Use Case Slices: Each folder is self-contained, atomic use case
    # __USE_CASE_NAME_KEBAB_CASE__ = create-user, get-users, etc.
    use_case_slice:
      basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__'
      layers:
        domain:
          folders:
            - 'usecases'      # Interface for this specific use case
          # Unit tests: create-user.ts + create-user.spec.ts (side by side)
        data:
          folders:
            - 'usecases'      # Implementation for this specific use case
          # Unit tests: remote-create-user.ts + remote-create-user.spec.ts (side by side)
        presentation:
          folders:
            - 'actions'       # Server Action for this use case
            - 'components'    # Components for this use case
            - 'hooks'         # Hooks for this use case
          # Unit tests: create-user-action.spec.ts, create-user-form.spec.tsx, use-create-user.spec.ts
        validation:
          folders:
            - 'schemas'       # Schema for this specific use case
            - 'validators'    # Validator for this specific use case
          # Unit tests: create-user-schema.spec.ts, create-user-validator.spec.ts
        main:
          folders:
            - 'composites'    # Composite component for this use case
          # Unit tests: create-user-composite.spec.tsx
        # Integration and E2E tests only (not unit tests)
        __tests__:
          folders:
            - 'integration'   # Tests that cross layers
            - 'e2e'          # End-to-end tests (Playwright, Cypress)

    # 2. Feature-Specific Shared: Code shared ONLY within this feature
    feature_shared:
      basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared'
      layers:
        domain:
          folders:
            - 'entities'      # e.g., user-entity.ts (shared by all user use cases)
            - 'models'        # e.g., user-model.ts
            - 'repositories'  # e.g., user-repository.ts (interface)
            - 'errors'        # e.g., user-not-found-error.ts
            - 'value-objects' # e.g., email-value-object.ts
        infra:
          folders:
            - 'api'           # e.g., user-api-client.ts (implementation)
            - 'services'      # e.g., user-external-service.ts
        presentation:
          folders:
            - 'ui'            # Feature-specific UI components
            - 'styles'        # Feature-specific styles
            - 'providers'     # Feature-specific context providers

    # 3. Feature Main/Integration: Connects all slices to App Router
    feature_main:
      basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/main'
      folders:
        - 'pages'         # e.g., user-page-composer.tsx (aggregates use case composites)
        - 'config'        # Feature-level configuration
        - 'docs'          # Feature documentation

  # Shared code with Clean Architecture layers
  shared:
    basePath: '__PROJECT_NAME__/src/shared'
    layers:
      domain:
        folders:
          - 'errors'          # Base error classes
          - 'protocols'       # Domain contracts/interfaces
          - 'types'           # Shared domain types
          - 'value-objects'   # Shared value objects

      data:
        folders:
          - 'protocols'       # Data layer protocols
          - 'helpers'         # Data transformation helpers
          - 'models'          # Shared DTOs

      infra:
        folders:
          - 'cache'           # Next.js cache utilities
          - 'http'            # Fetch wrappers and interceptors
          - 'storage'         # LocalStorage/SessionStorage adapters
          - 'cookies'         # Cookie management utilities
          - 'telemetry'       # Analytics and monitoring

      presentation:
        folders:
          - 'components'      # Shared UI components
          - 'hooks'           # Shared React hooks
          - 'providers'       # Shared context providers
          - 'ui'              # Shared shadcn/ui components
          - 'styles'          # Global styles and utilities
          - 'helpers'         # Presentation helpers

      validation:
        folders:
          - 'schemas'         # Shared Zod/Yup schemas
          - 'validators'      # Shared validation functions
          - 'protocols'       # Validation interfaces

      main:
        folders:
          - 'adapters'        # Shared adapters
          - 'builders'        # Shared builders
          - 'composites'      # Shared composites
          - 'decorators'      # Shared decorators
          - 'factories'       # Shared factories
          - 'lib'             # Utility functions

# Example of Hybrid Architecture workflow for Next.js
integration:
  use_case_example:
    # Task: "Generate create-user use case for user feature"
    # __FEATURE_NAME_KEBAB_CASE__ = user
    # __USE_CASE_NAME_KEBAB_CASE__ = create-user

    # STEP 1: Create Feature directories (if not exist)
    create_feature_structure:
      - 'src/features/user/'
      - 'src/features/user/shared/'     # Feature-specific shared code
      - 'src/features/user/main/'       # Feature integration

    # STEP 2: Create Use Case Slice directory (isolated)
    create_slice_directory:
      - 'src/features/user/create-user/' # Self-contained use case

    # STEP 3: Create NEW files (totally isolated within slice) WITH TESTS
    create_slice_files:
      # Domain layer with unit tests
      - 'src/features/user/create-user/domain/usecases/create-user.ts'
      - 'src/features/user/create-user/domain/usecases/create-user.spec.ts'

      # Data layer with unit tests
      - 'src/features/user/create-user/data/usecases/remote-create-user.ts'
      - 'src/features/user/create-user/data/usecases/remote-create-user.spec.ts'

      # Presentation layer with unit tests
      - 'src/features/user/create-user/presentation/actions/create-user-action.ts'
      - 'src/features/user/create-user/presentation/actions/create-user-action.spec.ts'
      - 'src/features/user/create-user/presentation/components/create-user-form.tsx'
      - 'src/features/user/create-user/presentation/components/create-user-form.spec.tsx'
      - 'src/features/user/create-user/presentation/hooks/use-create-user.ts'
      - 'src/features/user/create-user/presentation/hooks/use-create-user.spec.ts'

      # Validation layer with unit tests
      - 'src/features/user/create-user/validation/schemas/create-user-schema.ts'
      - 'src/features/user/create-user/validation/schemas/create-user-schema.spec.ts'
      - 'src/features/user/create-user/validation/validators/create-user-validator.ts'
      - 'src/features/user/create-user/validation/validators/create-user-validator.spec.ts'

      # Main layer with unit tests
      - 'src/features/user/create-user/main/composites/create-user-composite.tsx'
      - 'src/features/user/create-user/main/composites/create-user-composite.spec.tsx'

      # Integration tests (cross-layer)
      - 'src/features/user/create-user/__tests__/integration/create-user.integration.spec.ts'
      - 'src/features/user/create-user/__tests__/e2e/create-user.e2e.spec.ts'

    # STEP 4: Check/Modify FEATURE-SPECIFIC shared code
    feature_shared_files:
      - create_if_not_exists: 'src/features/user/shared/domain/models/user-model.ts'
      - create_if_not_exists: 'src/features/user/shared/domain/repositories/user-repository.ts'
      - modify: 'src/features/user/shared/domain/repositories/user-repository.ts'
        action: 'Add create() method to interface'
      - create_if_not_exists: 'src/features/user/shared/infra/api/user-api-client.ts'
      - modify: 'src/features/user/shared/infra/api/user-api-client.ts'
        action: 'Implement create() method for API calls'

    # STEP 5: Integrate with App Router
    integrate_app_router:
      - create_if_not_exists: 'src/features/user/main/pages/user-page-composer.tsx'
      - modify: 'src/features/user/main/pages/user-page-composer.tsx'
        action: 'Import and compose CreateUserComposite'
      - modify: 'src/app/(features)/user/page.tsx'
        action: 'Import and render UserPageComposer from feature/main'

    # RESULT: Perfect isolation for Next.js
    # - Use case slice is completely isolated in its own directory
    # - Feature-specific shared code stays within the feature
    # - App Router imports only from feature/main
    # - Zero risk of affecting other use cases

  example_integration:
    # How features connect to the App Router
    app_route: 'src/app/(features)/user/page.tsx'
    imports_from: 'src/features/user/main/pages/user-page-composer.tsx'

    use_case_composite: 'src/features/user/create-user/main/composites/create-user-composite.tsx'
    used_in: 'src/features/user/main/pages/user-page-composer.tsx'

    feature_shared_model: 'src/features/user/shared/domain/models/user-model.ts'
    used_by_slices: 'src/features/user/*/domain/usecases/*.ts'

    global_shared_ui: 'src/shared/presentation/components'
    global_shared_hooks: 'src/shared/presentation/hooks'

# ============= END STRUCTURE NEXT.JS 15 + CLEAN ARCHITECTURE =============

# --- From: frontend/02-architecture.part.regent ---

  # ------------------------------------------------------------------------------
  # FRONTEND ARCHITECTURAL RULES SECTION - NEXT.JS 15 + CLEAN ARCHITECTURE
  # These rules define the Clean Architecture boundaries for React/Next.js frontend
  # AI-NOTE: Frontend follows same Clean Architecture principles adapted for React/Next.js
  # AI-NOTE: Server components and client components have different dependency rules
  # ------------------------------------------------------------------------------

  architecture:
    folder_structure:
      use_case_slice: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__'
      feature_shared: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared'
      feature_main: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/main'
      global_shared: '__PROJECT_NAME__/src/shared'
      app_router: '__PROJECT_NAME__/src/app'

    execution_order:
      # AI-NOTE: Frontend vertical slicing includes UI components
      # Server Actions should be created before client hooks
      # Components should be tested in isolation before integration
      description: 'Frontend use cases are implemented vertically, from domain to UI components'
      approach: 'Vertical Slice Architecture - One feature at a time, through all frontend layers'
      sequence_per_use_case:
        1: 'domain'      # Use case interface and entities
        2: 'data'        # HTTP clients and remote implementations
        3: 'validation'  # Zod schemas and form validation
        4: 'presentation'# Actions, components, and hooks
        5: 'main'        # Composite components
        6: 'integration' # Connect to App Router

      workflow_diagram: |
        ```mermaid
        graph TD
          Start([Start Frontend Use Case])

          %% Branch Creation
          B1[Create Branch: feat/__FEATURE_NAME__/__USE_CASE_NAME__]

          %% Use Case Slice Directory
          UC1[Create Use Case Directory Structure]

          %% Domain Slice
          D1[Create Domain Interface]
          D2[Write Domain Tests - TDD Red]
          D3[Run: npm test - Expect Failure]
          D4[Git Commit: 'test(domain): add __USE_CASE__ tests']

          %% Data Slice
          DT1[Create Remote Implementation]
          DT2[Write HTTP Client Tests]
          DT3[Run: npm test - Green]
          DT4[Git Commit: 'feat(data): implement remote __USE_CASE__']

          %% Validation Slice
          V1[Create Zod Schema]
          V2[Create Form Validators]
          V3[Write Validation Tests]
          V4[Run: npm test - Green]
          V5[Git Commit: 'feat(validation): add __USE_CASE__ schema']

          %% Presentation Slice - Actions
          %% AI-NOTE: Server Actions use 'use server' directive
          %% Must handle form validation and error states
          PA1[Create Server Actions]
          PA2[Write Action Tests]
          PA3[Run: npm test - Green]
          PA4[Git Commit: 'feat(actions): add __USE_CASE__ server action']

          %% Presentation Slice - Hooks
          PH1[Create Custom Hooks]
          PH2[Write Hook Tests]
          PH3[Run: npm test - Green]
          PH4[Git Commit: 'feat(hooks): add use-__USE_CASE__ hook']

          %% Presentation Slice - Components
          PC1[Create UI Components]
          PC2[Write Component Tests]
          PC3[Run: npm test - Green]
          PC4[Git Commit: 'feat(components): add __USE_CASE__ form/ui']

          %% Main Slice - Composite
          M1[Create Composite Component]
          M2[Wire Dependencies]
          M3[Write Composite Tests]
          M4[Run: npm test - Green]
          M5[Git Commit: 'feat(main): add __USE_CASE__ composite']

          %% Feature Integration
          FI1[Update Feature Page Composer]
          FI2[Integrate Composite in Feature Main]
          FI3[Test Feature Integration]
          FI4[Git Commit: 'feat(pages): integrate __USE_CASE__ in page']

          %% App Router Integration
          AR1[Update App Router Page]
          AR2[Import Feature Page Composer]
          AR3[Test App Router Integration]
          AR4[Git Commit: 'feat(app): integrate __USE_CASE__ in app router']

          %% Testing
          IT1[Write Integration Tests]
          IT2[Run: npm run test:integration]
          IT3[Write E2E Tests with Playwright/Cypress]
          IT4[Run: npm run test:e2e]
          IT5[Git Commit: 'test(e2e): add __USE_CASE__ e2e tests']

          %% Final Steps
          F1[Run All Tests]
          F2[Run: npm run lint]
          F3[Run: npm run build]
          F4[Run: npm run type-check]
          F5[Git Push: Push Branch]
          F6[Create PR: '__FEATURE__/__USE_CASE__ Frontend Implementation']

          End([Frontend Use Case Complete])

          %% Flow - Vertical Development Through Frontend Layers
          Start --> B1
          B1 --> UC1

          %% Domain Flow
          UC1 --> D1 --> D2 --> D3 --> D4

          %% Data Flow
          D4 --> DT1 --> DT2 --> DT3 --> DT4

          %% Validation Flow
          DT4 --> V1 --> V2 --> V3 --> V4 --> V5

          %% Presentation Flow - Actions
          V5 --> PA1 --> PA2 --> PA3 --> PA4

          %% Presentation Flow - Hooks
          PA4 --> PH1 --> PH2 --> PH3 --> PH4

          %% Presentation Flow - Components
          PH4 --> PC1 --> PC2 --> PC3 --> PC4

          %% Main Flow
          PC4 --> M1 --> M2 --> M3 --> M4 --> M5

          %% Feature Integration Flow
          M5 --> FI1 --> FI2 --> FI3 --> FI4

          %% App Router Integration Flow
          FI4 --> AR1 --> AR2 --> AR3 --> AR4

          %% Testing Flow
          AR4 --> IT1 --> IT2 --> IT3 --> IT4 --> IT5

          %% Final Flow
          IT5 --> F1 --> F2 --> F3 --> F4 --> F5 --> F6 --> End

          classDef branch fill:#FFF9C4,stroke:#F57C00,stroke-width:2px
          classDef domain fill:#E8F5E9,stroke:#4CAF50,stroke-width:2px
          classDef data fill:#E3F2FD,stroke:#2196F3,stroke-width:2px
          classDef validation fill:#F3E5F5,stroke:#9C27B0,stroke-width:2px
          classDef presentation fill:#FCE4EC,stroke:#E91E63,stroke-width:2px
          classDef main fill:#E0F2F1,stroke:#009688,stroke-width:2px
          classDef integration fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px
          classDef testing fill:#FFEBEE,stroke:#F44336,stroke-width:2px
          classDef final fill:#E8EAF6,stroke:#3F51B5,stroke-width:2px

          class B1,UC1 branch
          class D1,D2,D3,D4 domain
          class DT1,DT2,DT3,DT4 data
          class V1,V2,V3,V4,V5 validation
          class PA1,PA2,PA3,PA4,PH1,PH2,PH3,PH4,PC1,PC2,PC3,PC4 presentation
          class M1,M2,M3,M4,M5 main
          class FI1,FI2,FI3,FI4,AR1,AR2,AR3,AR4 integration
          class IT1,IT2,IT3,IT4,IT5 testing
          class F1,F2,F3,F4,F5,F6 final
        ```

      git_workflow_per_use_case:
        description: 'Vertical slice development for Next.js - one complete feature at a time'
        example_use_case: 'create-user form in user feature'

        workflow_steps:
          - 'git checkout -b feat/__FEATURE_NAME__/__USE_CASE_NAME__'
          - 'Create use case slice directory: src/features/__FEATURE_NAME__/__USE_CASE_NAME__'

        domain_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/domain/usecases/__USE_CASE__.ts'
          - 'Write domain tests (TDD - RED) → npm test (expect failure)'
          - 'git add → git commit -m "test(domain): add failing tests for __USE_CASE__"'
          - 'Create domain interface → npm test → npm run lint'
          - 'git add → git commit -m "feat(domain): add __USE_CASE__ interface"'

        data_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/data/usecases/remote-__USE_CASE__.ts'
          - 'Implement HTTP client for use case → npm test → npm run lint'
          - 'git add → git commit -m "feat(data): implement remote __USE_CASE__"'

        validation_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/validation/schemas/__USE_CASE__-schema.ts'
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/validation/validators/__USE_CASE__-validator.ts'
          - 'Write validation tests → npm test → npm run lint'
          - 'git add → git commit -m "feat(validation): add __USE_CASE__ schema and validators"'

        presentation_slice_actions:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/presentation/actions/__USE_CASE__-action.ts'
          - 'Write server action tests → npm test → npm run lint'
          - 'git add → git commit -m "feat(actions): add __USE_CASE__ server action"'

        presentation_slice_hooks:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/presentation/hooks/use-__USE_CASE__.ts'
          - 'Write hook tests (React Testing Library) → npm test → npm run lint'
          - 'git add → git commit -m "feat(hooks): add use-__USE_CASE__ hook"'

        presentation_slice_components:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/presentation/components/__USE_CASE__-form.tsx'
          - 'Write component tests (React Testing Library) → npm test → npm run lint'
          - 'git add → git commit -m "feat(components): add __USE_CASE__ form component"'

        main_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/main/composites/__USE_CASE__-composite.tsx'
          - 'Wire all dependencies (hooks, actions, components) → npm test → npm run lint'
          - 'git add → git commit -m "feat(main): add __USE_CASE__ composite"'

        feature_integration:
          - 'Update: src/features/__FEATURE_NAME__/main/pages/__FEATURE__-page-composer.tsx'
          - 'Import and compose use case composite → import from ../__USE_CASE_NAME__/main/composites'
          - 'Test feature page integration → npm test'
          - 'git add → git commit -m "feat(pages): integrate __USE_CASE__ in feature page"'

        app_router_integration:
          - 'Update: src/app/(features)/__FEATURE_NAME__/page.tsx'
          - 'Import feature page composer → from ../../../features/__FEATURE_NAME__/main/pages'
          - 'Test app router integration → npm run dev → manual test'
          - 'git add → git commit -m "feat(app): integrate __USE_CASE__ in app router"'

        integration_testing:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/__tests__/integration/__USE_CASE__.integration.spec.ts'
          - 'Write integration tests → npm run test:integration'
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/__tests__/e2e/__USE_CASE__.e2e.spec.ts'
          - 'Write E2E tests → npm run test:e2e'
          - 'git add → git commit -m "test(e2e): add __USE_CASE__ integration and e2e tests"'

        finalization:
          - 'Run full test suite → npm test'
          - 'Run linting → npm run lint'
          - 'Run type checking → npm run type-check'
          - 'Run build → npm run build'
          - 'git push origin feat/__FEATURE_NAME__/__USE_CASE_NAME__'
          - 'gh pr create --base main --title "feat(__FEATURE__): implement __USE_CASE__ frontend feature"'

        benefits:
          - 'Atomic delivery: Each PR delivers a complete, working frontend feature'
          - 'Component isolation: Each slice can be developed and tested independently'
          - 'Type safety: Full TypeScript coverage from domain to UI'
          - 'Test coverage: Unit, integration, and E2E tests for complete confidence'
          - 'Next.js optimization: Leverages App Router, Server Actions, and RSC patterns'

    dependency_rules:
      domain:
        can_import_from: []  # Domain layer is the core - imports nothing
        cannot_import_from: ['data', 'infra', 'presentation', 'validation', 'main']

      data:
        can_import_from: ['domain']  # Data layer implements domain interfaces
        cannot_import_from: ['presentation', 'validation', 'main']

      validation:
        can_import_from: ['domain']  # Zod schemas validate domain entities and DTOs
        cannot_import_from: ['data', 'presentation', 'main']

      presentation:
        can_import_from: ['domain', 'validation']  # Presentation uses domain and validation
        cannot_import_from: ['data', 'main']

      main:
        can_import_from: ['data', 'domain', 'presentation', 'validation']  # Main layer composes everything
        cannot_import_from: []  # Main is the composition root

    # Clean Architecture principles adapted for React/Next.js
    principles:
      core_principles:
        - "Component Independence: UI components don't depend on external libraries directly"
        - "Testability: Business logic can be tested without DOM, API, or framework dependencies"
        - "Framework Independence: Business rules don't depend on Next.js or React specifics"
        - "Separation: Business rules are isolated from UI concerns"
        - "Dependency Rule: Dependencies point inward toward the domain"

      design_patterns:
        domain:
          - "Interface Pattern: Define contracts for use cases and entities"
          - "ES2015 Modules: Use import/export for code organization"
          - "Type Exports: Separate types for Input and Output DTOs"
          - "Single Method Pattern: One execute() method per use case"
          - "Entity Pattern: Rich domain models with behavior"

        data:
          - "Repository Pattern: HTTP clients implementing domain repositories"
          - "Adapter Pattern: Transform external API data to domain entities"
          - "Cache Pattern: Next.js cache and SWR/React Query integration"
          - "Error Handling: Transform HTTP errors to domain errors"
          - "Fetch Wrapper: Centralized HTTP client with interceptors"

        validation:
          - "Schema Validation: Zod schemas for runtime type validation"
          - "Form Validation: Integration with React Hook Form"
          - "Composite Pattern: Combine multiple field validators"
          - "Builder Pattern: Fluent interface for validation construction"
          - "Error Mapping: Transform validation errors to user-friendly messages"

        presentation:
          actions:
            - "Server Actions: Next.js 15 server-side form handling"
            - "Progressive Enhancement: Works without JavaScript"
            - "Error Boundaries: Graceful error handling in actions"
            - "Revalidation: Automatic cache invalidation after mutations"
          components:
            - "Composition Pattern: Small, composable UI components"
            - "Controlled Components: React controlled inputs with state"
            - "Compound Components: Complex components built from simpler ones"
            - "Render Props: Flexible component composition patterns"
            - "Shadcn/ui: Consistent design system components"
          hooks:
            - "Custom Hooks: Encapsulate business logic and state"
            - "State Management: useState, useReducer for local state"
            - "Effect Management: useEffect for side effects"
            - "Context API: Share state without prop drilling"
            - "Optimistic Updates: Immediate UI feedback for better UX"

        main:
          - "Composite Pattern: Combine use case slices into feature pages"
          - "Factory Pattern: Create composites with all dependencies wired"
          - "Provider Pattern: Context providers for feature-level state"
          - "Higher-Order Components: Add cross-cutting concerns"
          - "Dependency Injection: Constructor injection for composites"

      testing_strategy:
        domain:
          approach: "Unit Tests - Pure functions and business logic"
          coverage_target: "100%"
          tools: ["Vitest"]
          practices:
            - "Use fixed test data helpers instead of faker"
            - "Create mock factories with deterministic data"
            - "Test domain entities and use case interfaces"
            - "Use mockUserParams() with fixed values"
            - "Keep test helpers in tests/domain/mocks directory"
            - "No external dependencies or randomness in tests"

        data:
          approach: "Unit Tests with MSW (Mock Service Worker)"
          coverage_target: "95%"
          tools: ["Vitest", "MSW", "vi.mock"]
          practices:
            - "Mock HTTP clients with MSW handlers"
            - "Use makeSut() factory for test setup"
            - "Test API error scenarios and edge cases"
            - "Verify request payloads and headers"
            - "Use fixed test data from mocks directory"
            - "Mock external API responses consistently"

        validation:
          approach: "Unit Tests - Schema and form validation"
          coverage_target: "100%"
          tools: ["Vitest", "Zod", "@testing-library/react"]
          practices:
            - "Test Zod schemas with valid and invalid data"
            - "Test form validation integration with React Hook Form"
            - "Use makeSut() factory for validator creation"
            - "Test specific error types and messages"
            - "Test validation factories return correct schemas"
            - "Test edge cases (empty fields, malformed data)"

        presentation:
          approach: "Component and Hook Tests"
          coverage_target: "90%"
          tools: ["Vitest", "@testing-library/react", "@testing-library/user-event"]
          practices:
            - "Use render() from React Testing Library for components"
            - "Test user interactions with userEvent.click/type/submit"
            - "Use screen queries (getByRole, getByLabelText, getByTestId)"
            - "Create test helpers (renderWithProviders, setupUser)"
            - "Mock hooks and actions with vi.mock()"
            - "Test loading states, error states, and success states"
            - "Use MSW for integration testing with real API calls"
            - "Test accessibility with jest-axe"

        main:
          approach: "Integration and E2E Tests"
          coverage_target: "80%"
          tools: ["Vitest", "Playwright", "Cypress", "@testing-library/react"]
          practices:
            - "Test complete user flows with Playwright/Cypress"
            - "Test composite components with all dependencies"
            - "Use page object model for E2E tests"
            - "Test responsive design and mobile interactions"
            - "Verify SEO and meta tags in E2E tests"
            - "Test performance metrics (Core Web Vitals)"
            - "Use fixed test data for E2E scenarios"

      best_practices:
        - "SOLID Principles: Apply to React components and hooks"
        - "DRY: Extract common logic to custom hooks"
        - "KISS: Keep components simple and focused"
        - "YAGNI: Build only what's needed, when it's needed"
        - "Component Composition: Favor composition over inheritance"
        - "TypeScript: Use strict type checking throughout"
        - "Accessibility: Follow WCAG guidelines for inclusive design"
        - "Performance: Optimize with React.memo, useMemo, useCallback"
        - "SEO: Leverage Next.js SSR/SSG for search optimization"
        - "Security: Sanitize inputs and validate on both client and server"



# --- From: frontend/03-rules.part.regent ---

  # ------------------------------------------------------------------------------
  # AI-NOTE: IMMUTABLE SECTIONS AHEAD.
  # The sections from here until 'steps' are architectural rules.
  # You MUST copy them verbatim into the implementation file without ANY modification.
  #
  # AUTOMATED LEARNING SYSTEM:
  # The RLHF system automatically:
  # - Tracks success/failure patterns across executions
  # - Identifies common error types and their fixes
  # - Applies improvements when confidence > 80%
  # - Generates learning reports with actionable insights
  # - Prevents hallucinations with score 0 for uncertain cases
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # RULES SECTION
  # All architectural and pattern rules consolidated
  # ------------------------------------------------------------------------------

  rules:
    # Domain layer rules (modern approach)
    domain:
      allowed:
        - 'Type definitions and interfaces (Models)'
        - 'Use case interfaces with single execute() method'
        - 'Separate Input and Output types for each use case'
        - 'Simple data models without behavior'
        - 'JSDoc documentation for all public interfaces'
        - 'ES2015 module exports (export type, export interface)'

      forbidden:
        - 'Multiple methods in a single use case interface'
        - 'Combined operations (e.g., __USE_CASE_NAME__And__OTHER_ACTION__)'
        - 'Framework dependencies (React, Next.js hooks, third-party libraries)'
        - 'External libraries (HTTP clients, validation libraries)'
        - 'Implementation details of any kind'
        - 'React components or UI logic'
        - 'HTTP/API calls or browser APIs'
        - 'Environment variables or client configuration'
        - 'Console.log or any side effects'
        - 'Implementation of business logic (only interfaces allowed)'
        - 'Validation implementations'
        - 'Error throwing or handling'
        - 'Dependency injection'
        - 'Domain entities with methods/behavior (use simple data structures)'

      should:
        - 'Define business entities and value objects'
        - 'Contain only interfaces and types'
        - 'Be framework-agnostic'
        - 'Follow domain-driven design principles'

      should_not:
        - 'Import from other layers'
        - 'Contain implementation details'
        - 'Have framework dependencies'
      use_case:
        should:
          - 'Have only ONE execute() method per interface'
          - 'Define separate Input and Output types'
          - 'Have EXACTLY ONE responsibility (one business operation)'
          - 'Be named with single verb describing ONE action (CreateUser, not CreateUserAndSendEmail)'
          - 'Include comprehensive JSDoc documentation'
          - 'Return Promise<Output> from execute method'
          - 'Be framework agnostic'
          - 'Follow naming convention: VerbNoun (e.g., CreateUser, LoadSurvey, AuthenticateUser)'
        should_not:
          - 'Have multiple methods (no createUser() AND readUser() in same interface)'
          - 'Combine multiple operations (CreateUserAndSendEmail violates SRP)'
          - 'Contain implementation logic'
          - 'Know about HTTP, databases, or external services'
          - 'Import from data, presentation, or infrastructure layers'
          - 'Have side effects'
          - 'Use generic method names like handle(), process(), or run()'

    # Data layer rules
    data:
      should:
        - 'Implement domain use case interfaces'
        - 'Use constructor injection for dependencies'
        - 'Define protocols for external dependencies'
        - 'Use prefix naming (Remote__USE_CASE_NAME__, Api__USE_CASE_NAME__)'
        - 'Handle errors and status codes appropriately'
        - 'Keep business logic minimal (only orchestration)'
        - 'Return domain types, not infrastructure types'

      should_not:
        - 'Import from infrastructure layer directly'
        - 'Contain complex business logic (belongs in domain)'
        - 'Expose infrastructure details to domain'
        - 'Use concrete implementations instead of protocols'
        - 'Have direct API calls or browser APIs (use protocols)'

    # Infrastructure layer rules (Frontend-specific)
    infra:
      should:
        - 'Implement data layer protocols for frontend'
        - 'Use native Fetch API for HTTP requests'
        - 'Use browser localStorage/sessionStorage adapters'
        - 'Implement cache strategies (React Query, SWR, or similar)'
        - 'Handle network retry logic and offline scenarios'
        - 'Use environment variables for API endpoints'
        - 'Implement request/response interceptors'
        - 'Handle CORS and authentication headers'

      should_not:
        - 'Import from domain or use case layers'
        - 'Contain business logic'
        - 'Use multiple HTTP client implementations'
        - 'Expose HTTP-specific types to other layers'
        - 'Use axios or other HTTP libraries (use Fetch API)'
        - 'Access browser APIs directly from other layers'

    # Presentation layer rules (Frontend-specific)
    presentation:
      actions:
        should:
          - 'Use Next.js 15+ Server Actions for form submission'
          - 'Implement proper error handling with redirect/revalidate'
          - 'Use Zod schemas for server-side validation'
          - 'Return ActionResult<T> or FormState for form feedback'
          - 'Handle authentication and authorization'
        should_not:
          - 'Contain business logic (delegate to use cases)'
          - 'Make direct database calls'
          - 'Import from infra layer directly'

      components:
        should:
          - 'Use Shadcn/ui components with Tailwind CSS'
          - 'Prefer Server Components over Client Components'
          - 'Use "use client" directive only when necessary'
          - 'Follow atomic design principles (atoms, molecules, organisms)'
          - 'Implement proper error boundaries'
          - 'Use TypeScript for props and state'
        should_not:
          - 'Use custom CSS/SASS (use Tailwind CSS)'
          - 'Contain business logic (use custom hooks)'
          - 'Make direct API calls (use Server Actions or hooks)'

      hooks:
        should:
          - 'Use React hooks for state management and side effects'
          - 'Implement custom hooks for reusable logic'
          - 'Use Context API for feature-specific state'
          - 'Handle loading, error, and success states'
          - 'Follow hooks rules (no conditional calls)'
        should_not:
          - 'Use Redux or external state managers (use Context API)'
          - 'Contain business logic (delegate to use cases)'
          - 'Make direct API calls (use data layer)'

    # Error rules
    error:
      should:
        - 'Extend the native Error class'
        - 'Have descriptive names ending with Error'
        - 'Contain meaningful error messages'
        - 'Represent business rule violations'
        - 'Be thrown when domain invariants are violated'

      should_not:
        - 'Contain HTTP status codes'
        - 'Include technical/implementation details'
        - 'Expose sensitive information'
        - 'Import external dependencies'

    # Test helper rules
    test_helper:
      should:
        - 'Create mock/stub implementations of use cases'
        - 'Generate fake test data'
        - 'Be pure functions that return consistent data'
        - 'Help reduce test boilerplate'
        - 'Use ONLY Vitest (Jest is prohibited)'

      should_not:
        - 'Make real API calls or database queries'
        - 'Depend on external services'
        - 'Contain test assertions (those belong in test files)'
        - 'Have side effects or maintain state'
        - 'Use Jest (use Vitest instead)'

    # Validation rules (Frontend-specific)
    validation:
      schemas:
        should:
          - 'Use Zod for schema definition and validation'
          - 'Define schemas that match domain models'
          - 'Support both client and server-side validation'
          - 'Include proper error messages for form fields'
          - 'Export schemas for reuse across components'
        should_not:
          - 'Import from domain layer'
          - 'Contain business logic (only validation rules)'
          - 'Use other validation libraries (use Zod)'

      validators:
        should:
          - 'Implement reusable field validators'
          - 'Support synchronous validation for forms'
          - 'Return user-friendly error messages'
          - 'Follow Zod patterns and conventions'
        should_not:
          - 'Import from data or infra layers'
          - 'Throw exceptions (return validation results)'
          - 'Access external services for validation'
          - 'Use async validation (prefer synchronous)'

    # Main layer rules (Frontend-specific)
    main:
      composites:
        should:
          - 'Create composite components that wire all dependencies'
          - 'Compose Server Actions with validation schemas'
          - 'Wire use cases with data layer and validation'
          - 'Export fully configured components ready for App Router'
          - 'Handle error states and loading states'
        should_not:
          - 'Contain business logic (only composition)'
          - 'Make direct API calls'
          - 'Define new interfaces or types'

      pages:
        should:
          - 'Create page composers that aggregate feature composites'
          - 'Use Next.js 15 App Router patterns (layout, page, loading, error)'
          - 'Implement proper SEO metadata and structured data'
          - 'Handle authentication and route protection'
          - 'Export React.FC components for App Router integration'
        should_not:
          - 'Contain business logic (delegate to composites)'
          - 'Have direct state management (use providers)'
          - 'Include complex algorithms or calculations'
          - 'Store application state directly'

    # Reference patterns
    reference_patterns:
      clean_architecture:
        type: 'external_pattern'
        source: 'context7'
        query: 'clean architecture use case'
        url: 'https://github.com/...'
        description: 'Following Clean Architecture pattern.'

      ddd_pattern:
        type: 'external_pattern'
        source: 'context7'
        query: 'domain driven design'
        url: 'https://github.com/...'
        description: 'Following DDD patterns.'

      tdd_pattern:
        type: 'external_pattern'
        source: 'context7'
        query: 'test driven development'
        url: 'https://github.com/...'
        description: 'Following TDD patterns.'

    # Learning patterns (Frontend-specific)
    learning_patterns:
      common_errors:
        - pattern: 'import axios'
          fix: 'Use Fetch API instead of axios in frontend infra layer'
          score_impact: -2

        - pattern: '"use client" everywhere'
          fix: 'Prefer Server Components, use "use client" only when necessary'
          score_impact: -1

        - pattern: 'useState for server state'
          fix: 'Use Server Actions and revalidation instead of client state'
          score_impact: -1

        - pattern: '__USE_CASE_NAME__And__OTHER_ACTION__'
          fix: 'Split into two separate use cases (SRP violation)'
          score_impact: -1

        - pattern: 'missing Zod validation'
          fix: 'Add Zod schema validation for forms and Server Actions'
          score_impact: -2

      success_indicators:
        - 'Uses ubiquitous language consistently'
        - 'Follows single responsibility principle'
        - 'No dependency violations between layers'
        - 'Proper Server Component vs Client Component usage'
        - 'Comprehensive test coverage with Vitest'
        - 'Clean git history with atomic commits'
        - 'Effective use of Next.js App Router patterns'
        - 'Strong TypeScript typing throughout'

    # Required protocols for all layers
    required_protocols:
      # Domain Layer
      domain:
        - 'All use cases must have single execute() method'
        - 'All use cases must define separate Input and Output types'
        - 'All domain types must be immutable'
        - 'No use case can perform multiple operations (SRP)'
        - 'All models must be simple DTOs without behavior'

      # Data Layer
      data:
        - 'All implementations must inject dependencies via constructor'
        - 'All protocols must be interfaces, not concrete classes'
        - 'All implementations must use Db or Remote prefix'
        - 'Must return domain types, not infrastructure types'
        - 'Must handle errors and map status codes appropriately'

      # Infrastructure Layer
      infra:
        - 'All adapters must implement data layer protocols'
        - 'HTTP clients must use Fetch API, not axios'
        - 'Browser storage adapters must use localStorage/sessionStorage'
        - 'All external configs must come from environment variables'
        - 'Must not expose infrastructure types to other layers'

      # Presentation Layer
      presentation:
        - 'Server Actions must return ActionResult<T> or FormState'
        - 'React components must use function components with hooks'
        - 'Pages must be Server Components by default'
        - 'Custom hooks must follow React hooks rules'
        - 'Components must receive dependencies as props'

      # Validation Layer
      validation:
        - 'All schemas must use Zod for validation'
        - 'Schemas must match domain model structure'
        - 'Validation must be synchronous for forms'
        - 'Must support both client and server validation'
        - 'Error messages must be user-friendly'

      # Main Layer
      main:
        - 'All composites must return configured components'
        - 'Composite functions must wire all dependencies'
        - 'No business logic allowed (only composition)'
        - 'Pages must use Next.js App Router patterns'
        - 'Must not define new types (use existing from other layers)'

      # Cross-cutting Concerns
      general:
        - 'All public interfaces must have JSDoc documentation'
        - 'All errors must extend native Error class'
        - 'All test helpers must be pure functions'
        - 'All tests must use Vitest, not Jest'
        - 'No use of faker - fixed test data only'
        - 'All components must be properly typed with TypeScript'
        - 'Use "use client" directive only when necessary'

    # Documentation standards (JSDoc)
    documentation:
      # Domain Layer Documentation
      domain:
        use_case_interface:
          - '@description - Clear description of the use case purpose'
          - '@example - Usage example with execute() method'
          - '@see - Reference to related use cases or documentation'
        input_output_types:
          - '@typedef - Define Input and Output types'
          - '@property - Document each field with type and constraints'
          - '@example - Show valid input/output instances'
        model_type:
          - '@typedef - Define the domain model'
          - '@property - Document each property with business rules'
          - '@example - Show valid model instance'

      # Data Layer Documentation
      data:
        protocol_interface:
          - '@interface - Define protocol contracts'
          - '@method - Document each method signature'
          - '@throws - Document possible errors'
        implementation_class:
          - '@class - Describe the use case implementation'
          - '@implements - List implemented interfaces'
          - '@constructor - Document dependency injection'
          - '@method - Document orchestration logic'

      # Infrastructure Layer Documentation
      infra:
        api_client:
          - '@class - Describe the API client purpose'
          - '@implements - Protocol being implemented'
          - '@dependency - External libraries used (Fetch API)'
        storage_adapter:
          - '@class - Browser storage adapter implementation'
          - '@method - Document storage operations'
          - '@throws - Storage-related errors'
        http_client:
          - '@class - HTTP client implementation for frontend'
          - '@method - Document request/response handling'
          - '@throws - Network-related errors'

      # Presentation Layer Documentation
      presentation:
        server_action:
          - '@function - Server Action description'
          - '@param - Form data or action parameters'
          - '@returns - ActionResult<T> or FormState'
          - '@throws - Validation or business errors'
        react_component:
          - '@component - Component description'
          - '@props - Component properties with TypeScript types'
          - '@state - Component state (if Client Component)'
          - '@returns - JSX.Element'
        custom_hook:
          - '@hook - Custom hook description'
          - '@param - Hook parameters'
          - '@returns - Hook return value with types'
          - '@example - Usage example'

      # Validation Layer Documentation
      validation:
        zod_schema:
          - '@schema - Zod schema description'
          - '@property - Document each field with validation rules'
          - '@example - Show valid and invalid examples'
          - '@returns - Parsed data or validation errors'
        validator_function:
          - '@function - Field validator description'
          - '@param - Value to validate'
          - '@returns - Validation result or error message'

      # Main Layer Documentation
      main:
        composite:
          - '@component - Composite component description'
          - '@returns - Configured component with all dependencies'
          - '@example - How to use the composite'
        page_composer:
          - '@component - Page composer description'
          - '@param - Page props and metadata'
          - '@returns - Next.js page component'
        composition:
          - '@function - Dependency composition for frontend'
          - '@returns - Fully configured React component'

      example_template: |
        /**
        * @description __USE_CASE_DESCRIPTION__
        * @example
        * const __USE_CASE_NAME_CAMEL_CASE__ = new __USE_CASE_NAME_PASCAL_CASE__Impl(__DEPENDENCY_NAME__)
        * const result = await __USE_CASE_NAME_CAMEL_CASE__.execute({
        *   __INPUT_FIELD_1__: '__EXAMPLE_VALUE_1__',
        *   __INPUT_FIELD_2__: '__EXAMPLE_VALUE_2__',
        *   __INPUT_FIELD_3__: '__EXAMPLE_VALUE_3__'
        * })
        * @see {@link __RELATED_USE_CASE__} for __RELATED_DESCRIPTION__
        */
        export interface __USE_CASE_NAME_PASCAL_CASE__ {
          execute(input: __USE_CASE_NAME_PASCAL_CASE__Input): Promise<__USE_CASE_NAME_PASCAL_CASE__Output>
        }

        /**
        * @typedef {Object} __USE_CASE_NAME_PASCAL_CASE__Input
        * @property {string} __INPUT_FIELD_1__ - __FIELD_1_DESCRIPTION__ (__FIELD_1_CONSTRAINTS__)
        * @property {string} __INPUT_FIELD_2__ - __FIELD_2_DESCRIPTION__
        * @property {string} __INPUT_FIELD_3__ - __FIELD_3_DESCRIPTION__ (__FIELD_3_CONSTRAINTS__)
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Input = {
          __INPUT_FIELD_1__: string
          __INPUT_FIELD_2__: string
          __INPUT_FIELD_3__: string
        }

        /**
        * @typedef {Object} __USE_CASE_NAME_PASCAL_CASE__Output
        * @property {string} __OUTPUT_FIELD_1__ - __OUTPUT_FIELD_1_DESCRIPTION__
        * @property {string} __OUTPUT_FIELD_2__ - __OUTPUT_FIELD_2_DESCRIPTION__
        * @property {string} __OUTPUT_FIELD_3__ - __OUTPUT_FIELD_3_DESCRIPTION__
        * @property {Date} __TIMESTAMP_FIELD__ - __TIMESTAMP_DESCRIPTION__
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Output = {
          __OUTPUT_FIELD_1__: string
          __OUTPUT_FIELD_2__: string
          __OUTPUT_FIELD_3__: string
          __TIMESTAMP_FIELD__: Date
        }


# --- From: frontend/steps/03-infra.part.regent ---

  # ------------------------------------------------------------------------------
  # AI-NOTE: INFRASTRUCTURE LAYER IMPLEMENTATION STEPS FOR FRONTEND (TDD)
  # These steps implement infra layer following RED-GREEN-REFACTOR cycle
  # Specific to frontend with Fetch API, Cache, Storage, and Next.js 15 patterns
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # INFRASTRUCTURE LAYER STEPS SECTION
  # Steps for generating infrastructure layer artifacts in frontend features
  # Following Test-Driven Development (RED-GREEN-REFACTOR) methodology
  # Using Fetch API, localStorage, sessionStorage, and frontend-specific patterns
  # ------------------------------------------------------------------------------

  infra_steps:
    # === STEP 1: CREATE FEATURE BRANCH ===
    - id: 'create-feature-branch-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create feature branch for __USE_CASE_NAME_PASCAL_CASE__ frontend infrastructure layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Following Git Flow pattern for feature development.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'git workflow feature branch naming conventions'
          url: 'https://github.com/...'
          description: 'Git Flow and feature branch best practices.'
      run_scripts:
        description: 'Create and checkout feature branch for infra layer development'
        scripts:
          - name: 'Create feature branch'
            command: 'git checkout -b feat/__FEATURE_NAME_KEBAB_CASE__-infra-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Verify branch creation'
            command: 'git branch --show-current'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Push feature branch'
            command: 'git push -u origin feat/__FEATURE_NAME_KEBAB_CASE__-infra-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 2: CREATE INFRA STRUCTURE (RED PHASE) ===
    - id: 'create-infra-structure-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'folder'
      description: 'Create infrastructure layer folder structure for __USE_CASE_NAME_PASCAL_CASE__ frontend use case'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'FRONTEND_ARCHITECTURE.md'
          description: 'Following Clean Architecture infrastructure layer structure for frontend.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'clean architecture infrastructure layer frontend fetch api cache storage'
          url: 'https://github.com/...'
          description: 'Infrastructure layer patterns for frontend with browser APIs.'
      action:
        create_folders:
          basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra'
          folders:
            - 'http'         # HTTP client implementations (Fetch API)
            - 'cache'        # Cache implementations (localStorage, sessionStorage)
            - 'storage'      # Storage adapters for browsers

    # === STEP 3: CREATE FAILING TESTS (RED PHASE) ===
    - id: 'create-infra-failing-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create failing tests for FetchHttpAdapter infrastructure implementation (RED)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'test driven development red phase vitest frontend fetch api mocking'
          url: 'https://github.com/...'
          description: 'TDD RED phase patterns for frontend infrastructure with Vitest.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/http/fetch-http-adapter.spec.ts'
      template: |
        import { describe, it, expect, beforeEach, vi, afterEach, type MockedFunction } from 'vitest'
        import type { HttpClient, HttpRequest, HttpResponse } from '@/data/protocols/http'
        import { FetchHttpAdapter } from './fetch-http-adapter'

        /**
         * TDD Tests for FetchHttpAdapter infrastructure implementation
         * Following RED-GREEN-REFACTOR cycle for frontend HTTP operations
         *
         * @testType Unit Test - Infrastructure Layer with Mocked Fetch
         * @phase RED - These tests should FAIL initially
         */
        describe('FetchHttpAdapter (TDD RED Phase)', () => {
          let sut: FetchHttpAdapter
          let mockFetch: MockedFunction<typeof fetch>

          beforeEach(() => {
            mockFetch = vi.fn()
            global.fetch = mockFetch
            sut = new FetchHttpAdapter()
          })

          afterEach(() => {
            vi.restoreAllMocks()
          })

          describe('RED Phase - These should FAIL', () => {
            it('should implement HttpClient interface', () => {
              // RED: This will fail because FetchHttpAdapter doesn't exist yet
              expect(sut).toBeInstanceOf(FetchHttpAdapter)
              expect(typeof sut.request).toBe('function')
            })

            it('should make GET request with correct parameters', async () => {
              // RED: This will fail because implementation doesn't exist
              const httpRequest: HttpRequest = {
                url: '/api/test',
                method: 'get',
                headers: {
                  'Accept': 'application/json'
                }
              }

              const mockResponse = {
                ok: true,
                status: 200,
                statusText: 'OK',
                headers: new Headers(),
                json: () => Promise.resolve({ data: 'test' })
              }

              mockFetch.mockResolvedValueOnce(mockResponse as any)

              const result = await sut.request(httpRequest)

              expect(mockFetch).toHaveBeenCalledWith('/api/test', {
                method: 'get',
                headers: {
                  'Accept': 'application/json'
                },
                body: undefined
              })

              expect(result).toEqual({
                statusCode: 200,
                body: { data: 'test' }
              })
            })

            it('should make POST request with body', async () => {
              // RED: This will fail because implementation doesn't exist
              const requestBody = {
                __INPUT_FIELD_1__: 'test-value-1',
                __INPUT_FIELD_2__: 'test-value-2'
              }

              const httpRequest: HttpRequest = {
                url: '/api/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: requestBody
              }

              const mockResponse = {
                ok: true,
                status: 201,
                statusText: 'Created',
                headers: new Headers(),
                json: () => Promise.resolve({ id: '123', success: true })
              }

              mockFetch.mockResolvedValueOnce(mockResponse as any)

              const result = await sut.request(httpRequest)

              expect(mockFetch).toHaveBeenCalledWith(
                'https://api.example.com/api/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__',
                {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                  },
                  body: JSON.stringify(requestBody)
                }
              )

              expect(result).toEqual({
                data: { id: '123', success: true },
                status: 201,
                statusText: 'Created',
                headers: {}
              })
            })

            it('should handle request timeout', async () => {
              // RED: This will fail because timeout logic doesn't exist
              const httpRequest: HttpRequest = {
                url: '/api/slow',
                method: 'GET'
              }

              const timeoutError = new Error('Request timeout')
              mockFetch.mockRejectedValueOnce(timeoutError)

              await expect(sut.request(httpRequest)).rejects.toThrow('Request timeout after 30000ms')
            })

            it('should handle network errors', async () => {
              // RED: This will fail because error handling doesn't exist
              const httpRequest: HttpRequest = {
                url: '/api/network-error',
                method: 'GET'
              }

              const networkError = new Error('fetch failed')
              mockFetch.mockRejectedValueOnce(networkError)

              await expect(sut.request(httpRequest)).rejects.toThrow('Network error: fetch failed')
            })

            it('should handle request cancellation', async () => {
              // RED: This will fail because AbortSignal handling doesn't exist
              const controller = new AbortController()
              const httpRequest: HttpRequest = {
                url: '/api/cancel-me',
                method: 'GET',
                signal: controller.signal
              }

              const abortError = new Error('AbortError')
              abortError.name = 'AbortError'
              mockFetch.mockRejectedValueOnce(abortError)

              await expect(sut.request(httpRequest)).rejects.toThrow('Request was cancelled')
            })

            it('should parse different content types', async () => {
              // RED: This will fail because content type parsing doesn't exist
              const httpRequest: HttpRequest = {
                url: '/api/text',
                method: 'GET'
              }

              const mockResponse = {
                ok: true,
                status: 200,
                statusText: 'OK',
                headers: new Headers({
                  'content-type': 'text/plain'
                }),
                text: () => Promise.resolve('plain text response')
              }

              mockFetch.mockResolvedValueOnce(mockResponse as any)

              const result = await sut.request<string>(httpRequest)

              expect(result.data).toBe('plain text response')
            })
          })

          describe('Configuration Tests (RED Phase)', () => {
            it('should handle custom base URL configuration', () => {
              // RED: Will fail if constructor doesn't handle base URL
              const customClient = new Fetch__USE_CASE_NAME_PASCAL_CASE__Client(
                'https://custom.api.com',
                10000
              )

              expect(customClient).toBeDefined()
            })

            it('should handle default configuration', () => {
              // RED: Will fail if default constructor doesn't work
              const defaultClient = new Fetch__USE_CASE_NAME_PASCAL_CASE__Client()

              expect(defaultClient).toBeDefined()
            })
          })

          describe('Type Safety Tests (RED Phase)', () => {
            it('should ensure request type compatibility', () => {
              // RED: Will fail if types are not properly defined
              const validRequest: HttpRequest = {
                url: '/test',
                method: 'POST',
                headers: {
                  'Custom-Header': 'value'
                },
                body: {
                  data: 'test'
                },
                signal: new AbortController().signal
              }

              expect(validRequest).toBeDefined()
            })

            it('should ensure response type compatibility', async () => {
              // RED: Will fail if return type is not correct
              const httpRequest: HttpRequest = {
                url: '/api/typed',
                method: 'GET'
              }

              const mockResponse = {
                ok: true,
                status: 200,
                statusText: 'OK',
                headers: new Headers(),
                json: () => Promise.resolve({ typed: 'data' })
              }

              mockFetch.mockResolvedValueOnce(mockResponse as any)

              const result: HttpResponse<{ typed: string }> = await sut.request(httpRequest)

              // TypeScript should enforce these types
              expect(result.data.typed).toBe('data')
              expect(typeof result.status).toBe('number')
              expect(typeof result.statusText).toBe('string')
              expect(typeof result.headers).toBe('object')
            })
          })
        })


    # === STEP 4: CREATE HTTP CLIENT IMPLEMENTATION (GREEN PHASE) ===
    - id: 'create-http-client-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create FetchHttpAdapter implementation to make tests pass (GREEN)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'fetch api adapter implementation typescript frontend http'
          url: 'https://github.com/...'
          description: 'Fetch API adapter implementation patterns for frontend.'
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: 'FetchHttpAdapter'
          description: 'Consistent with existing HTTP adapter implementations.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/http/fetch-http-adapter.ts'
      template: |
        import type { HttpClient, HttpRequest, HttpResponse, HttpStatusCode } from '@/data/protocols/http'

        /**
         * Fetch API implementation of HttpClient protocol
         * Concrete adapter for HTTP operations using native Fetch API
         *
         * @implementation Infrastructure Layer - HTTP Adapter
         * @pattern Adapter Pattern - Fetch API implementation
         * @layer Infrastructure - External service communication
         */
        export class FetchHttpAdapter implements HttpClient {
          /**
           * Execute HTTP request using Fetch API
           *
           * @param data - HTTP request configuration
           * @returns Promise with HTTP response following HttpClient protocol
           */
          async request(data: HttpRequest): Promise<HttpResponse> {
            let response: Response

            try {
              response = await fetch(data.url, {
                method: data.method,
                body: data.body ? JSON.stringify(data.body) : undefined,
                headers: data.headers
              })
            } catch (error) {
              // Handle network errors - return as if it was a server error
              return {
                statusCode: 500,
                body: undefined
              }
            }

            let body: any
            try {
              body = await response.json()
            } catch (error) {
              // If JSON parsing fails, return undefined body
              body = undefined
            }

            return {
              statusCode: response.status,
              body
            }
          }
        }

    # === STEP 5: RUN PASSING TESTS (GREEN PHASE) ===
    - id: 'run-passing-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Verify all tests pass with HTTP client implementation (GREEN phase)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      run_scripts:
        description: 'Run tests to verify GREEN phase completion'
        scripts:
          - name: 'Run passing tests'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/http --coverage'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Commit GREEN phase'
            command: 'git add . && git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): implement __USE_CASE_NAME_KEBAB_CASE__ HTTP client (GREEN)"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 6: CREATE CACHE IMPLEMENTATION (GREEN PHASE) ===
    - id: 'create-cache-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create browser cache adapter for __USE_CASE_NAME_PASCAL_CASE__ (GREEN)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'browser cache implementation localStorage sessionStorage typescript'
          url: 'https://github.com/...'
          description: 'Browser storage and cache implementation patterns.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/cache/browser-cache-adapter.ts'
      template: |
        /**
         * Generic cache interface for browser storage operations
         */
        export interface CacheClient {
          get<T = unknown>(key: string): Promise<T | null>
          set<T = unknown>(key: string, value: T, ttl?: number): Promise<void>
          invalidate(key: string): Promise<void>
        }

        /**
         * Browser cache implementation using localStorage/sessionStorage
         * Provides caching capabilities for frontend operations
         *
         * @implementation Infrastructure Layer - Cache Adapter
         * @pattern Adapter Pattern - Browser storage implementation
         * @layer Infrastructure - Browser storage communication
         */
        export class BrowserCacheAdapter implements CacheClient {
          private readonly storage: Storage

          constructor() {
            this.storage = typeof window !== 'undefined' ? window.localStorage : {} as Storage
          }

          async get<T = unknown>(key: string): Promise<T | null> {
            try {
              const item = this.storage.getItem(key)
              if (!item) return null

              const { data, expiresAt } = JSON.parse(item)
              if (expiresAt && Date.now() > expiresAt) {
                await this.invalidate(key)
                return null
              }

              return data as T
            } catch {
              return null
            }
          }

          async set<T = unknown>(key: string, value: T, ttl?: number): Promise<void> {
            try {
              const item = {
                data: value,
                expiresAt: ttl ? Date.now() + ttl : null
              }
              this.storage.setItem(key, JSON.stringify(item))
            } catch {
              // Silent failure
            }
          }

          async invalidate(key: string): Promise<void> {
            try {
              this.storage.removeItem(key)
            } catch {
              // Silent failure
            }
          }
        }

    # === STEP 7: CREATE STORAGE ADAPTER (GREEN PHASE) ===
    - id: 'create-storage-adapter-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create storage adapter for __USE_CASE_NAME_PASCAL_CASE__ persistence'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'browser storage adapter patterns typescript frontend'
          url: 'https://github.com/...'
          description: 'Browser storage adapter patterns for persistence.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/storage/browser-storage-adapter.ts'
      template: |
        /**
         * Browser storage adapter for persistent data
         * Simple localStorage wrapper following the established patterns
         *
         * @implementation Infrastructure Layer - Storage Adapter
         * @pattern Adapter Pattern - Browser storage implementation
         * @layer Infrastructure - Persistent storage operations
         */
        export class BrowserStorageAdapter {
          private readonly storage: Storage

          constructor() {
            this.storage = typeof window !== 'undefined' ? window.localStorage : {} as Storage
          }

          set(key: string, value: any): void {
            try {
              this.storage.setItem(key, JSON.stringify(value))
            } catch {
              // Silent failure
            }
          }

          get<T = unknown>(key: string): T | null {
            try {
              const item = this.storage.getItem(key)
              return item ? JSON.parse(item) : null
            } catch {
              return null
            }
          }

          remove(key: string): void {
            try {
              this.storage.removeItem(key)
            } catch {
              // Silent failure
            }
          }
        }

    # === STEP 8: REFACTOR IMPLEMENTATION (REFACTOR PHASE) ===
    - id: 'refactor-infra-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Add error handling and validation to HTTP adapter (REFACTOR)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'http client error handling frontend typescript'
          url: 'https://github.com/...'
          description: 'Error handling patterns for HTTP clients.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/http/fetch-http-adapter.ts'
      template: |
        import type { HttpClient, HttpRequest, HttpResponse } from '@/data/protocols/http'

        /**
         * Enhanced Fetch API implementation with better error handling
         * Refactored for production use following established patterns
         *
         * @implementation Infrastructure Layer - HTTP Adapter (Refactored)
         * @pattern Adapter Pattern - Enhanced Fetch API implementation
         * @layer Infrastructure - Robust external service communication
         */
        export class FetchHttpAdapter implements HttpClient {
          async request(data: HttpRequest): Promise<HttpResponse> {
            let response: Response

            try {
              response = await fetch(data.url, {
                method: data.method,
                body: data.body ? JSON.stringify(data.body) : undefined,
                headers: data.headers
              })
            } catch (error) {
              // Network errors, CORS, etc.
              return {
                statusCode: 500,
                body: undefined
              }
            }

            // Handle different response types
            let body: any
            try {
              const contentType = response.headers.get('content-type')
              if (contentType?.includes('application/json')) {
                body = await response.json()
              } else {
                body = await response.text()
              }
            } catch (error) {
              body = undefined
            }

            return {
              statusCode: response.status,
              body
            }
          }
        }

    # === STEP 9: CREATE INTEGRATION TESTS (REFACTOR PHASE) ===
    - id: 'create-integration-tests-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create integration tests for complete infrastructure layer (REFACTOR)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'integration testing infrastructure layer http cache storage vitest'
          url: 'https://github.com/...'
          description: 'Integration testing patterns for infrastructure layer.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/__tests__/infrastructure.integration.spec.ts'
      template: |
        import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
        import { Fetch__USE_CASE_NAME_PASCAL_CASE__Client } from '../http/fetch-__USE_CASE_NAME_KEBAB_CASE__-client'
        import { Browser__USE_CASE_NAME_PASCAL_CASE__Cache } from '../cache/browser-__USE_CASE_NAME_KEBAB_CASE__-cache'
        import { Browser__USE_CASE_NAME_PASCAL_CASE__Storage } from '../storage/browser-__USE_CASE_NAME_KEBAB_CASE__-storage'
        import type { HttpRequest } from '../../data/protocols/__USE_CASE_NAME_KEBAB_CASE__-http-client'

        /**
         * Integration tests for __USE_CASE_NAME_PASCAL_CASE__ infrastructure layer
         * Tests complete infrastructure functionality with HTTP, cache, and storage
         *
         * @testType Integration Test - Complete Infrastructure Flow
         * @coverage End-to-end infrastructure layer functionality
         */
        describe('__USE_CASE_NAME_PASCAL_CASE__ Infrastructure Integration', () => {
          let httpClient: Fetch__USE_CASE_NAME_PASCAL_CASE__Client
          let cache: Browser__USE_CASE_NAME_PASCAL_CASE__Cache
          let storage: Browser__USE_CASE_NAME_PASCAL_CASE__Storage
          let mockFetch: ReturnType<typeof vi.fn>

          // Mock localStorage and sessionStorage
          const localStorageMock = {
            getItem: vi.fn(),
            setItem: vi.fn(),
            removeItem: vi.fn(),
            clear: vi.fn(),
            length: 0,
            key: vi.fn()
          }

          beforeEach(() => {
            mockFetch = vi.fn()
            global.fetch = mockFetch

            // Mock browser storage
            Object.defineProperty(window, 'localStorage', {
              value: localStorageMock,
              writable: true
            })

            Object.defineProperty(window, 'sessionStorage', {
              value: localStorageMock,
              writable: true
            })

            httpClient = new Fetch__USE_CASE_NAME_PASCAL_CASE__Client({
              baseUrl: 'https://test.api.com',
              timeout: 5000
            })

            cache = new Browser__USE_CASE_NAME_PASCAL_CASE__Cache('local')
            storage = new Browser__USE_CASE_NAME_PASCAL_CASE__Storage('local')
          })

          afterEach(() => {
            vi.clearAllMocks()
          })

          describe('HTTP Client Integration', () => {
            it('should handle complete HTTP request flow', async () => {
              const request: HttpRequest = {
                url: '/api/test',
                method: 'POST',
                headers: {
                  'Custom-Header': 'test-value'
                },
                body: {
                  data: 'integration-test'
                }
              }

              const mockResponse = {
                ok: true,
                status: 200,
                statusText: 'OK',
                headers: new Headers({
                  'content-type': 'application/json'
                }),
                json: () => Promise.resolve({
                  id: 'integration-123',
                  success: true,
                  message: 'Integration test successful'
                })
              }

              mockFetch.mockResolvedValueOnce(mockResponse)

              const result = await httpClient.request(request)

              expect(result).toEqual({
                data: {
                  id: 'integration-123',
                  success: true,
                  message: 'Integration test successful'
                },
                status: 200,
                statusText: 'OK',
                headers: {
                  'content-type': 'application/json'
                }
              })

              expect(mockFetch).toHaveBeenCalledWith('https://test.api.com/api/test', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json',
                  'Custom-Header': 'test-value'
                },
                body: JSON.stringify({ data: 'integration-test' }),
                signal: undefined
              })
            })

            it('should handle HTTP errors with retry logic', async () => {
              const request: HttpRequest = {
                url: '/api/retry-test',
                method: 'GET'
              }

              const clientWithRetries = new Fetch__USE_CASE_NAME_PASCAL_CASE__Client({
                baseUrl: 'https://test.api.com',
                retries: 2,
                retryDelay: 100
              })

              // Mock network error
              const networkError = new Error('fetch failed')
              mockFetch
                .mockRejectedValueOnce(networkError)
                .mockRejectedValueOnce(networkError)
                .mockResolvedValueOnce({
                  ok: true,
                  status: 200,
                  statusText: 'OK',
                  headers: new Headers(),
                  json: () => Promise.resolve({ success: true })
                })

              const result = await clientWithRetries.request(request)

              expect(result.data).toEqual({ success: true })
              expect(mockFetch).toHaveBeenCalledTimes(3) // Initial + 2 retries
            })
          })

          describe('Cache Integration', () => {
            it('should cache and retrieve data correctly', async () => {
              const testData = {
                id: 'cache-test-123',
                value: 'integration-cache-data'
              }

              localStorageMock.getItem.mockReturnValue(null) // Not cached initially

              // Cache the data
              await cache.set('test-key', testData, 5000) // 5 second TTL

              expect(localStorageMock.setItem).toHaveBeenCalledWith(
                '__USE_CASE_NAME_KEBAB_CASE__:test-key',
                expect.stringContaining('"data":{"id":"cache-test-123","value":"integration-cache-data"}')
              )

              // Mock cached data retrieval
              localStorageMock.getItem.mockReturnValue(JSON.stringify({
                data: testData,
                cachedAt: Date.now(),
                expiresAt: Date.now() + 5000
              }))

              const cachedData = await cache.get('test-key')

              expect(cachedData).toEqual(testData)
              expect(localStorageMock.getItem).toHaveBeenCalledWith(
                '__USE_CASE_NAME_KEBAB_CASE__:test-key'
              )
            })

            it('should handle cache expiration', async () => {
              const expiredData = JSON.stringify({
                data: { expired: true },
                cachedAt: Date.now() - 10000,
                expiresAt: Date.now() - 5000 // Expired 5 seconds ago
              })

              localStorageMock.getItem.mockReturnValue(expiredData)

              const result = await cache.get('expired-key')

              expect(result).toBeNull()
              expect(localStorageMock.removeItem).toHaveBeenCalledWith(
                '__USE_CASE_NAME_KEBAB_CASE__:expired-key'
              )
            })
          })

          describe('Storage Integration', () => {
            it('should store and retrieve data persistently', async () => {
              const testData = {
                id: 'storage-test-456',
                persistentValue: 'integration-storage-data'
              }

              localStorageMock.getItem.mockReturnValue(null) // Not stored initially

              // Store the data
              await storage.store('persistent-key', testData)

              expect(localStorageMock.setItem).toHaveBeenCalledWith(
                '__USE_CASE_NAME_KEBAB_CASE__-storage:persistent-key',
                expect.stringContaining('"data":{"id":"storage-test-456","persistentValue":"integration-storage-data"}')
              )

              // Mock stored data retrieval
              localStorageMock.getItem.mockReturnValue(JSON.stringify({
                data: testData,
                storedAt: new Date().toISOString(),
                version: '1.0'
              }))

              const storedData = await storage.retrieve('persistent-key')

              expect(storedData).toEqual(testData)
              expect(localStorageMock.getItem).toHaveBeenCalledWith(
                '__USE_CASE_NAME_KEBAB_CASE__-storage:persistent-key'
              )
            })

            it('should check data existence correctly', async () => {
              localStorageMock.getItem.mockReturnValue('some-data')

              const exists = await storage.exists('test-key')

              expect(exists).toBe(true)
              expect(localStorageMock.getItem).toHaveBeenCalledWith(
                '__USE_CASE_NAME_KEBAB_CASE__-storage:test-key'
              )
            })
          })

          describe('Cross-Component Integration', () => {
            it('should integrate HTTP client with cache for optimized requests', async () => {
              // Simulate a complete flow: HTTP request -> cache result -> retrieve from cache
              const apiData = {
                id: 'integration-789',
                fromApi: true,
                timestamp: Date.now()
              }

              // First request: Cache miss, fetch from API
              localStorageMock.getItem.mockReturnValue(null)

              mockFetch.mockResolvedValueOnce({
                ok: true,
                status: 200,
                statusText: 'OK',
                headers: new Headers({ 'content-type': 'application/json' }),
                json: () => Promise.resolve(apiData)
              })

              const request: HttpRequest = {
                url: '/api/cached-data',
                method: 'GET'
              }

              // Fetch from API
              const apiResponse = await httpClient.request(request)
              expect(apiResponse.data).toEqual(apiData)

              // Cache the result
              await cache.set('api-data', apiResponse.data, 30000)

              // Second request: Cache hit
              localStorageMock.getItem.mockReturnValue(JSON.stringify({
                data: apiData,
                cachedAt: Date.now(),
                expiresAt: Date.now() + 30000
              }))

              const cachedResult = await cache.get('api-data')

              expect(cachedResult).toEqual(apiData)
              expect(mockFetch).toHaveBeenCalledTimes(1) // Only called once, second time from cache
            })

            it('should handle storage persistence across browser sessions', async () => {
              const sessionData = {
                userId: 'user-123',
                sessionId: 'session-456',
                preferences: {
                  theme: 'dark',
                  language: 'en'
                }
              }

              // Store session data
              await storage.store('user-session', sessionData)

              expect(localStorageMock.setItem).toHaveBeenCalledWith(
                '__USE_CASE_NAME_KEBAB_CASE__-storage:user-session',
                expect.stringContaining('"userId":"user-123"')
              )

              // Simulate browser refresh - retrieve session data
              localStorageMock.getItem.mockReturnValue(JSON.stringify({
                data: sessionData,
                storedAt: new Date().toISOString(),
                version: '1.0'
              }))

              const retrievedSession = await storage.retrieve('user-session')

              expect(retrievedSession).toEqual(sessionData)
              expect(retrievedSession?.preferences.theme).toBe('dark')
            })
          })

          describe('Error Handling Integration', () => {
            it('should handle complete failure gracefully', async () => {
              // Simulate complete infrastructure failure
              mockFetch.mockRejectedValue(new Error('Complete network failure'))
              localStorageMock.getItem.mockImplementation(() => {
                throw new Error('Storage not available')
              })

              const request: HttpRequest = {
                url: '/api/fail',
                method: 'GET'
              }

              // HTTP should fail
              await expect(httpClient.request(request)).rejects.toThrow('Network error')

              // Cache should fail gracefully (return null)
              const cacheResult = await cache.get('fail-key')
              expect(cacheResult).toBeNull()

              // Storage should throw error
              await expect(storage.retrieve('fail-key')).rejects.toThrow()
            })
          })
        })

    # === STEP 10: FINAL VALIDATION (REFACTOR PHASE) ===
    - id: 'validate-refactored-implementation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Run all tests and validations after refactoring (REFACTOR phase complete)'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      run_scripts:
        description: 'Complete TDD cycle validation and commit refactored code'
        scripts:
          - name: 'Run all infrastructure layer tests'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra --coverage --reporter=verbose'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'TypeScript compilation check'
            command: 'npx tsc --noEmit --project tsconfig.json'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'ESLint validation'
            command: 'npm run lint -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Commit refactored implementation'
            command: 'git add . && git commit -m "refactor(__FEATURE_NAME_KEBAB_CASE__): improve __USE_CASE_NAME_KEBAB_CASE__ infra layer design (REFACTOR)"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 11: VALIDATE COMPLETE INFRASTRUCTURE LAYER ===
    - id: 'validate-complete-infrastructure-layer-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Final validation of complete frontend infrastructure layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      run_scripts:
        description: 'Run comprehensive validation of frontend infrastructure layer'
        scripts:
          - name: 'Complete test suite'
            command: 'npm run test -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra --coverage --run'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'TypeScript strict compilation'
            command: 'npx tsc --noEmit --strict --project tsconfig.json'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'ESLint with strict rules'
            command: 'npm run lint -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra --max-warnings 0'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Clean Architecture validation'
            command: 'npm run arch:check -- --layer=infra --feature=__FEATURE_NAME_KEBAB_CASE__ --use-case=__USE_CASE_NAME_KEBAB_CASE__'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Bundle size analysis'
            command: 'npm run analyze -- --feature=__FEATURE_NAME_KEBAB_CASE__'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Performance analysis'
            command: 'npm run perf:analyze -- --infra-layer'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Final commit'
            command: 'git add . && git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): complete __USE_CASE_NAME_KEBAB_CASE__ frontend infrastructure layer with TDD"'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 12: OPEN PULL REQUEST ===
    - id: 'open-pull-request-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Open Pull Request for frontend infrastructure layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'PULL_REQUEST_TEMPLATE.md'
          description: 'Following PR template and code review guidelines.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'pull request best practices code review checklist infrastructure'
          url: 'https://github.com/...'
          description: 'PR and code review best practices for infrastructure layer.'
      run_scripts:
        description: 'Create pull request with comprehensive description and checklist'
        scripts:
          - name: 'Push final changes'
            command: 'git push origin feat/__FEATURE_NAME_KEBAB_CASE__-infra-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Create Pull Request'
            command: |
              gh pr create \
                --title "feat(__FEATURE_NAME_KEBAB_CASE__): implement __USE_CASE_NAME_KEBAB_CASE__ frontend infrastructure layer with TDD" \
                --body "## Summary

              Implements complete frontend infrastructure layer for __USE_CASE_NAME_PASCAL_CASE__ use case following Clean Architecture and TDD methodology.

              ### 🚀 Features Implemented
              - ✅ Fetch__USE_CASE_NAME_PASCAL_CASE__Client implementation with native Fetch API
              - ✅ Browser cache implementation with localStorage/sessionStorage
              - ✅ Storage adapter for persistent data management
              - ✅ Complete TDD cycle (RED-GREEN-REFACTOR) with comprehensive tests
              - ✅ Error handling with retry logic and timeout management
              - ✅ Type-safe implementation with TypeScript
              - ✅ Integration tests with realistic browser scenarios
              - ✅ Request cancellation and timeout handling
              - ✅ Cache expiration and storage persistence

              ### 🧪 Test Coverage
              - Unit tests for HTTP client with mocked fetch
              - Unit tests for cache and storage implementations
              - Integration tests with complete infrastructure flow
              - Error scenario testing (network, timeout, storage failures)
              - Browser compatibility and edge case testing
              - Complete TDD methodology validation

              ### 🏗️ Architecture Compliance
              - ✅ Clean Architecture layers respected
              - ✅ Infrastructure layer implements data layer protocols
              - ✅ Native browser APIs used (Fetch, localStorage, sessionStorage)
              - ✅ No dependencies on external HTTP libraries (axios forbidden)
              - ✅ Proper error transformation to domain-appropriate errors
              - ✅ Environment configuration support

              ### 📋 Code Review Checklist
              - [ ] All tests passing (npm run test)
              - [ ] TypeScript compilation clean (npx tsc --noEmit)
              - [ ] ESLint validation passed (npm run lint)
              - [ ] Clean Architecture principles followed
              - [ ] No dependency violations between layers
              - [ ] Fetch API used instead of axios
              - [ ] Browser storage implementations robust
              - [ ] Error handling comprehensive and appropriate
              - [ ] Code follows project conventions and patterns
              - [ ] Documentation and JSDoc comments present
              - [ ] Performance optimizations implemented
              - [ ] Security best practices followed

              ### 🔍 Review Focus Areas
              1. **HTTP Client Implementation**: Review Fetch__USE_CASE_NAME_PASCAL_CASE__Client structure and API communication logic
              2. **Cache Strategy**: Validate cache implementation with TTL and expiration handling
              3. **Storage Persistence**: Ensure storage adapter handles browser storage correctly
              4. **Error Handling**: Verify error transformation and retry logic
              5. **Architecture**: Confirm Clean Architecture compliance and dependency directions
              6. **Browser Compatibility**: Check for cross-browser support and edge cases

              ### 📊 Metrics
              - Test Coverage: Aiming for >95% coverage
              - TypeScript: Strict compilation with no any types
              - ESLint: Zero warnings/errors
              - Bundle Size Impact: Minimal (infrastructure utilities only)
              - Performance: Optimized HTTP client with retry and caching

              ### 🌐 Browser Support
              - Modern browsers with Fetch API support
              - Graceful fallback for storage unavailability
              - Request cancellation support with AbortController
              - Timeout handling for slow networks

              ---
              🤖 Generated with TDD methodology and Clean Architecture best practices" \
                --draft
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Display PR URL'
            command: 'gh pr view --web'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 13: AI CODE REVIEW ===
    - id: 'ai-code-review-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'AI-powered code review and quality analysis for frontend infrastructure layer'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'CODE_REVIEW_GUIDELINES.md'
          description: 'Automated code review standards and quality gates.'
        - type: 'external_pattern'
          source: 'context7'
          query: 'automated code review infrastructure clean architecture typescript frontend'
          url: 'https://github.com/...'
          description: 'AI code review patterns and quality metrics for infrastructure.'
      ai_review_prompts:
        architecture_review: |
          Please review this frontend infrastructure layer implementation for Clean Architecture compliance:

          📁 Files to Review:
          - src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/http/fetch-__USE_CASE_NAME_KEBAB_CASE__-client.ts
          - src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/cache/browser-__USE_CASE_NAME_KEBAB_CASE__-cache.ts
          - src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra/storage/browser-__USE_CASE_NAME_KEBAB_CASE__-storage.ts

          🎯 Review Criteria:
          1. **Clean Architecture Compliance**: Verify dependency direction (infra → data, no domain imports)
          2. **Frontend Patterns**: Confirm native browser API usage, no external HTTP libraries
          3. **Error Handling**: Evaluate error transformation and browser-specific error cases
          4. **Type Safety**: Check TypeScript usage and browser API type compatibility
          5. **Testing Strategy**: Review TDD implementation and browser testing approach

          🔍 Focus Areas:
          - No imports from domain or outer layers
          - Implements data layer protocols correctly
          - Uses Fetch API instead of axios or other HTTP libraries
          - Proper browser storage handling (localStorage/sessionStorage)
          - Error handling transforms infrastructure errors to domain errors
          - Browser compatibility and graceful degradation
          - Request timeout and cancellation support

          Please provide specific feedback on architecture violations and improvement suggestions.

        browser_compatibility_review: |
          Please perform a comprehensive browser compatibility review for this frontend infrastructure:

          🎯 Compatibility Areas:
          1. **Fetch API Usage**: Verify proper Fetch API implementation and polyfill requirements
          2. **Storage APIs**: Check localStorage and sessionStorage usage patterns
          3. **Error Handling**: Evaluate browser-specific error scenarios
          4. **Performance**: Assess impact on different browsers and devices
          5. **Security**: Review CORS, CSP, and browser security implications

          🔍 Specific Checks:
          - Fetch API feature detection and fallback strategies
          - Storage quota handling and storage unavailability
          - AbortController support for request cancellation
          - Memory leak prevention in browser environment
          - HTTPS requirements and mixed content issues
          - Browser cache management and cache headers

          Please provide actionable feedback with specific browser compatibility improvements.

        performance_review: |
          Please perform a performance analysis for this frontend infrastructure layer:

          🎯 Performance Metrics:
          1. **Network Performance**: HTTP client efficiency and optimization
          2. **Memory Usage**: Browser storage and cache memory management
          3. **Bundle Size**: Infrastructure code impact on bundle size
          4. **Runtime Performance**: Execution efficiency in browser environment
          5. **Cache Strategy**: Cache effectiveness and invalidation performance

          🔍 Specific Analysis:
          - HTTP request batching and connection reuse
          - Cache hit/miss ratios and storage efficiency
          - Memory leaks in event listeners and timeouts
          - Bundle tree-shaking and dead code elimination
          - Browser storage performance with large datasets
          - Network retry logic and exponential backoff

          Please provide performance optimization recommendations with measurable improvements.

        security_review: |
          Please review the security aspects of this frontend infrastructure implementation:

          📋 Security Areas to Evaluate:
          1. **Data Protection**: Sensitive data handling in storage and cache
          2. **Network Security**: HTTPS requirements and secure communication
          3. **Browser Security**: XSS prevention and secure storage practices
          4. **Error Exposure**: Information disclosure in error messages
          5. **Configuration Security**: Environment variable and API key handling

          🛡️ Security Checks:
          - No sensitive data logged in development or production
          - Secure storage practices (no plaintext passwords/tokens)
          - Proper CORS configuration and origin validation
          - Error messages don't expose system internals
          - Environment variables properly scoped and secured
          - Cache doesn't store sensitive information inappropriately

          Please provide security improvements with specific mitigation strategies.

      run_scripts:
        description: 'Execute AI code review process for infrastructure layer'
        scripts:
          - name: 'Run automated architecture validation'
            command: 'npm run arch:validate -- --layer=infra --feature=__FEATURE_NAME_KEBAB_CASE__ --use-case=__USE_CASE_NAME_KEBAB_CASE__'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Generate code coverage report'
            command: 'npm run test:coverage -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Security analysis'
            command: 'npm run security:check -- --infra-layer'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Performance analysis'
            command: 'npm run perf:analyze -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Bundle size impact analysis'
            command: 'npm run analyze:bundle -- --feature=__FEATURE_NAME_KEBAB_CASE__ --layer=infra'
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 14: CLEANUP AND MERGE ===
    - id: 'cleanup-and-merge-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Final cleanup, review approval, and merge frontend infrastructure layer implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'MERGE_GUIDELINES.md'
          description: 'Merge process and cleanup procedures.'
      run_scripts:
        description: 'Complete PR merge and cleanup process'
        scripts:
          - name: 'Final validation before merge'
            command: 'npm run validate:all -- src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/infra'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Browser compatibility check'
            command: 'npm run test:browsers -- --infra-layer'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Security final scan'
            command: 'npm run security:scan -- --layer=infra'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Merge Pull Request'
            command: 'gh pr merge --squash --delete-branch'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Switch back to main branch'
            command: 'git checkout main'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Pull latest changes'
            command: 'git pull origin main'
            workingDirectory: '__PROJECT_NAME__'
          - name: 'Cleanup local branch'
            command: 'git branch -d feat/__FEATURE_NAME_KEBAB_CASE__-infra-__USE_CASE_NAME_KEBAB_CASE__-frontend'
            workingDirectory: '__PROJECT_NAME__'

    # === OPTIONAL: BROWNFIELD REFACTORING STEPS ===
    # These steps can be used to refactor existing frontend code to Clean Architecture
    - id: 'refactor-existing-__USE_CASE_NAME_KEBAB_CASE__-infra-1'
      type: 'conditional_refactor'
      description: 'Refactor existing axios usage to Fetch API implementation'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: 'check_existing_axios_usage'
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'refactoring axios to fetch api clean architecture frontend'
          url: 'https://github.com/...'
          description: 'Brownfield refactoring patterns for HTTP clients.'
      refactor_pattern:
        find_pattern: |
          # AI-NOTE: Identify axios imports and usage
          # Look for: import axios from 'axios'
          # Replace ALL axios calls with FetchHttpClient
          <<<FIND>>>
          // Legacy axios usage pattern
          import axios from 'axios'

          const response = await axios.post('/api/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__', {
            __INPUT_FIELD_1__: data.__INPUT_FIELD_1__,
            __INPUT_FIELD_2__: data.__INPUT_FIELD_2__
          }, {
            headers: {
              'Content-Type': 'application/json'
            },
            timeout: 30000
          })

          return response.data
          <<</FIND>>>
        replace_pattern: |
          # AI-NOTE: Ensure replacement:
          # - Uses FetchHttpClient from infra layer
          # - Implements proper error handling
          # - Uses dependency injection
          # - Is testable with mocks
          <<<REPLACE>>>
          // Refactored to use Clean Architecture infrastructure layer
          import { Fetch__USE_CASE_NAME_PASCAL_CASE__Client } from '../infra/http/fetch-__USE_CASE_NAME_KEBAB_CASE__-client'

          const httpClient = new Fetch__USE_CASE_NAME_PASCAL_CASE__Client()

          const response = await httpClient.request({
            url: '/api/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: {
              __INPUT_FIELD_1__: data.__INPUT_FIELD_1__,
              __INPUT_FIELD_2__: data.__INPUT_FIELD_2__
            }
          })

          return response.data
          <<</REPLACE>>>

    - id: 'refactor-existing-__USE_CASE_NAME_KEBAB_CASE__-infra-2'
      type: 'conditional_refactor'
      description: 'Refactor direct localStorage usage to storage adapter pattern'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: 'check_direct_localstorage_usage'
      refactor_pattern:
        find_pattern: |
          <<<FIND>>>
          // Legacy direct localStorage usage
          const saveUserPreferences = (preferences: UserPreferences) => {
            localStorage.setItem('user-preferences', JSON.stringify(preferences))
          }

          const loadUserPreferences = (): UserPreferences | null => {
            const stored = localStorage.getItem('user-preferences')
            return stored ? JSON.parse(stored) : null
          }

          const clearUserPreferences = () => {
            localStorage.removeItem('user-preferences')
          }
          <<</FIND>>>
        replace_pattern: |
          # AI-NOTE: Ensure replacement:
          # - Uses FetchHttpClient from infra layer
          # - Implements proper error handling
          # - Uses dependency injection
          # - Is testable with mocks
          <<<REPLACE>>>
          // Refactored to use Clean Architecture storage adapter
          import { Browser__USE_CASE_NAME_PASCAL_CASE__Storage } from '../infra/storage/browser-__USE_CASE_NAME_KEBAB_CASE__-storage'

          const storage = new Browser__USE_CASE_NAME_PASCAL_CASE__Storage()

          const saveUserPreferences = async (preferences: UserPreferences) => {
            await storage.store('user-preferences', preferences)
          }

          const loadUserPreferences = async (): Promise<UserPreferences | null> => {
            return await storage.retrieve<UserPreferences>('user-preferences')
          }

          const clearUserPreferences = async () => {
            await storage.remove('user-preferences')
          }
          <<</REPLACE>>>

    - id: 'refactor-existing-__USE_CASE_NAME_KEBAB_CASE__-infra-3'
      type: 'conditional_refactor'
      description: 'Refactor manual cache management to cache adapter pattern'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: 'check_manual_cache_management'
      refactor_pattern:
        find_pattern: |
          <<<FIND>>>
          // Legacy manual cache management
          const CACHE_KEY = '__USE_CASE_NAME_KEBAB_CASE__-cache'
          const CACHE_TTL = 5 * 60 * 1000 // 5 minutes

          const getCachedData = () => {
            const cached = localStorage.getItem(CACHE_KEY)
            if (!cached) return null

            const { data, timestamp } = JSON.parse(cached)
            if (Date.now() - timestamp > CACHE_TTL) {
              localStorage.removeItem(CACHE_KEY)
              return null
            }

            return data
          }

          const setCachedData = (data: any) => {
            const cacheItem = {
              data,
              timestamp: Date.now()
            }
            localStorage.setItem(CACHE_KEY, JSON.stringify(cacheItem))
          }
          <<</FIND>>>
        replace_pattern: |
          # AI-NOTE: Ensure replacement:
          # - Uses FetchHttpClient from infra layer
          # - Implements proper error handling
          # - Uses dependency injection
          # - Is testable with mocks
          <<<REPLACE>>>
          // Refactored to use Clean Architecture cache adapter
          import { Browser__USE_CASE_NAME_PASCAL_CASE__Cache } from '../infra/cache/browser-__USE_CASE_NAME_KEBAB_CASE__-cache'

          const cache = new Browser__USE_CASE_NAME_PASCAL_CASE__Cache()
          const CACHE_TTL = 5 * 60 * 1000 // 5 minutes

          const getCachedData = async () => {
            return await cache.get('__USE_CASE_NAME_KEBAB_CASE__-data')
          }

          const setCachedData = async (data: any) => {
            await cache.set('__USE_CASE_NAME_KEBAB_CASE__-data', data, CACHE_TTL)
          }
          <<</REPLACE>>>



# --- From: shared/01-footer.part.regent ---
  # ============= BEGIN FOOTER SECTION =============


  # ------------------------------------------------------------------------------
  # AI-NOTE: IMMUTABLE DOCUMENTATION SECTIONS AHEAD.
  # Copy these sections verbatim. The [placeholders] inside the commands
  # are for HUMAN examples and MUST NOT be replaced by the AI.
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # TROUBLESHOOTING & RECOVERY
  # ------------------------------------------------------------------------------

  troubleshooting:
    lint_fails:
      - 'DO NOT commit - Fix all lint errors first'
      - 'Check for unused imports'
      - 'Verify proper TypeScript types'
      - 'Ensure no console.log statements'
      - 'Run yarn lint --fix to auto-fix when possible'

    tests_fail:
      - 'DO NOT commit - All tests must pass'
      - 'Check if mocks match the actual interfaces'
      - 'Verify Input/Output types are correct'
      - 'Ensure test coverage meets requirements'
      - 'Run specific test: yarn test [test-file-path]'

    typescript_fails:
      - 'Check all type definitions match'
      - 'Ensure no missing imports'
      - 'Verify interface implementations are complete'
      - 'Run yarn tsc --noEmit to check types'

  # Refactoring checklist
  refactoring:
    before_refactoring: |
      # Check current status and differences
      echo "📊 Checking current changes..."
      git status
      git diff

      # Ensure clean working directory
      echo "✅ Saving current work..."
      git stash save "WIP: before refactoring"

      # Create refactoring branch
      echo "🌿 Creating refactor branch..."
      git checkout -b refactor/[feature-name]

      # Run tests to ensure starting point is stable
      echo "🧪 Validating current state..."
      yarn test --run
      if [ $? -ne 0 ]; then
        echo "❌ Tests failing before refactor - fix first!"
        exit 1
      fi
      echo "✅ Ready to refactor"

    during_refactoring: |
      # After each change, check what was modified
      echo "🔍 Reviewing changes..."
      git diff --stat
      git diff

      # Validate the change
      yarn lint && yarn test --run

      # Commit atomically
      git add -p  # Interactive staging
      git commit -m "refactor([feature-name]): [specific change description]"

      # Show what was changed
      git show --stat

    common_scenarios:
      - name: 'Splitting a use case'
        wrong_example: |
          interface CreateUserAndSendEmail {
            execute: (input: CreateUserAndSendEmailInput) => Promise<CreateUserAndSendEmailOutput>
          }
        correct_example: |
          interface CreateUser{
            execute: (input: CreateUserInput) => Promise<CreateUserOutput>
          }
          interface SendWelcomeEmail {
            execute: (input: SendWelcomeEmailInput) => Promise<SendWelcomeEmailOutput>
          }

      - name: 'Renaming domain errors'
        wrong_example: |
          export class ErrorUserExists extends Error {
            constructor() {
              super('Error: user exists')
              this.name = 'ErrorUserExists'
            }
          }
        correct_example: |
          export class UserAlreadyExistsError extends Error {
            constructor() {
              super('User with this email already exists')
              this.name = 'UserAlreadyExistsError'
            }
          }

  # ------------------------------------------------------------------------------
  # LEARNING & IMPROVEMENT PATTERNS
  # The system tracks these patterns to improve over time
  # ------------------------------------------------------------------------------
  learning_patterns:
    common_errors:
      # Domain Layer Violations
      - pattern: 'import axios|fetch|prisma|redis'
        fix: 'Remove external library imports from domain layer'
        layer: 'domain'
        score_impact: -2

      - pattern: 'CreateUserAndSend|GetDataAndFormat'
        fix: 'Split into two separate use cases (SRP violation)'
        layer: 'domain'
        score_impact: -1

      - pattern: 'missing @domainConcept'
        fix: 'Add domain concept documentation for +2 score'
        layer: 'domain'
        score_impact: +1

      # Data Layer Violations
      - pattern: 'direct database access in data layer'
        fix: 'Use repository protocols instead of direct database access'
        layer: 'data'
        score_impact: -2

      - pattern: 'business logic in data layer'
        fix: 'Move business logic to domain layer'
        layer: 'data'
        score_impact: -1

      # Infrastructure Layer Violations
      - pattern: 'business logic in infrastructure'
        fix: 'Infrastructure should only contain adapters and implementations'
        layer: 'infra'
        score_impact: -2

      - pattern: 'missing error handling in adapters'
        fix: 'Add proper error handling and recovery in infrastructure adapters'
        layer: 'infra'
        score_impact: -1

      # Presentation Layer Violations
      - pattern: 'business logic in controllers|components'
        fix: 'Move business logic to use cases in domain layer'
        layer: 'presentation'
        score_impact: -2

      - pattern: 'direct database access from presentation'
        fix: 'Use use cases and factories from main layer'
        layer: 'presentation'
        score_impact: -2

      # Main Layer Violations
      - pattern: 'business logic in factories'
        fix: 'Main layer should only compose, not implement business logic'
        layer: 'main'
        score_impact: -2

      - pattern: 'missing dependency injection'
        fix: 'Use factories and dependency injection for all dependencies'
        layer: 'main'
        score_impact: -1

    success_indicators:
      - 'Uses ubiquitous language consistently across all layers'
      - 'Follows single responsibility principle in every component'
      - 'No dependency violations between layers'
      - 'Comprehensive test coverage (Domain: 100%, Data: 95%, Infra: 80%, Presentation: 90%)'
      - 'Clean git history with atomic commits'
      - 'Proper error handling at each layer boundary'
      - 'Clear separation of concerns between layers'
      - 'Type safety maintained throughout the stack'

  # AI Guidelines for All Layers
  ai_guidelines:
    general:
      - 'Always validate before committing: Run lint first, Run tests second, Only commit if both pass'
      - 'If generation fails: Identify the specific error, Fix only that error, Re-run validation, Do NOT proceed until fixed'
      - 'MUST generate different case styles from the input names (e.g., "Add Item To Cart" becomes: PascalCase=AddItemToCart, kebab-case=add-item-to-cart, lower case=add item to cart).'
      - 'MUST replace ALL placeholder variables (like __FEATURE_NAME_KEBAB_CASE__) with actual values'
      - 'MUST NOT leave any placeholder variables in the final implementation'
      - 'MUST NOT replace any [placeholders] found inside documentation sections like refactoring or recovery'
      - 'MUST use vitest for backend, @testing-library/react for frontend'
      - 'When in doubt: Choose simplicity over complexity, Split rather than combine, Ask for clarification rather than assume'

    layer_specific:
      domain:
        - 'Follow the principle: One use case = One file = One responsibility'
        - 'If tempted to add "And" in a use case name, split it'
        - 'MUST follow all domain rules - no business logic implementation, only contracts'
        - 'No external dependencies allowed in domain layer'
        - 'Use value objects for domain concepts'
        - 'Define clear domain errors with meaningful messages'

      data:
        - 'Implement use cases defined in domain layer'
        - 'Use repository protocols for data access'
        - 'Transform external data to domain models'
        - 'Handle data-specific errors and map to domain errors'
        - 'No direct database or API calls'

      infrastructure:
        - 'Implement repository interfaces defined in data layer'
        - 'Handle external service integrations (database, cache, APIs)'
        - 'Provide concrete implementations of protocols'
        - 'Include proper error handling and retry logic'
        - 'Use appropriate design patterns (Adapter, Facade)'

      presentation:
        - 'Controllers/Components should be thin - delegate to use cases'
        - 'Handle input validation and transformation'
        - 'Format responses for clients'
        - 'Implement proper error responses'
        - 'For frontend: Use hooks for business logic extraction'
        - 'For backend: Use middleware for cross-cutting concerns'

      main:
        - 'Composition root only - no business logic'
        - 'Wire up all dependencies using factories'
        - 'Configure dependency injection'
        - 'Setup application bootstrap and configuration'
        - 'For Next.js: Configure providers and middleware'
        - 'For Express/Fastify: Setup server and routes'

  # ------------------------------------------------------------------------------
  # AI-NOTE: TASK EVALUATION SECTION.
  # After the entire execution is complete, this section will be populated by a
  # human reviewer or an evaluation script.
  # ------------------------------------------------------------------------------

  evaluation:
    # AI-NOTE: This final_status will be 'SUCCESS' if all steps passed, or 'FAILED' if any step failed.
    final_status: 'PENDING' # PENDING | SUCCESS | FAILED
    # AI-NOTE: The final_rlhf_score is calculated automatically based on execution quality
    # -2: Catastrophic errors (architecture violations, wrong REPLACE/WITH format)
    # -1: Runtime errors (lint, tests, git failures)
    #  0: Low confidence (system uncertain, prevents hallucinations)
    # +1: Good execution but missing DDD elements
    # +2: Perfect with Clean Architecture, DDD, ubiquitous language
    final_rlhf_score: null # -2, -1, 0, 1, 2
    # AI-NOTE: The system automatically analyzes patterns and learns from each execution
    # This text is enhanced by automated RLHF analysis for continuous improvement
    reviewer_summary: |
      - What went well:
        - ...
      - Areas for improvement:
        - ...
    # AI-NOTE: This section lists actionable suggestions for improving the master templates or prompts.
    # This is the key to the continuous learning loop.
    template_improvement_suggestions:
      - target_template: '[layer].template.yaml'
        target_step_id: '[step-id]'
        suggestion: '[specific improvement suggestion based on execution results]'
        priority: 'medium'
        
  # ============= END FOOTER SECTION =============

  # End of TEMPLATE.yaml
