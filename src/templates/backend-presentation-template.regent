# =============================================
# GENERATED FILE - DO NOT EDIT DIRECTLY
# Target: backend
# Layer: presentation
# Built from parts in /Users/thiagobutignon/dev/spec-kit-clean-archicteture/src/templates/parts
# Generated at: 2025-10-01 14:09:16
# To modify, edit the part files and rebuild
# =============================================


# --- From: shared/00-header.part.regent ---

# AI-NOTE: This YAML file is the single source of truth for generating clean architecture layers.
# This is the MASTER TEMPLATE that will evolve to support all architectural layers.
#
# INTELLIGENT RLHF SCORING SYSTEM:
# The system uses Reinforcement Learning from Human Feedback to score execution quality:
# -2: CATASTROPHIC - Architecture violations, incorrect REPLACE/WITH format in refactor steps
# -1: RUNTIME ERROR - Lint failures, test failures, git operation problems
#  0: LOW CONFIDENCE - System is uncertain, avoids hallucinations
# +1: GOOD - Task complete but missing architectural elements
# +2: PERFECT - Exceptional quality with Clean Architecture, DDD principles, ubiquitous language
#
# QUALITY INDICATORS FOR +2 SCORE:
# - Uses ubiquitous language terminology
# - Follows Domain-Driven Design principles
# - Applies Clean Architecture concepts
# - Implements patterns: Aggregate Root, Value Objects, Domain Events
# - Perfect branch naming convention
# - Comprehensive PR descriptions
#
version: '3.0.0'
# AI-NOTE: Update these fields to describe the specific feature and layers.
metadata:
  title: '__FEATURE_NAME_PASCAL_CASE__ Clean Architecture Implementation'
  description: 'Clean Architecture template for __FEATURE_NAME_LOWER_CASE__ feature following master template rules.'
  source: 'TEMPLATE.yaml'
  # AI-NOTE: This should be replaced with the current date, e.g., YYYY-MM-DD.
  lastUpdated: '__CURRENT_DATE__'
  # AI-NOTE: Specify which layers are being implemented
  layers:
    - 'domain'
    # Future layers will be added here:
    # - 'data'
    # - 'infra'
    # - 'presentation'
    # - 'validation'
    # - 'main'
  # AI-NOTE: Define ubiquitous language for +2 RLHF score
  ubiquitousLanguage:
    - term: '__ENTITY_NAME__'
      definition: '__ENTITY_DEFINITION_IN_BUSINESS_CONTEXT__'
    - term: '__VALUE_OBJECT_NAME__'
      definition: '__VALUE_OBJECT_BUSINESS_MEANING__'
    - term: '__DOMAIN_EVENT__'
      definition: '__EVENT_BUSINESS_SIGNIFICANCE__'



# --- From: backend/01-structure.part.regent ---
  # AI-NOTE: Hybrid Architecture - "Feature Module with Use Case Slices"
  # Features are modules containing atomic use case slices for domain cohesion and generation safety

  structure:
    # Main application structure (entry point)
    app:
      basePath: '__PROJECT_NAME__/src'
      folders:
        - 'main'           # Application bootstrap and configuration
        - 'shared'         # Truly generic, app-wide shared code
        - 'features'       # Feature modules

    # Feature Module: Container for a business domain (e.g., user, product)
    # __FEATURE_NAME_KEBAB_CASE__ = user, product, etc.
    feature_module:
      basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__'

      # 1. Use Case Slices: Each folder is self-contained, atomic use case
      # __USE_CASE_NAME_KEBAB_CASE__ = create-user, delete-user, etc.
      use_case_slice:
        basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__'
        layers:
          domain:
            folders:
              - 'usecases'      # Interface for this specific use case
              - 'errors'        # Use case specific domain errors
            # Unit tests: create-user.ts + create-user.spec.ts (side by side)
          data:
            folders:
              - 'usecases'      # Implementation for this specific use case
            # Unit tests: db-create-user.ts + db-create-user.spec.ts (side by side)
          presentation:
            folders:
              - 'controllers'   # Controller for this specific use case
              - 'errors'        # HTTP errors specific to this use case
            # Unit tests: create-user-controller.ts + create-user-controller.spec.ts
          validation:
            folders:
              - 'validators'    # Validator for this specific use case
              - 'schemas'       # Schema for this specific use case
            # Unit tests: create-user-validator.spec.ts + create-user-schema.spec.ts
          main:
            folders:
              - 'factories'     # Factory for this specific use case
            # Unit tests: create-user-controller-factory.spec.ts
          # Integration and E2E tests only (not unit tests)
          __tests__:
            folders:
              - 'integration'   # Tests that cross layers
              - 'e2e'          # End-to-end tests

      # 2. Feature-Specific Shared: Code shared ONLY within this feature
      feature_shared:
        basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared'
        layers:
          domain:
            folders:
              - 'models'        # e.g., user-model.ts (shared by all user use cases)
              - 'repositories'  # e.g., user-repository.ts (interface)
              - 'errors'        # e.g., user-not-found-error.ts
              - 'value-objects' # e.g., email-value-object.ts
          infra:
            folders:
              - 'db'            # e.g., user-prisma-repository.ts (implementation)
          presentation:
            folders:
              - 'protocols'     # e.g., user-http-protocols.ts
              - 'errors'        # e.g., user-http-errors.ts

      # 3. Feature Main/Integration: Connects all slices to main application
      feature_main:
        basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/main'
        folders:
          - 'routes'        # e.g., user-routes.ts (aggregates all use case routes)
          - 'config'        # Feature-level configuration
          - 'docs'          # Feature documentation

  # Integration between features and main application
  integration:
    main_server:
      basePath: '__PROJECT_NAME__/src/main'
      folders:
        - 'config'          # Server configuration (express, fastify, etc)
        - 'routes'          # Route aggregation from all features
        - 'middlewares'     # Global middlewares
        - 'adapters'        # Framework adapters
        - 'docs'            # API documentation (Swagger, etc)
      files:
        - 'server.ts'       # Main server file
        - 'app.ts'          # Application setup

    shared:
      basePath: '__PROJECT_NAME__/src/shared'
      layers:
        domain:
          folders:
            - 'errors'          # Base error classes
            - 'protocols'       # Domain contracts/interfaces
            - 'types'           # Shared domain types
            - 'value-objects'   # Shared value objects

        data:
          folders:
            - 'protocols'       # Data layer protocols
            - 'helpers'         # Data transformation helpers

        infra:
          folders:
            - 'cryptography'    # Shared encryption/hashing adapters (bcrypt, jwt)
            - 'http'            # Shared HTTP clients and adapters
            - 'validators'      # Shared validators (email, cpf, etc)
            - 'cache'           # Shared cache implementations (Redis, memory)
            - 'telemetry'       # Shared logging and monitoring
            - 'messaging'       # Shared message queue adapters

        presentation:
          folders:
            - 'protocols'       # Presentation protocols
            - 'helpers'         # Presentation helpers
            - 'middlewares'     # Shared middlewares

        main:
          folders:
            - 'adapters'        # Shared adapters
            - 'decorators'      # Shared decorators
            - 'factories'       # Shared factories

    # Example of Hybrid Architecture workflow
    use_case_example:
      # Task: "Generate create-user use case for user feature"
      # __FEATURE_NAME_KEBAB_CASE__ = user
      # __USE_CASE_NAME_KEBAB_CASE__ = create-user

      # STEP 1: Create Feature directories (if not exist)
      create_feature_structure:
        - 'src/features/user/'
        - 'src/features/user/shared/'     # Feature-specific shared code
        - 'src/features/user/main/'       # Feature integration

      # STEP 2: Create Use Case Slice directory (isolated)
      create_slice_directory:
        - 'src/features/user/create-user/' # Self-contained use case

      # STEP 3: Create NEW files (totally isolated within slice) WITH TESTS
      create_slice_files:
        # Domain layer with unit tests
        - 'src/features/user/create-user/domain/usecases/create-user.ts'
        - 'src/features/user/create-user/domain/usecases/create-user.spec.ts'
        - 'src/features/user/create-user/domain/errors/create-user-errors.ts'

        # Data layer with unit tests
        - 'src/features/user/create-user/data/usecases/db-create-user.ts'
        - 'src/features/user/create-user/data/usecases/db-create-user.spec.ts'

        # Presentation layer with unit tests
        - 'src/features/user/create-user/presentation/controllers/create-user-controller.ts'
        - 'src/features/user/create-user/presentation/controllers/create-user-controller.spec.ts'
        - 'src/features/user/create-user/presentation/errors/create-user-http-errors.ts'

        # Validation layer with unit tests
        - 'src/features/user/create-user/validation/validators/create-user-validator.ts'
        - 'src/features/user/create-user/validation/validators/create-user-validator.spec.ts'
        - 'src/features/user/create-user/validation/schemas/create-user-schema.ts'
        - 'src/features/user/create-user/validation/schemas/create-user-schema.spec.ts'

        # Main layer with unit tests
        - 'src/features/user/create-user/main/factories/create-user-controller-factory.ts'
        - 'src/features/user/create-user/main/factories/create-user-controller-factory.spec.ts'

        # Integration tests (cross-layer)
        - 'src/features/user/create-user/__tests__/integration/create-user.integration.spec.ts'

      # STEP 4: Check/Modify FEATURE-SPECIFIC shared code
      feature_shared_files:
        - create_if_not_exists: 'src/features/user/shared/domain/models/user-model.ts'
        - create_if_not_exists: 'src/features/user/shared/domain/repositories/user-repository.ts'
        - modify: 'src/features/user/shared/domain/repositories/user-repository.ts'
          action: 'Add add() method to interface'
        - create_if_not_exists: 'src/features/user/shared/infra/db/user-prisma-repository.ts'
        - modify: 'src/features/user/shared/infra/db/user-prisma-repository.ts'
          action: 'Implement add() method'

      # STEP 5: Integrate route
      integrate_route:
        - create_if_not_exists: 'src/features/user/main/routes/user-routes.ts'
        - modify: 'src/features/user/main/routes/user-routes.ts'
          action: 'Add POST /users route importing from ../create-user/main/factories'

      # RESULT: Perfect isolation
      # - Use case slice is completely isolated in its own directory
      # - Feature-specific shared code stays within the feature
      # - Global shared remains unpolluted
      # - Zero risk of affecting other use cases (delete-user, update-user)

    example_integration:
      # How features connect to the main application
      feature_route: 'src/features/user/main/routes/user-routes.ts'
      imports_to: 'src/main/routes/index.ts'

      use_case_factory: 'src/features/user/create-user/main/factories/create-user-controller-factory.ts'
      used_in: 'src/features/user/main/routes/user-routes.ts'

      feature_shared_model: 'src/features/user/shared/domain/models/user-model.ts'
      used_by_slices: 'src/features/user/*/domain/usecases/*.ts'

      global_shared_protocol: 'src/shared/protocols/http.ts'
      used_by_features: 'src/features/*/shared/presentation/protocols'



# --- From: backend/02-architecture.part.regent ---

  # ------------------------------------------------------------------------------
  # ARCHITECTURAL RULES SECTION
  # These rules define the Clean Architecture boundaries and dependencies
  # AI-NOTE: These rules are CRITICAL - any violation should trigger RLHF score: -2
  # AI-NOTE: Use these rules to validate generated code and refactoring decisions
  # ------------------------------------------------------------------------------

  architecture:
    folder_structure:
      use_case_slice: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__'
      feature_shared: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared'
      feature_main: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/main'
      global_shared: '__PROJECT_NAME__/src/shared'
      main_server: '__PROJECT_NAME__/src/main'

    execution_order:
      # AI-NOTE: Vertical slicing ensures atomic feature delivery
      # Each use case should be independently deployable and testable
      # Complete one use case through ALL layers before starting another
      description: 'Use cases are implemented vertically, crossing all layers atomically'
      approach: 'Vertical Slice Architecture - One use case at a time, through all layers'
      sequence_per_use_case:
        1: 'domain'     # Use case interface and models
        2: 'data'       # Use case implementation
        3: 'infra'      # Repository implementation (only if new repository needed in feature/shared)
        4: 'validation' # Input validation for the use case
        5: 'presentation' # Controller for the use case
        6: 'main'       # Factory and route integration
        7: 'integration' # Connect to feature main routes

      workflow_diagram: |
        ```mermaid
        graph TD
          Start([Start Use Case Implementation])

          %% Branch Creation
          B1[Create Branch: feat/__FEATURE_NAME__/__USE_CASE_NAME__]

          %% Use Case Slice - Vertical Development
          UC1[Create Use Case Directory Structure]

          %% Domain Slice
          D1[Create Domain Interface]
          D2[Write Domain Tests - TDD Red]
          D3[Run: yarn test:unit - Expect Failure]
          D4[Git Commit: 'test(domain): add __USE_CASE__ tests']

          %% Data Slice
          DT1[Implement Data Use Case]
          DT2[Write Data Tests]
          DT3[Run: yarn test:unit - Green]
          DT4[Git Commit: 'feat(data): implement __USE_CASE__']

          %% Infra Slice (if needed)
          %% AI-NOTE: Repository creation is CONDITIONAL
          %% Only create if no existing repository handles this entity
          I1[Check if Repository Exists]
          I2{Need New Repository?}
          I3[Implement Repository in Feature Shared]
          I4[Write Repository Tests]
          I5[Run: yarn test:unit - Green]
          I6[Git Commit: 'feat(infra): add repository for __USE_CASE__']

          %% Validation Slice
          V1[Create Validation Schema]
          V2[Create Validators]
          V3[Write Validation Tests]
          V4[Run: yarn test:unit - Green]
          V5[Git Commit: 'feat(validation): add __USE_CASE__ validation']

          %% Presentation Slice
          P1[Create Controller]
          P2[Write Controller Tests]
          P3[Run: yarn test:unit - Green]
          P4[Git Commit: 'feat(presentation): add __USE_CASE__ controller']

          %% Main Slice
          M1[Create Controller Factory]
          M2[Write Factory Tests]
          M3[Run: yarn test:unit - Green]
          M4[Git Commit: 'feat(main): add __USE_CASE__ factory']

          %% Feature Integration
          FI1[Update Feature Routes]
          FI2[Add Route for Use Case]
          FI3[Update API Documentation]
          FI4[Git Commit: 'feat(routes): integrate __USE_CASE__ route']

          %% Integration Testing
          IT1[Write Integration Tests]
          IT2[Run: yarn test:integration]
          IT3[Write E2E Tests]
          IT4[Run: yarn test:e2e]
          IT5[Git Commit: 'test(integration): add __USE_CASE__ integration tests']

          %% Final Steps
          F1[Run All Tests]
          F2[Run: yarn lint]
          F3[Run: yarn build]
          F4[Git Push: Push Branch]
          F5[Create PR: '__FEATURE__/__USE_CASE__ Implementation']

          End([Use Case Complete])

          %% Flow - Vertical Development Through Layers
          Start --> B1
          B1 --> UC1

          %% Domain Flow
          UC1 --> D1 --> D2 --> D3 --> D4

          %% Data Flow
          D4 --> DT1 --> DT2 --> DT3 --> DT4

          %% Infra Flow (conditional)
          DT4 --> I1 --> I2
          I2 -->|Yes| I3 --> I4 --> I5 --> I6
          I2 -->|No| V1
          I6 --> V1

          %% Validation Flow
          V1 --> V2 --> V3 --> V4 --> V5

          %% Presentation Flow
          V5 --> P1 --> P2 --> P3 --> P4

          %% Main Flow
          P4 --> M1 --> M2 --> M3 --> M4

          %% Feature Integration Flow
          M4 --> FI1 --> FI2 --> FI3 --> FI4

          %% Testing Flow
          FI4 --> IT1 --> IT2 --> IT3 --> IT4 --> IT5

          %% Final Flow
          IT5 --> F1 --> F2 --> F3 --> F4 --> F5 --> End

          classDef branch fill:#FFF9C4,stroke:#F57C00,stroke-width:2px
          classDef domain fill:#E8F5E9,stroke:#4CAF50,stroke-width:2px
          classDef data fill:#E3F2FD,stroke:#2196F3,stroke-width:2px
          classDef infra fill:#FFF3E0,stroke:#FF9800,stroke-width:2px
          classDef validation fill:#F3E5F5,stroke:#9C27B0,stroke-width:2px
          classDef presentation fill:#FCE4EC,stroke:#E91E63,stroke-width:2px
          classDef main fill:#E0F2F1,stroke:#009688,stroke-width:2px
          classDef integration fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px
          classDef testing fill:#FFEBEE,stroke:#F44336,stroke-width:2px
          classDef final fill:#E8EAF6,stroke:#3F51B5,stroke-width:2px

          class B1,UC1 branch
          class D1,D2,D3,D4 domain
          class DT1,DT2,DT3,DT4 data
          class I1,I2,I3,I4,I5,I6 infra
          class V1,V2,V3,V4,V5 validation
          class P1,P2,P3,P4 presentation
          class M1,M2,M3,M4 main
          class FI1,FI2,FI3,FI4 integration
          class IT1,IT2,IT3,IT4,IT5 testing
          class F1,F2,F3,F4,F5 final
        ```

      git_workflow_per_use_case:
        description: 'Vertical slice development - one complete use case at a time'
        example_use_case: 'create-user in user feature'

        workflow_steps:
          - 'git checkout -b feat/__FEATURE_NAME__/__USE_CASE_NAME__'
          - 'Create use case slice directory: src/features/__FEATURE_NAME__/__USE_CASE_NAME__'

        domain_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/domain/usecases/__USE_CASE__.ts'
          - 'Write domain tests (TDD - RED) → yarn test:unit (expect failure)'
          - 'git add → git commit -m "test(domain): add failing tests for __USE_CASE__"'
          - 'Create domain interface → yarn test:unit → yarn lint'
          - 'git add → git commit -m "feat(domain): add __USE_CASE__ interface"'

        data_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/data/usecases/db-__USE_CASE__.ts'
          - 'Implement use case → yarn test:unit (GREEN) → yarn lint'
          - 'git add → git commit -m "feat(data): implement __USE_CASE__"'

        infra_slice_if_needed:
          - 'IMPORTANT: Infra layer is NOT in use case slice - it goes in feature/shared'
          - 'Check if repository exists in: src/features/__FEATURE_NAME__/shared/infra/db/'
          - 'Only create new repository if needed for this use case:'
          - '  Create: src/features/__FEATURE_NAME__/shared/infra/db/__ENTITY__-repository.ts'
          - '  Write repository tests → yarn test:unit → yarn lint'
          - '  git add → git commit -m "feat(infra): add __ENTITY__ repository for __FEATURE__"'
          - 'If repository already exists, skip this step entirely'

        validation_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/validation/validators/__USE_CASE__-validator.ts'
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/validation/schemas/__USE_CASE__-schema.ts'
          - 'Write validation tests → yarn test:unit → yarn lint'
          - 'git add → git commit -m "feat(validation): add __USE_CASE__ validation"'

        presentation_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/presentation/controllers/__USE_CASE__-controller.ts'
          - 'Write controller tests (TDD) → yarn test:unit → yarn lint'
          - 'git add → git commit -m "feat(presentation): add __USE_CASE__ controller"'

        main_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/main/factories/__USE_CASE__-controller-factory.ts'
          - 'Wire dependencies → yarn test:unit → yarn lint'
          - 'git add → git commit -m "feat(main): add __USE_CASE__ factory"'

        feature_integration:
          - 'Update: src/features/__FEATURE_NAME__/main/routes/__FEATURE__-routes.ts'
          - 'Add route for new use case → import factory from ../__USE_CASE_NAME__/main/factories'
          - 'Update API documentation if needed'
          - 'git add → git commit -m "feat(routes): integrate __USE_CASE__ route"'

        integration_testing:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/__tests__/integration/__USE_CASE__.integration.spec.ts'
          - 'Write integration tests → yarn test:integration'
          - 'Write E2E tests if needed → yarn test:e2e'
          - 'git add → git commit -m "test(integration): add __USE_CASE__ integration tests"'

        finalization:
          - 'Run full test suite → yarn test'
          - 'Run linting → yarn lint'
          - 'Run build → yarn build'
          - 'git push origin feat/__FEATURE_NAME__/__USE_CASE_NAME__'
          - 'gh pr create --base main --title "feat(__FEATURE__): implement __USE_CASE__ use case"'

        benefits:
          - 'Atomic delivery: Each PR delivers a complete, working feature'
          - 'Reduced integration risk: No big bang integration at the end'
          - 'Faster feedback: Working software delivered incrementally'
          - 'Better testing: Each slice can be tested in isolation and integrated'
          - 'Cleaner git history: Each commit represents a logical unit of work'  

    dependency_rules:
      # AI-NOTE: Dependency direction is INWARD toward domain
      # Any outward dependency is a CRITICAL violation
      # Use these rules to validate imports in generated code
      domain:
        can_import_from: []  # Domain layer is the core - imports nothing
        cannot_import_from: ['data', 'infra', 'presentation', 'validation', 'main']
        notes: 'Domain defines business rules and contracts - must remain framework agnostic'

      data:
        can_import_from: ['domain']  # Data layer implements domain interfaces
        cannot_import_from: ['infra', 'presentation', 'validation', 'main']
        notes: 'Data orchestrates use cases but delegates infrastructure concerns to infra layer'

      infra:
        can_import_from: ['data', 'domain']  # Infrastructure implements data protocols
        cannot_import_from: ['presentation', 'main']
        notes: 'Infrastructure provides concrete implementations for data layer protocols'

      presentation:
        can_import_from: ['domain', 'validation']  # Presentation uses domain models and validation
        cannot_import_from: ['data', 'infra', 'main']
        notes: 'Presentation handles HTTP concerns - uses domain models and validation rules'

      validation:
        can_import_from: []  # Validation layer is independent - no imports
        cannot_import_from: ['domain', 'data', 'infra', 'presentation', 'main']
        notes: 'Validation is pure - implements generic validation interfaces, not presentation-specific'

      main:
        can_import_from: ['data', 'domain', 'infra', 'presentation', 'validation']  # Main layer composes everything
        cannot_import_from: []  # Main is the composition root
        notes: 'Main is the composition root - wires all dependencies and creates factories'

    # Clean Architecture principles and practices
    principles:
      core_principles:
        - "Independence: Business rules don't know about outside world"
        - "Testability: Business rules can be tested without UI, Database, Web Server, etc."
        - "Flexibility: UI, Database, and any external agency are plugins"
        - "Separation: Business rules are the core, everything else is detail"
        - "Dependency Rule: Dependencies point inward toward the domain"

      design_patterns:
        domain:
          - "Interface Pattern: Define contracts for use cases"
          - "ES2015 Modules: Use import/export for code organization"
          - "Type Exports: Separate types for Input and Output"
          - "Single Method Pattern: One execute() method per use case"
          - "Port Pattern: Define boundaries for external communication"
          - "DTO Pattern: Simple data transfer objects without behavior"

        data:
          - "Implementation Pattern: Concrete implementations of domain use cases"
          - "Repository Pattern: Define protocols for data persistence"
          - "Protocol Pattern: Abstractions for external dependencies (HTTP, DB, Crypto)"
          - "Dependency Injection: Constructor injection of protocols"
          - "Prefix Pattern: Use 'Db' or 'Remote' prefix for implementations"

        infra:
          - "Adapter Pattern: Implement data protocols (FetchHttpClient, PrismaAdapter)"
          - "Single HTTP Client: One FetchClient for all HTTP operations"
          - "ORM Pattern: Prisma for PostgreSQL + pgvector support"
          - "Cache Pattern: Redis adapter for caching strategies"
          - "Helper Pattern: Database and cache helpers for connections"

        presentation:
          - "Controller Pattern: Express controllers for REST API"
          - "Middleware Pattern: Express middleware pipeline"
          - "Helper Pattern: HTTP response helpers (ok, badRequest, etc.)"
          - "Protocol Pattern: Define controller and validation interfaces"
          - "Error Handling: Centralized error middleware"
          - "Request Validation: Input sanitization and validation"

        validation:
          - "Composite Pattern: Combine multiple field validators (ValidationComposite)"
          - "Builder Pattern: Fluent interface for validation construction (ValidationBuilder)"
          - "Factory Pattern: Create validation composites (makeLoginValidation, makeSignupValidation)"

        main:
          - "Factory Pattern: Create controllers with all dependencies (makeLoginController)"
          - "Decorator Pattern: Add logging and monitoring (LogControllerDecorator)"
          - "Adapter Pattern: Express route and middleware adapters"
          - "Composition Root: Wire up controllers, middlewares, and routes"
          - "Configuration Pattern: Centralized app, env, and swagger config"
          - "Dependency Injection: IoC container for dependency management"
          - "Route Aggregation: Collect routes from all features"

      testing_strategy:
        # AI-NOTE: Testing strategy varies by layer
        # Domain: Pure unit tests with no external dependencies
        # Data: Unit tests with mocked protocols
        # Infra: Integration tests with real databases
        domain:
          approach: "Unit Tests - Pure functions and business logic"
          coverage_target: "100%"
          tools: ["Vitest", "Testing Library"]
          practices:
            # AI-NOTE: NEVER use faker or random data in tests
            # Always use deterministic, fixed test data
            - "Use fixed test data helpers instead of faker"
            - "Create mock factories with deterministic data"
            - "Test domain models and use case interfaces"
            - "Use mockAddAccountParams() with fixed values"
            - "Keep test helpers in tests/domain/mocks directory"
            - "No external dependencies or randomness in tests"

        data:
          approach: "Unit Tests with Mocks"
          coverage_target: "95%"
          tools: ["Vitest", "vi.spyOn", "vi.fn"]
          practices:
            - "Create spy classes (HasherSpy, RepositorySpy)"
            - "Use makeSut() factory for test setup"
            - "Mock protocol implementations with classes"
            - "Use vi.spyOn() for spying on methods"
            - "Test error cases with throwError helper"
            - "Verify method calls and parameters"
            - "Use fixed test data from mocks directory"

        infra:
          approach: "Integration Tests"
          coverage_target: "80%"
          tools: ["Vitest", "Prisma test database", "Module mocking"]
          practices:
            - "Use vi.mock() to mock external modules (bcrypt, jsonwebtoken)"
            - "Test with Prisma test client and PostgreSQL"
            - "Clean database between tests with Prisma reset"
            - "Use makeSut() factory pattern"
            - "Mock localStorage with jsdom or happy-dom"
            - "Use vi.mock() for Fetch API mocking"
            - "Use fixed test data - no faker"

        presentation:
          approach: "Unit Tests for Controllers and Middlewares"
          coverage_target: "90%"
          tools: ["Vitest", "HTTP helpers (ok, badRequest, serverError)"]
          practices:
            - "Use spy classes (AuthenticationSpy, ValidationSpy)"
            - "Test controller handle() method"
            - "Use makeSut() factory with dependency injection"
            - "Test HTTP response helpers (ok, badRequest, unauthorized)"
            - "Mock requests with fixed data"
            - "Test error scenarios with throwError helper"
            - "Test middleware chain execution"
            - "Verify proper error propagation"

        validation:
          approach: "Unit Tests - Validation logic"
          coverage_target: "100%"
          tools: ["Vitest", "ValidationSpy for mocking"]
          practices:
            - "Test each validator independently (RequiredField, Email, MinLength)"
            - "Test ValidationComposite with multiple validators"
            - "Use makeSut() factory for validator creation"
            - "Test specific error types (MissingParamError, InvalidFieldError)"
            - "Test validation factories return correct composites"
            - "Test edge cases (empty fields, invalid formats)"
            - "Use fixed field names and error messages"

        main:
          approach: "E2E and Integration Tests"
          coverage_target: "70%"
          tools: ["Vitest", "Playwright", "MSW"]
          practices:
            - "Test complete user flows with Playwright"
            - "Test factory functions with Vitest"
            - "Mock HTTP layer with MSW"
            - "Verify dependency wiring"
            - "Use fixed test data for E2E scenarios"
            - "No faker in integration tests"

      best_practices:
        - "SOLID Principles: Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion"
        - "DRY: Don't Repeat Yourself - Extract common logic"
        - "KISS: Keep It Simple, Silly - Avoid over-engineering"
        - "YAGNI: You Aren't Gonna Need It - Build only what's needed"
        - "SOC: Separation of Concerns - Each layer has its responsibility"
        - "Small Commits: Make atomic, focused commits"
        - "Composition over Inheritance: Favor object composition"
        - "Conventional Commits: Use semantic commit messages"
        - "TDD: Write tests first, then implementation"
        - "Clean Code: Self-documenting, readable code"


# --- From: backend/03-rules.part.regent ---

  # ------------------------------------------------------------------------------
  # AI-NOTE: IMMUTABLE SECTIONS AHEAD.
  # The sections from here until 'steps' are architectural rules.
  # You MUST copy them verbatim into the implementation file without ANY modification.
  #
  # AUTOMATED LEARNING SYSTEM:
  # The RLHF system automatically:
  # - Tracks success/failure patterns across executions
  # - Identifies common error types and their fixes
  # - Applies improvements when confidence > 80%
  # - Generates learning reports with actionable insights
  # - Prevents hallucinations with score 0 for uncertain cases
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # RULES SECTION
  # All architectural and pattern rules consolidated
  # ------------------------------------------------------------------------------

  rules:
    # Domain layer rules (modern approach)
    domain:
      allowed:
        - 'Type definitions and interfaces (Models)'
        - 'Use case interfaces with single execute() method'
        - 'Separate Input and Output types for each use case'
        - 'Simple data models without behavior'
        - 'JSDoc documentation for all public interfaces'
        - 'ES2015 module exports (export type, export interface)'

      forbidden:
        - 'Multiple methods in a single use case interface'
        - 'Combined operations (e.g., CreateUserAndSendEmail)'
        - 'Framework dependencies (Express, third-party libraries)'
        - 'External libraries (HTTP or database clients)'
        - 'Implementation details of any kind'
        - 'UI components or presentation logic'
        - 'HTTP/Database/File system operations'
        - 'Environment variables or configuration'
        - 'Console.log or any I/O operations'
        - 'Implementation of business logic (only interfaces allowed)'
        - 'Validation implementations'
        - 'Error throwing or handling'
        - 'Dependency injection'
        - 'Domain entities with methods/behavior (use simple data structures)'

      should:
        - 'Define business entities and value objects'
        - 'Contain only interfaces and types'
        - 'Be framework-agnostic'
        - 'Follow domain-driven design principles'

      should_not:
        - 'Import from other layers'
        - 'Contain implementation details'
        - 'Have framework dependencies'
      use_case:
        should:
          - 'Have only ONE execute() method per interface'
          - 'Define separate Input and Output types'
          - 'Have EXACTLY ONE responsibility (one business operation)'
          - 'Be named with single verb describing ONE action (__USE_CASE_NAME__, not __USE_CASE_NAME__And__OTHER_ACTION__)'
          - 'Include comprehensive JSDoc documentation'
          - 'Return Promise<Output> from execute method'
          - 'Be framework agnostic'
          - 'Follow naming convention: VerbNoun (e.g., __USE_CASE_EXAMPLE_1__, __USE_CASE_EXAMPLE_2__, __USE_CASE_EXAMPLE_3__)'
        should_not:
          - 'Have multiple methods (no __METHOD_1__() AND __METHOD_2__() in same interface)'
          - 'Combine multiple operations (__USE_CASE_NAME__And__OTHER_ACTION__ violates SRP)'
          - 'Contain implementation logic'
          - 'Know about HTTP, databases, or external services'
          - 'Import from data, presentation, or infrastructure layers'
          - 'Have side effects'
          - 'Use generic method names like handle(), process(), or run()'

    # Data layer rules
    data:
      should:
        - 'Implement domain use case interfaces'
        - 'Use constructor injection for dependencies'
        - 'Define protocols for external dependencies'
        - 'Use prefix naming (Db__USE_CASE_NAME__, Remote__USE_CASE_NAME__)'
        - 'Handle errors and status codes appropriately'
        - 'Keep business logic minimal (only orchestration)'
        - 'Return domain types, not infrastructure types'

      should_not:
        - 'Import from infrastructure layer directly'
        - 'Contain complex business logic (belongs in domain)'
        - 'Expose infrastructure details to domain'
        - 'Use concrete implementations instead of protocols'
        - 'Have direct database or HTTP calls (use protocols)'

    # Infrastructure layer rules
    infra:
      should:
        - 'Implement data layer protocols'
        - 'Use native Fetch API instead of axios'
        - 'Use Prisma ORM for database operations'
        - 'Support PostgreSQL with pgvector extension'
        - 'Use Redis for caching when needed'
        - 'Provide single FetchHttpClient for all HTTP needs'
        - 'Handle connection management and retries'
        - 'Use environment variables for configuration'

      should_not:
        - 'Import from domain or use case layers'
        - 'Contain business logic'
        - 'Use multiple HTTP client implementations'
        - 'Expose database-specific types to other layers'
        - 'Use axios or other HTTP libraries (use Fetch API)'
        - 'Use MongoDB (use Prisma with PostgreSQL)'

    # Presentation layer rules
    presentation:
      should:
        - 'Use Express for HTTP server and routing'
        - 'Implement Controller interface with handle method'
        - 'Return standardized HTTP responses (ok, badRequest, etc.)'
        - 'Use middlewares for cross-cutting concerns'
        - 'Handle errors gracefully with try/catch'
        - 'Validate requests before processing'
        - 'Use RESTful API design principles'
        - 'Implement proper HTTP status codes'

      should_not:
        - 'Use GraphQL (use REST with Express)'
        - 'Import from data or infra layers directly'
        - 'Contain business logic (belongs in use cases)'
        - 'Make direct HTTP calls (use data layer)'
        - 'Expose internal implementation details'
        - 'Implement middleware that does not follow the Express middleware signature (req, res, next)'

    # Error rules
    error:
      should:
        - 'Extend the native Error class'
        - 'Have descriptive names ending with Error'
        - 'Contain meaningful error messages'
        - 'Represent business rule violations'
        - 'Be thrown when domain invariants are violated'

      should_not:
        - 'Contain HTTP status codes'
        - 'Include technical/implementation details'
        - 'Expose sensitive information'
        - 'Import external dependencies'

    # Test helper rules
    test_helper:
      should:
        - 'Create mock/stub implementations of use cases'
        - 'Generate fake test data'
        - 'Be pure functions that return consistent data'
        - 'Help reduce test boilerplate'
        - 'Use ONLY Vitest (Jest is prohibited)'

      should_not:
        - 'Make real API calls or database queries'
        - 'Depend on external services'
        - 'Contain test assertions (those belong in test files)'
        - 'Have side effects or maintain state'
        - 'Use Jest (use Vitest instead)'

    # Validation rules
    validation:
      should:
        - 'Implement FieldValidation interface for field validators'
        - 'Use ValidationComposite to combine multiple validators'
        - 'Use ValidationBuilder for fluent validation construction'
        - 'Create factory functions for validation composites'
        - 'Validate individual fields with specific rules'
        - 'Return descriptive error messages'
        - 'Support chaining of validation rules'
        - 'Use static build() method for composite creation'
      should_not:
        - 'Import from domain layer'
        - 'Import from data or infra layers'
        - 'Contain business logic (only validation rules)'
        - 'Throw exceptions (return Error objects instead)'
        - 'Access external services or databases'
        - 'Use async validation (keep validators synchronous)'

    # Main layer rules
    main:
      should:
        - 'Create factory functions for controllers'
        - 'Wire up all dependencies using composition'
        - 'Apply decorators for cross-cutting concerns (logging, monitoring)'
        - 'Configure Express routes and middlewares'
        - 'Setup Swagger documentation'
        - 'Handle environment configuration'
        - 'Use adapters for framework integration'
        - 'Return decorated controllers from factories'
        - 'Setup dependency injection container'
        - 'Configure database connections and migrations'
        - 'Initialize monitoring and health checks'

      should_not:
        - 'Contain business logic (only wiring)'
        - 'Have direct database or API calls'
        - 'Include complex algorithms or calculations'
        - 'Store application state'
        - 'Define new interfaces or types (only use existing ones)'
        - 'Handle request/response logic (belongs in presentation)'

    # Reference patterns
    reference_patterns:
      clean_architecture:
        type: 'external_pattern'
        source: 'context7'
        query: 'clean architecture use case'
        url: 'https://github.com/...'
        description: 'Following Clean Architecture pattern.'

      ddd_pattern:
        type: 'external_pattern'
        source: 'context7'
        query: 'domain driven design'
        url: 'https://github.com/...'
        description: 'Following DDD patterns.'

      tdd_pattern:
        type: 'external_pattern'
        source: 'context7'
        query: 'test driven development'
        url: 'https://github.com/...'
        description: 'Following TDD patterns.'

    # Learning patterns
    learning_patterns:
      common_errors:
        - pattern: 'import axios'
          fix: 'Use Fetch API instead of axios in infra layer'
          score_impact: -2

        - pattern: '__USE_CASE_NAME__And__OTHER_ACTION__'
          fix: 'Split into two separate use cases (SRP violation)'
          score_impact: -1

        - pattern: 'missing @domainConcept'
          fix: 'Add domain concept documentation for +2 score'
          score_impact: +1

      success_indicators:
        - 'Uses ubiquitous language consistently'
        - 'Follows single responsibility principle'
        - 'No dependency violations'
        - 'Comprehensive test coverage'
        - 'Clean git history with atomic commits'

    # Required protocols for all layers
    required_protocols:
      # Domain Layer
      domain:
        - 'All use cases must have single execute() method'
        - 'All use cases must define separate Input and Output types'
        - 'All domain types must be immutable'
        - 'No use case can perform multiple operations (SRP)'
        - 'All models must be simple DTOs without behavior'

      # Data Layer
      data:
        - 'All implementations must inject dependencies via constructor'
        - 'All protocols must be interfaces, not concrete classes'
        - 'All implementations must use Db or Remote prefix'
        - 'Must return domain types, not infrastructure types'
        - 'Must handle errors and map status codes appropriately'

      # Infrastructure Layer
      infra:
        - 'All adapters must implement data layer protocols'
        - 'HTTP clients must use Fetch API, not axios'
        - 'Database repositories must use Prisma with PostgreSQL'
        - 'All external configs must come from environment variables'
        - 'Must not expose infrastructure types to other layers'

      # Presentation Layer
      presentation:
        - 'Controllers must implement handle() method'
        - 'Controllers must return HTTP helpers (ok, badRequest, etc.)'
        - 'Middlewares must implement handle() with next parameter'
        - 'Request handlers must validate input before processing'
        - 'Response handlers must use standard HTTP status codes'

      # Validation Layer
      validation:
        - 'All validators must implement FieldValidation interface'
        - 'Validators must return Error or undefined'
        - 'ValidationComposite must use static build() method'
        - 'Validation must be synchronous (no async/await)'
        - 'Factory functions must return ValidationComposite (make__USE_CASE_NAME__Validation)'

      # Main Layer
      main:
        - 'All factories must return configured instances'
        - 'Factory functions must wire all dependencies'
        - 'No business logic allowed (only composition)'
        - 'Routes must use adapter pattern for framework integration'
        - 'Must not define new types (use existing from other layers)'

      # Cross-cutting Concerns
      general:
        - 'All public interfaces must have JSDoc documentation'
        - 'All errors must extend native Error class'
        - 'All test helpers must be pure functions'
        - 'All tests must use Vitest, not Jest'
        - 'No use of faker - fixed test data only'

    # Documentation standards (JSDoc)
    documentation:
      # Domain Layer Documentation
      domain:
        use_case_interface:
          - '@description - Clear description of the use case purpose'
          - '@example - Usage example with execute() method'
          - '@see - Reference to related use cases or documentation'
        input_output_types:
          - '@typedef - Define Input and Output types'
          - '@property - Document each field with type and constraints'
          - '@example - Show valid input/output instances'
        model_type:
          - '@typedef - Define the domain model'
          - '@property - Document each property with business rules'
          - '@example - Show valid model instance'

      # Data Layer Documentation
      data:
        protocol_interface:
          - '@interface - Define protocol contracts'
          - '@method - Document each method signature'
          - '@throws - Document possible errors'
        implementation_class:
          - '@class - Describe the use case implementation'
          - '@implements - List implemented interfaces'
          - '@constructor - Document dependency injection'
          - '@method - Document orchestration logic'

      # Infrastructure Layer Documentation
      infra:
        adapter_class:
          - '@class - Describe the adapter purpose'
          - '@implements - Protocol being implemented'
          - '@dependency - External libraries used'
        database_repository:
          - '@class - Repository implementation'
          - '@method - Document CRUD operations'
          - '@throws - Database-specific errors'
        http_client:
          - '@class - HTTP client implementation'
          - '@method - Document request/response handling'
          - '@throws - Network-related errors'

      # Presentation Layer Documentation
      presentation:
        controller:
          - '@class - Controller description'
          - '@route - HTTP route and method'
          - '@param - Request parameters'
          - '@returns - HTTP response format'
          - '@throws - HTTP error responses'
        middleware:
          - '@function - Middleware purpose'
          - '@param - Request, Response, Next'
          - '@throws - Authorization/validation errors'
        route_handler:
          - '@function - Route handler description'
          - '@param - Request and response objects'
          - '@returns - HTTP response with status and data'
          - '@throws - HTTP error responses'

      # Validation Layer Documentation
      validation:
        validator_class:
          - '@class - Validator description'
          - '@implements - FieldValidation interface'
          - '@method - validate() method logic'
          - '@returns - Error or undefined'
        composite:
          - '@class - ValidationComposite'
          - '@method - Combines multiple validators'
          - '@returns - First error found or undefined'

      # Main Layer Documentation
      main:
        factory:
          - '@function - Factory function description'
          - '@returns - Configured instance with dependencies'
          - '@example - How to use the factory'
        route:
          - '@function - Route configuration'
          - '@param - Express router instance'
          - '@middleware - Applied middlewares'
        composition:
          - '@function - Dependency composition'
          - '@returns - Fully configured instance with dependencies injected'

      example_template: |
        /**
        * @description __USE_CASE_DESCRIPTION__
        * @example
        * const __USE_CASE_NAME_CAMEL_CASE__ = new __USE_CASE_NAME_PASCAL_CASE__Impl(__DEPENDENCY_NAME__)
        * const result = await __USE_CASE_NAME_CAMEL_CASE__.execute({
        *   __INPUT_FIELD_1__: '__EXAMPLE_VALUE_1__',
        *   __INPUT_FIELD_2__: '__EXAMPLE_VALUE_2__',
        *   __INPUT_FIELD_3__: '__EXAMPLE_VALUE_3__'
        * })
        * @see {@link __RELATED_USE_CASE__} for __RELATED_DESCRIPTION__
        */
        export interface __USE_CASE_NAME_PASCAL_CASE__ {
          execute(input: __USE_CASE_NAME_PASCAL_CASE__Input): Promise<__USE_CASE_NAME_PASCAL_CASE__Output>
        }

        /**
        * @typedef {Object} __USE_CASE_NAME_PASCAL_CASE__Input
        * @property {string} __INPUT_FIELD_1__ - __FIELD_1_DESCRIPTION__ (__FIELD_1_CONSTRAINTS__)
        * @property {string} __INPUT_FIELD_2__ - __FIELD_2_DESCRIPTION__
        * @property {string} __INPUT_FIELD_3__ - __FIELD_3_DESCRIPTION__ (__FIELD_3_CONSTRAINTS__)
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Input = {
          __INPUT_FIELD_1__: string
          __INPUT_FIELD_2__: string
          __INPUT_FIELD_3__: string
        }

        /**
        * @typedef {Object} __USE_CASE_NAME_PASCAL_CASE__Output
        * @property {string} __OUTPUT_FIELD_1__ - __OUTPUT_FIELD_1_DESCRIPTION__
        * @property {string} __OUTPUT_FIELD_2__ - __OUTPUT_FIELD_2_DESCRIPTION__
        * @property {string} __OUTPUT_FIELD_3__ - __OUTPUT_FIELD_3_DESCRIPTION__
        * @property {Date} __TIMESTAMP_FIELD__ - __TIMESTAMP_DESCRIPTION__
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Output = {
          __OUTPUT_FIELD_1__: string
          __OUTPUT_FIELD_2__: string
          __OUTPUT_FIELD_3__: string
          __TIMESTAMP_FIELD__: Date
        }



# --- From: backend/steps/04-presentation.part.regent ---

  # ------------------------------------------------------------------------------
  # AI-NOTE: PRESENTATION LAYER IMPLEMENTATION STEPS FOR BACKEND
  # These steps create controllers, middlewares, and HTTP protocols
  # following Clean Architecture and Vertical Slice patterns for Node.js/Express
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # PRESENTATION LAYER STEPS SECTION
  # Steps for generating presentation layer artifacts in backend features
  # Following "Feature Module with Use Case Slices" architecture
  # ------------------------------------------------------------------------------

  presentation_steps:
    # === STEP 1: CREATE FEATURE BRANCH ===
    - id: 'create-feature-branch-presentation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create and checkout feature branch for __USE_CASE_NAME_PASCAL_CASE__ presentation implementation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'GIT_WORKFLOW.md'
          description: 'Git branching strategy and naming conventions'
      run_scripts:
        description: 'Create feature branch with proper naming convention'
        scripts:
          - name: 'Create feature branch'
            command: |
              # Stash any uncommitted changes
              git stash save "WIP: Before creating __FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__ presentation branch"

              # Ensure we're on the main branch and up to date
              git checkout main || git checkout master
              git pull origin main || git pull origin master

              # Create and checkout new feature branch
              BRANCH_NAME="feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__-presentation"
              git checkout -b "$BRANCH_NAME" || {
                echo "❌ Failed to create branch: $BRANCH_NAME"
                exit 1
              }

              echo "✅ Created and checked out branch: $BRANCH_NAME"
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 2: CREATE TEST STRUCTURE (TDD - RED PHASE) ===
    - id: 'create-test-structure-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'folder'
      description: 'TDD RED: Create test structure for __USE_CASE_NAME_PASCAL_CASE__ presentation layer'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'TDD_GUIDE.md'
          description: 'Following Test-Driven Development: RED-GREEN-REFACTOR cycle.'
      action:
        create_folders:
          basePath: '__PROJECT_NAME__/tests/presentation'
          folders:
            - 'controllers'   # Controller tests
            - 'mocks'         # Test mocks and spies
            - 'middlewares'   # Middleware tests

    # === STEP 3: CREATE TEST MOCKS (TDD - RED PHASE) ===
    - id: 'create-test-mocks-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'TDD RED: Create test mocks and spies for __USE_CASE_NAME_PASCAL_CASE__'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'TDD_GUIDE.md'
          description: 'Test doubles and mocking patterns'
      path: '__PROJECT_NAME__/tests/presentation/mocks/mock-__USE_CASE_NAME_KEBAB_CASE__.ts'
      template: |
        import { __USE_CASE_NAME_PASCAL_CASE__ } from '@/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain/usecases/__USE_CASE_NAME_KEBAB_CASE__'
        import { Validation } from '@/presentation/protocols'

        /**
         * Test doubles for __USE_CASE_NAME_PASCAL_CASE__ controller testing
         * AI-NOTE: TDD - Create mocks BEFORE implementation
         * These mocks define the expected behavior
         */

        export class __USE_CASE_NAME_PASCAL_CASE__Spy implements __USE_CASE_NAME_PASCAL_CASE__ {
          params: any
          result = {
            __OUTPUT_FIELD_1__: 'test-output-1',
            __OUTPUT_FIELD_2__: 'test-output-2',
            __OUTPUT_FIELD_3__: 'test-output-3',
            __TIMESTAMP_FIELD__: new Date('2024-01-01')
          }
          callsCount = 0

          async execute(input: any): Promise<any> {
            this.params = input
            this.callsCount++
            return this.result
          }
        }

        export class ValidationSpy implements Validation {
          error: Error | null = null
          input: any

          validate(input: any): Error | null {
            this.input = input
            return this.error
          }
        }

    # === STEP 4: CREATE CONTROLLER TEST (TDD - RED PHASE) ===
    - id: 'create-controller-test-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'TDD RED: Write failing tests for __USE_CASE_NAME_PASCAL_CASE__Controller'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'test driven development vitest red green refactor'
          description: 'TDD cycle with Vitest'
      path: '__PROJECT_NAME__/tests/presentation/controllers/__USE_CASE_NAME_KEBAB_CASE__-controller.spec.ts'
      template: |
        import { describe, it, expect, vi, beforeEach } from 'vitest'
        import { __USE_CASE_NAME_PASCAL_CASE__Controller } from '@/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/presentation/controllers/__USE_CASE_NAME_KEBAB_CASE__-controller'
        import { badRequest, serverError, ok, noContent } from '@/presentation/helpers'
        import { __USE_CASE_NAME_PASCAL_CASE__Spy, ValidationSpy } from '@/tests/presentation/mocks/mock-__USE_CASE_NAME_KEBAB_CASE__'

        /**
         * TDD RED Phase: Write tests BEFORE implementation
         * AI-NOTE: These tests will FAIL initially - that's expected!
         * The implementation will be created to make these tests pass
         */

        type SutTypes = {
          sut: __USE_CASE_NAME_PASCAL_CASE__Controller
          __USE_CASE_NAME_CAMEL_CASE__Spy: __USE_CASE_NAME_PASCAL_CASE__Spy
          validationSpy: ValidationSpy
        }

        const makeSut = (): SutTypes => {
          const __USE_CASE_NAME_CAMEL_CASE__Spy = new __USE_CASE_NAME_PASCAL_CASE__Spy()
          const validationSpy = new ValidationSpy()
          const sut = new __USE_CASE_NAME_PASCAL_CASE__Controller(
            __USE_CASE_NAME_CAMEL_CASE__Spy,
            validationSpy
          )
          return {
            sut,
            __USE_CASE_NAME_CAMEL_CASE__Spy,
            validationSpy
          }
        }

        // AI-NOTE: NEVER use faker or random data - use fixed test data
        const makeRequest = (): __USE_CASE_NAME_PASCAL_CASE__Controller.Request => ({
          __INPUT_FIELD_1__: 'test-value-1',
          __INPUT_FIELD_2__: 'test-value-2',
          __INPUT_FIELD_3__: 'test-value-3'
        })

        describe('__USE_CASE_NAME_PASCAL_CASE__Controller', () => {
          describe('TDD RED - These tests will fail initially', () => {
            it('should call Validation with correct values', async () => {
              const { sut, validationSpy } = makeSut()
              const request = makeRequest()

              await sut.handle(request)

              expect(validationSpy.input).toEqual(request)
            })

            it('should return 400 if Validation fails', async () => {
              const { sut, validationSpy } = makeSut()
              validationSpy.error = new Error('Validation error')

              const httpResponse = await sut.handle(makeRequest())

              expect(httpResponse).toEqual(badRequest(validationSpy.error))
            })

            it('should call __USE_CASE_NAME_PASCAL_CASE__ with correct values', async () => {
              const { sut, __USE_CASE_NAME_CAMEL_CASE__Spy } = makeSut()
              const request = makeRequest()

              await sut.handle(request)

              expect(__USE_CASE_NAME_CAMEL_CASE__Spy.params).toEqual(request)
            })

            it('should return 500 if __USE_CASE_NAME_PASCAL_CASE__ throws', async () => {
              const { sut, __USE_CASE_NAME_CAMEL_CASE__Spy } = makeSut()
              vi.spyOn(__USE_CASE_NAME_CAMEL_CASE__Spy, 'execute').mockRejectedValueOnce(new Error())

              const httpResponse = await sut.handle(makeRequest())

              expect(httpResponse).toEqual(serverError(new Error()))
            })

            it('should return 200 on success', async () => {
              const { sut, __USE_CASE_NAME_CAMEL_CASE__Spy } = makeSut()

              const httpResponse = await sut.handle(makeRequest())

              expect(httpResponse).toEqual(ok(__USE_CASE_NAME_CAMEL_CASE__Spy.result))
            })

            it('should return 204 if no content', async () => {
              const { sut, __USE_CASE_NAME_CAMEL_CASE__Spy } = makeSut()
              __USE_CASE_NAME_CAMEL_CASE__Spy.result = null

              const httpResponse = await sut.handle(makeRequest())

              expect(httpResponse).toEqual(noContent())
            })
          })
        })

    # === STEP 5: RUN TESTS - VERIFY RED (TDD - RED PHASE) ===
    - id: 'verify-tests-fail-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'TDD RED: Verify tests fail (controller does not exist yet)'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      run_scripts:
        description: 'Run tests to ensure they fail (RED phase)'
        scripts:
          - name: 'Run failing tests'
            command: |
              echo "🔴 TDD RED: Running tests - they should FAIL..."
              npm test -- __USE_CASE_NAME_KEBAB_CASE__-controller.spec.ts || {
                echo "✅ Good! Tests are failing as expected (RED phase)"
                echo "   Now we'll implement the code to make them pass..."
                exit 0
              }
              echo "❌ ERROR: Tests are passing but code doesn't exist yet!"
              exit 1
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 6: CREATE PRESENTATION STRUCTURE (TDD - GREEN PHASE) ===
    - id: 'create-presentation-structure-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'folder'
      description: 'TDD GREEN: Create presentation layer structure to make tests pass'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      action:
        create_folders:
          basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/presentation'
          folders:
            - 'controllers'
            - 'errors'
            - 'protocols'
            - 'helpers'

    # === STEP 7: CREATE CONTROLLER (TDD - GREEN PHASE) ===
    - id: 'create-presentation-controller-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'TDD GREEN: Implement controller to make tests pass'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'express controller clean architecture dependency injection'
          url: 'https://github.com/...'
          description: 'Following Clean Architecture controller pattern for Express.'
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '*Controller'
          description: 'Consistent with existing backend controllers.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/presentation/controllers/__USE_CASE_NAME_KEBAB_CASE__-controller.ts'
      template: |
        import { Controller, HttpResponse, Validation } from '@/presentation/protocols'
        import { badRequest, serverError, ok, noContent } from '@/presentation/helpers'
        import { __USE_CASE_NAME_PASCAL_CASE__ } from '@/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain/usecases/__USE_CASE_NAME_KEBAB_CASE__'

        /**
         * HTTP Controller for __USE_CASE_NAME_PASCAL_CASE__ use case
         * @pattern Clean Architecture - Framework agnostic controller
         * @layer Presentation Layer - HTTP adapter for business logic
         * @architecture Vertical Slice - Self-contained controller
         *
         * AI-NOTE: Controllers should only:
         * 1. Validate request format (NOT business rules)
         * 2. Call the use case
         * 3. Transform result to HTTP response
         * 4. Handle errors appropriately
         */
        export class __USE_CASE_NAME_PASCAL_CASE__Controller implements Controller {
          constructor(
            private readonly __USE_CASE_NAME_CAMEL_CASE__: __USE_CASE_NAME_PASCAL_CASE__,
            private readonly validation: Validation
          ) {}

          /**
           * Handle HTTP request for __USE_CASE_NAME_LOWER_CASE__
           * @param request - HTTP request data
           * @returns Promise with HTTP response
           */
          async handle(request: __USE_CASE_NAME_PASCAL_CASE__Controller.Request): Promise<HttpResponse> {
            try {
              // AI-NOTE: Validation is structural only - business rules belong in domain
              const error = this.validation.validate(request)
              if (error) {
                return badRequest(error)
              }

              // AI-NOTE: Controller delegates to use case - no business logic here
              const result = await this.__USE_CASE_NAME_CAMEL_CASE__.execute(request)

              // AI-NOTE: Choose appropriate response based on use case type
              if (!result) {
                return noContent()
              }

              return ok(result)
            } catch (error) {
              // AI-NOTE: All unhandled errors become 500 - domain errors should be caught
              return serverError(error)
            }
          }
        }

        /**
         * Namespace for __USE_CASE_NAME_PASCAL_CASE__Controller types
         * AI-NOTE: Request type should match domain input but may have HTTP-specific fields
         */
        export namespace __USE_CASE_NAME_PASCAL_CASE__Controller {
          export type Request = {
            __INPUT_FIELD_1__: string
            __INPUT_FIELD_2__: string
            __INPUT_FIELD_3__: string
            // AI-NOTE: Add authentication/authorization fields if needed
            accountId?: string
            role?: string
          }
        }

    # === STEP 8: RUN TESTS - VERIFY GREEN (TDD - GREEN PHASE) ===
    - id: 'verify-tests-pass-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'TDD GREEN: Verify all tests pass with implementation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      run_scripts:
        description: 'Run tests to ensure they pass (GREEN phase)'
        scripts:
          - name: 'Run passing tests'
            command: |
              echo "🟢 TDD GREEN: Running tests - they should PASS now..."
              npm test -- __USE_CASE_NAME_KEBAB_CASE__-controller.spec.ts || {
                echo "❌ ERROR: Tests are still failing after implementation!"
                echo "   Review the controller implementation and fix issues."
                exit 1
              }
              echo "✅ Excellent! All tests are passing (GREEN phase)"
              echo "   Consider refactoring if needed (REFACTOR phase)..."
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 9: CREATE HTTP HELPERS ===
    - id: 'create-presentation-helpers-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create HTTP helper functions for __USE_CASE_NAME_PASCAL_CASE__'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: 'http-helper'
          description: 'Following existing HTTP helper patterns.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/presentation/helpers/http-helper.ts'
      template: |
        import { HttpResponse } from '@/presentation/protocols'
        import { ServerError, UnauthorizedError } from '@/presentation/errors'

        /**
         * HTTP Helper functions for consistent responses
         * AI-NOTE: Use these helpers to maintain consistent HTTP status codes
         * and error handling across all controllers
         */

        export const badRequest = (error: Error): HttpResponse => ({
          statusCode: 400,
          body: error
        })

        export const forbidden = (error: Error): HttpResponse => ({
          statusCode: 403,
          body: error
        })

        export const unauthorized = (): HttpResponse => ({
          statusCode: 401,
          body: new UnauthorizedError()
        })

        export const serverError = (error: Error): HttpResponse => ({
          statusCode: 500,
          body: new ServerError(error.stack)
        })

        export const ok = (data: any): HttpResponse => ({
          statusCode: 200,
          body: data
        })

        export const noContent = (): HttpResponse => ({
          statusCode: 204,
          body: null
        })

        export const created = (data: any): HttpResponse => ({
          statusCode: 201,
          body: data
        })

    # === STEP 10: CREATE PRESENTATION ERRORS ===
    - id: 'create-presentation-errors-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create presentation errors for __USE_CASE_NAME_PASCAL_CASE__'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      references:
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '*Error'
          description: 'Consistent with existing presentation errors.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/presentation/errors/__USE_CASE_NAME_KEBAB_CASE__-errors.ts'
      template: |
        /**
         * Presentation layer errors for __USE_CASE_NAME_PASCAL_CASE__
         * AI-NOTE: These are HTTP-specific errors, not domain errors
         */

        export class ServerError extends Error {
          constructor(stack?: string) {
            super('Internal server error')
            this.name = 'ServerError'
            this.stack = stack
          }
        }

        export class UnauthorizedError extends Error {
          constructor() {
            super('Unauthorized')
            this.name = 'UnauthorizedError'
          }
        }

        export class AccessDeniedError extends Error {
          constructor() {
            super('Access denied')
            this.name = 'AccessDeniedError'
          }
        }

        export class MissingParamError extends Error {
          constructor(paramName: string) {
            super(`Missing param: ${paramName}`)
            this.name = 'MissingParamError'
          }
        }

        export class InvalidParamError extends Error {
          constructor(paramName: string) {
            super(`Invalid param: ${paramName}`)
            this.name = 'InvalidParamError'
          }
        }

    # === STEP 11: CREATE MIDDLEWARE (IF NEEDED) ===
    - id: 'create-presentation-middleware-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create authentication middleware for __USE_CASE_NAME_PASCAL_CASE__ if needed'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: '__REQUIRES_AUTH__' # Skip if authentication not needed
      references:
        - type: 'external_pattern'
          source: 'context7'
          query: 'express middleware clean architecture authentication'
          url: 'https://github.com/...'
          description: 'Authentication middleware pattern.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared/presentation/middlewares/auth-middleware.ts'
      template: |
        import { Middleware, HttpResponse } from '@/presentation/protocols'
        import { forbidden, ok, serverError } from '@/presentation/helpers'
        import { AccessDeniedError } from '@/presentation/errors'
        import { LoadAccountByToken } from '@/domain/usecases'

        /**
         * Authentication Middleware for __FEATURE_NAME_PASCAL_CASE__ feature
         * AI-NOTE: Middleware should only handle cross-cutting concerns
         * Business logic belongs in use cases
         */
        export class AuthMiddleware implements Middleware {
          constructor(
            private readonly loadAccountByToken: LoadAccountByToken,
            private readonly role?: string
          ) {}

          async handle(request: AuthMiddleware.Request): Promise<HttpResponse> {
            try {
              const { accessToken } = request
              if (accessToken) {
                const account = await this.loadAccountByToken.load(accessToken, this.role)
                if (account) {
                  return ok({ accountId: account.id })
                }
              }
              return forbidden(new AccessDeniedError())
            } catch (error) {
              return serverError(error)
            }
          }
        }

        export namespace AuthMiddleware {
          export type Request = {
            accessToken?: string
          }
        }

    # === STEP 12: REFACTOR (TDD - REFACTOR PHASE - OPTIONAL) ===
    - id: 'refactor-presentation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'TDD REFACTOR: Improve code quality while keeping tests green'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      condition: '__NEEDS_REFACTORING__' # Optional step
      references:
        - type: 'internal_guideline'
          source: 'REFACTOR_GUIDE.md'
          description: 'Refactoring patterns and best practices'
      run_scripts:
        description: 'Refactor code while ensuring tests remain green'
        scripts:
          - name: 'Refactor with safety'
            command: |
              echo "♻️ TDD REFACTOR: Improving code quality..."
              echo "   Common refactorings:"
              echo "   - Extract methods for better readability"
              echo "   - Remove duplication"
              echo "   - Improve naming"
              echo "   - Simplify complex conditionals"

              # Run tests before refactoring
              npm test -- __USE_CASE_NAME_KEBAB_CASE__-controller.spec.ts || {
                echo "❌ Tests must be green before refactoring!"
                exit 1
              }

              # AI-NOTE: Apply refactorings here
              # Examples:
              # - Extract validation to separate method
              # - Simplify error handling
              # - Improve response helpers

              # Run tests after refactoring
              npm test -- __USE_CASE_NAME_KEBAB_CASE__-controller.spec.ts || {
                echo "❌ Refactoring broke tests! Revert changes."
                exit 1
              }

              echo "✅ Refactoring complete - tests still green!"
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 13: CREATE FEATURE SHARED PRESENTATION (IF NEEDED) ===
    - id: 'create-shared-presentation-__FEATURE_NAME_KEBAB_CASE__'
      type: 'create_file'
      description: 'Create shared presentation protocols for __FEATURE_NAME_PASCAL_CASE__ feature'
      status: 'PENDING' # PENDING | SUCCESS | FAILED | SKIPPED
      rlhf_score: null # -2, -1, 0, 1, 2
      execution_log: ''
      condition: '__MULTIPLE_USE_CASES_IN_FEATURE__' # Skip if single use case
      references:
        - type: 'internal_code_analysis'
          source: 'serena'
          tool: 'find_symbol'
          query: '*Protocol'
          description: 'Check if feature shared protocols exist.'
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared/presentation/protocols/index.ts'
      template: |
        /**
         * Shared presentation protocols for __FEATURE_NAME_PASCAL_CASE__ feature
         * AI-NOTE: These are shared across multiple use cases in this feature
         */

        export type HttpResponse = {
          statusCode: number
          body: any
        }

        export interface Controller {
          handle(request: any): Promise<HttpResponse>
        }

        export interface Middleware {
          handle(request: any): Promise<HttpResponse>
        }

        export interface Validation {
          validate(input: any): Error | null
        }

    # === STEP 14: REFACTOR FOR BROWNFIELD (CONDITIONAL) ===
    # AI-NOTE: When brownfield refactoring is needed, the AI should dynamically generate
    # steps based on the specific files that need refactoring. Each file should
    # have its own step for better tracking and granular control.

    - id: 'refactor-presentation-__FILE_TO_MODIFY_KEBAB_CASE__'
      type: 'conditional_file'
      description: 'Refactor __FILE_TO_MODIFY_KEBAB_CASE__ presentation layer to Clean Architecture'
      condition: 'check_if_presentation_needs_refactoring'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'REFACTORING_GUIDE.md'
          description: 'Clean Architecture refactoring patterns for presentation layer'
        - type: 'internal_code_analysis'
          source: 'serena'
          description: 'Analyze current presentation structure and dependencies'
      path: '__PROJECT_NAME__/src/__PATH_TO_FILE__/__FILE_TO_MODIFY_KEBAB_CASE__.ts'
      template: |
        # AI-NOTE: FIND/REPLACE Pattern for Brownfield Refactoring
        # The AI must identify SPECIFIC code blocks that violate Clean Architecture
        # Common presentation layer violations:
        # - Business logic in controllers/routes
        # - Direct database access
        # - Framework dependencies (Express types)
        # - Missing dependency injection
        # - Poor error handling

        <<<FIND>>>
        # AI-NOTE: Match the EXACT code including imports if needed
        # Be specific to avoid matching wrong code blocks
        # Include enough context for unique identification
        # Look for violations like:
        # - app.post('/api/...', async (req, res) => { ... database calls ... })
        # - import { Request, Response } from 'express'
        # - Manual validation in controllers
        # - JWT verification in controller
        # - Missing try-catch blocks
        [ORIGINAL_CODE_TO_BE_REPLACED]
        <<<REPLACE>>>
        # AI-NOTE: Apply Clean Architecture transformation
        # Ensure the refactored code:
        # - Separates controllers from routes
        # - Uses framework-agnostic interfaces
        # - Implements proper dependency injection
        # - Has consistent error handling
        # - Delegates business logic to use cases
        # - Uses middleware for cross-cutting concerns
        [REFACTORED_CODE_FOLLOWING_CLEAN_ARCHITECTURE]

    # === STEP 15: CREATE PULL REQUEST ===
    - id: 'create-pr-presentation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Create Pull Request for __USE_CASE_NAME_PASCAL_CASE__ presentation layer'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'PR_TEMPLATE.md'
          description: 'Pull request template and guidelines'
      run_scripts:
        description: 'Create PR using GitHub CLI'
        scripts:
          - name: 'Push branch and create PR'
            command: |
              # Push branch to remote
              git push -u origin "feat/__FEATURE_NAME_KEBAB_CASE__-__USE_CASE_NAME_KEBAB_CASE__-presentation"

              # Create PR using GitHub CLI
              gh pr create \
                --title "feat(__FEATURE_NAME_KEBAB_CASE__): add __USE_CASE_NAME_KEBAB_CASE__ presentation layer" \
                --body "## Summary

              Added presentation layer for __USE_CASE_NAME_PASCAL_CASE__ use case following Clean Architecture patterns.

              ## Changes
              - ✅ Created controller with dependency injection
              - ✅ Added HTTP helper functions
              - ✅ Implemented middleware for cross-cutting concerns
              - ✅ Added comprehensive unit tests
              - ✅ Follows vertical slice architecture

              ## Testing
              - [ ] Unit tests pass
              - [ ] Integration tests pass
              - [ ] Manual testing completed

              ## Checklist
              - [ ] Code follows Clean Architecture principles
              - [ ] No business logic in controllers
              - [ ] Framework-agnostic interfaces
              - [ ] Proper error handling
              - [ ] Tests coverage > 80%
              " \
                --assignee @me \
                --label "feature,presentation,clean-architecture"
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 16: CODE REVIEW ===
    - id: 'code-review-presentation-__USE_CASE_NAME_KEBAB_CASE__'
      type: 'validation'
      description: 'Automated code review for presentation layer implementation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      references:
        - type: 'internal_guideline'
          source: 'CODE_REVIEW_CHECKLIST.md'
          description: 'Code review standards for presentation layer'
      run_scripts:
        description: 'Run automated code review checks'
        scripts:
          - name: 'Architecture compliance check'
            command: |
              echo "🔍 Running presentation layer architecture compliance checks..."

              # Check for business logic in controllers
              if grep -r "prisma\." src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/presentation/controllers/; then
                echo "❌ CRITICAL: Direct database access found in controllers"
                exit 1
              fi

              # Check for Express dependencies
              if grep -r "import.*Request.*from.*express" src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/presentation/controllers/; then
                echo "❌ ERROR: Express dependencies found in controllers"
                exit 1
              fi

              # Check for proper error handling
              if ! grep -r "try.*catch" src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/presentation/controllers/; then
                echo "⚠️ WARNING: Missing try-catch blocks in controllers"
              fi

              echo "✅ Presentation layer architecture compliance passed"
            workingDirectory: '__PROJECT_NAME__'

  # ------------------------------------------------------------------------------
  # PRESENTATION REFACTORING PATTERN
  # Single pattern for refactoring existing code to Clean Architecture presentation layer
  # ------------------------------------------------------------------------------

  presentation_refactoring_patterns:
    - id: 'refactor-to-clean-presentation'
      description: 'Refactor existing presentation layer to follow Clean Architecture'
      detection:
        - 'Direct database access in controllers/routes'
        - 'Business logic mixed with HTTP handling'
        - 'Framework-specific types in controllers'
        - 'Missing dependency injection'
        - 'Poor error handling'
      example:
        original: |
          <<<FIND>>>
          # AI-NOTE: Identify presentation layer violations
          # Common patterns to look for:
          # 1. Express routes with inline business logic
          # 2. Controllers with database queries
          # 3. Framework dependencies (req, res)
          # 4. Missing validation layer
          # 5. Authentication logic in controllers
          [ORIGINAL_VIOLATING_CODE]
          <<<REPLACE>>>
          # AI-NOTE: Apply Clean Architecture transformation
          # The refactored code should:
          # 1. Separate controllers from routes
          # 2. Use framework-agnostic interfaces
          # 3. Implement dependency injection
          # 4. Delegate to use cases
          # 5. Use middleware for cross-cutting concerns
          [REFACTORED_CLEAN_CODE]
        category: 'presentation-refactoring'
        severity: 'HIGH'
        rlhf_impact: -2 # Major architecture violation

  # ------------------------------------------------------------------------------
  # PRESENTATION ANTI-PATTERNS TO AVOID
  # Common mistakes that violate Clean Architecture in presentation layer
  # ------------------------------------------------------------------------------

  presentation_anti_patterns:
    - name: 'Business Logic in Controller'
      description: 'Controller contains business rules instead of delegating to use case'
      example: 'if (user.age < 18) return forbidden() // Business rule!'
      correct: 'Let use case throw domain error, controller just transforms it'
      rlhf_impact: -2

    - name: 'Direct Database Access'
      description: 'Controller or middleware accessing database directly'
      example: 'const user = await prisma.user.findUnique(...)'
      correct: 'Controller calls use case, use case calls repository'
      rlhf_impact: -2

    - name: 'Framework Coupling'
      description: 'Controllers depend on Express/Fastify specific types'
      example: 'import { Request, Response } from "express"'
      correct: 'Use framework-agnostic interfaces'
      rlhf_impact: -1

    - name: 'Missing Validation'
      description: 'No validation layer, manual checks in controller'
      example: 'if (!email) return badRequest(...)'
      correct: 'Inject Validation interface'
      rlhf_impact: -1

    - name: 'Poor Error Handling'
      description: 'No try-catch or exposing internal errors'
      example: 'res.status(500).json({ error: error.message })'
      correct: 'Use serverError helper with proper logging'
      rlhf_impact: -1



# --- From: shared/steps/validation.part.regent ---
# ------------------------------------------------------------------------------
# SHARED VALIDATION LAYER TEMPLATE
# Clean Architecture - Shared Validation Components
# Supports: Backend (Node.js), Frontend (Next.js), Fullstack
# Pattern: TDD with RED-GREEN-REFACTOR cycle
# ------------------------------------------------------------------------------

metadata:
  layer: 'validation'
  project_type: 'backend' # backend | frontend | fullstack - AI-NOTE: Replace with actual project type
  architecture_style: 'clean'
  test_framework: 'jest' # jest | vitest - AI-NOTE: Replace with actual test framework
  language: 'typescript'
  patterns:
    - 'validation-composite'
    - 'field-validators'
    - 'error-handling'
  references:
    - 'Clean Architecture principles'
    - 'SOLID principles'
    - 'TDD methodology'

# ------------------------------------------------------------------------------
# VALIDATION STRUCTURE SETUP
# ------------------------------------------------------------------------------

structure:
  validation_structure:
    description: 'Setup validation layer structure'
    folders:
      - 'src/validation'
      - 'src/validation/protocols'
      - 'src/validation/validators'
      - 'src/validation/errors'
      - 'tests/validation'
      - 'tests/validation/validators'
      - 'tests/validation/mocks'

# ------------------------------------------------------------------------------
# VALIDATION IMPLEMENTATION STEPS
# Following TDD: RED -> GREEN -> REFACTOR
# ------------------------------------------------------------------------------

steps:
  validation_steps:
    # === STEP 1: CREATE VALIDATION BRANCH ===
    - id: 'create-validation-branch'
      type: 'validation'
      description: 'Create feature branch for validation implementation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      run_scripts:
        description: 'Create and checkout validation feature branch'
        scripts:
          - name: 'Create validation branch'
            command: |
              git checkout -b "feat/__FEATURE_NAME_KEBAB_CASE__-validation"
              echo "✅ Created branch: feat/__FEATURE_NAME_KEBAB_CASE__-validation"
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 2: TDD RED - CREATE VALIDATION PROTOCOLS ===
    - id: 'test-validation-protocols'
      type: 'test'
      description: 'TDD RED: Create validation protocol tests (should fail)'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/tests/validation/protocols/validation.spec.ts'
      template: |
        import { Validation } from '@/validation/protocols'

        describe('Validation Protocol', () => {
          test('Should have validate method', () => {
            const validation: Validation = {
              validate: jest.fn()
            }

            const input = { field: 'value' }
            validation.validate(input)

            expect(validation.validate).toHaveBeenCalledWith(input)
          })
        })

    # === STEP 3: TDD RED - CREATE ERROR TESTS ===
    - id: 'test-validation-errors'
      type: 'create_file'
      description: 'TDD RED: Create validation error tests'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/tests/validation/errors/validation-errors.spec.ts'
      template: |
        import {
          MissingParamError,
          InvalidParamError,
          MinLengthError,
          MaxLengthError
        } from '@/validation/errors'

        describe('Validation Errors', () => {
          describe('MissingParamError', () => {
            test('Should return correct error message', () => {
              const error = new MissingParamError('email')
              expect(error.message).toBe('Missing param: email')
              expect(error.name).toBe('MissingParamError')
            })
          })

          describe('InvalidParamError', () => {
            test('Should return correct error message', () => {
              const error = new InvalidParamError('email')
              expect(error.message).toBe('Invalid param: email')
              expect(error.name).toBe('InvalidParamError')
            })
          })

          describe('MinLengthError', () => {
            test('Should return correct error message', () => {
              const error = new MinLengthError('password', 8)
              expect(error.message).toBe('password must be at least 8 characters')
              expect(error.name).toBe('MinLengthError')
            })
          })

          describe('MaxLengthError', () => {
            test('Should return correct error message', () => {
              const error = new MaxLengthError('name', 50)
              expect(error.message).toBe('name must be at most 50 characters')
              expect(error.name).toBe('MaxLengthError')
            })
          })
        })

    # === STEP 4: TDD RED - CREATE VALIDATOR TESTS ===
    - id: 'test-required-field-validation'
      type: 'create_file'
      description: 'TDD RED: Create RequiredFieldValidation tests'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/tests/validation/validators/required-field-validation.spec.ts'
      template: |
        import { RequiredFieldValidation } from '@/validation/validators'
        import { MissingParamError } from '@/validation/errors'

        const makeSut = (fieldName: string): RequiredFieldValidation => {
          return new RequiredFieldValidation(fieldName)
        }

        describe('RequiredFieldValidation', () => {
          test('Should return MissingParamError if field is missing', () => {
            const sut = makeSut('email')
            const error = sut.validate({ name: 'John' })
            expect(error).toEqual(new MissingParamError('email'))
          })

          test('Should return MissingParamError if field is empty', () => {
            const sut = makeSut('email')
            const error = sut.validate({ email: '' })
            expect(error).toEqual(new MissingParamError('email'))
          })

          test('Should return null if field is present', () => {
            const sut = makeSut('email')
            const error = sut.validate({ email: 'john@example.com' })
            expect(error).toBeNull()
          })

          test('Should return null if field is 0', () => {
            const sut = makeSut('age')
            const error = sut.validate({ age: 0 })
            expect(error).toBeNull()
          })

          test('Should return null if field is false', () => {
            const sut = makeSut('active')
            const error = sut.validate({ active: false })
            expect(error).toBeNull()
          })
        })

    # === STEP 5: TDD RED - CREATE EMAIL VALIDATION TESTS ===
    - id: 'test-email-validation'
      type: 'create_file'
      description: 'TDD RED: Create EmailValidation tests'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/tests/validation/validators/email-validation.spec.ts'
      template: |
        import { EmailValidation } from '@/validation/validators'
        import { InvalidParamError } from '@/validation/errors'
        import { EmailValidator } from '@/validation/protocols'

        const makeEmailValidator = (): EmailValidator => {
          class EmailValidatorStub implements EmailValidator {
            isValid(email: string): boolean {
              return true
            }
          }
          return new EmailValidatorStub()
        }

        const makeSut = (): { sut: EmailValidation, emailValidatorStub: EmailValidator } => {
          const emailValidatorStub = makeEmailValidator()
          const sut = new EmailValidation('email', emailValidatorStub)
          return {
            sut,
            emailValidatorStub
          }
        }

        describe('EmailValidation', () => {
          test('Should return InvalidParamError if email is invalid', () => {
            const { sut, emailValidatorStub } = makeSut()
            jest.spyOn(emailValidatorStub, 'isValid').mockReturnValueOnce(false)
            const error = sut.validate({ email: 'invalid_email' })
            expect(error).toEqual(new InvalidParamError('email'))
          })

          test('Should call EmailValidator with correct email', () => {
            const { sut, emailValidatorStub } = makeSut()
            const isValidSpy = jest.spyOn(emailValidatorStub, 'isValid')
            sut.validate({ email: 'john@example.com' })
            expect(isValidSpy).toHaveBeenCalledWith('john@example.com')
          })

          test('Should return null if email is valid', () => {
            const { sut } = makeSut()
            const error = sut.validate({ email: 'john@example.com' })
            expect(error).toBeNull()
          })
        })

    # === STEP 6: TDD RED - CREATE VALIDATION COMPOSITE TESTS ===
    - id: 'test-validation-composite'
      type: 'create_file'
      description: 'TDD RED: Create ValidationComposite tests'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/tests/validation/validators/validation-composite.spec.ts'
      template: |
        import { ValidationComposite } from '@/validation/validators'
        import { Validation } from '@/validation/protocols'
        import { InvalidParamError, MissingParamError } from '@/validation/errors'

        const makeValidation = (): Validation => {
          class ValidationStub implements Validation {
            validate(input: any): Error | null {
              return null
            }
          }
          return new ValidationStub()
        }

        const makeSut = (): { sut: ValidationComposite, validationStubs: Validation[] } => {
          const validationStubs = [makeValidation(), makeValidation()]
          const sut = new ValidationComposite(validationStubs)
          return {
            sut,
            validationStubs
          }
        }

        describe('ValidationComposite', () => {
          test('Should return error if any validation fails', () => {
            const { sut, validationStubs } = makeSut()
            const error = new MissingParamError('field')
            jest.spyOn(validationStubs[1], 'validate').mockReturnValueOnce(error)
            const result = sut.validate({ field: 'value' })
            expect(result).toEqual(error)
          })

          test('Should return first error if more than one validation fails', () => {
            const { sut, validationStubs } = makeSut()
            const firstError = new MissingParamError('field')
            const secondError = new InvalidParamError('field')
            jest.spyOn(validationStubs[0], 'validate').mockReturnValueOnce(firstError)
            jest.spyOn(validationStubs[1], 'validate').mockReturnValueOnce(secondError)
            const result = sut.validate({ field: 'value' })
            expect(result).toEqual(firstError)
          })

          test('Should return null if all validations succeed', () => {
            const { sut } = makeSut()
            const result = sut.validate({ field: 'value' })
            expect(result).toBeNull()
          })

          test('Should call all validations with correct input', () => {
            const { sut, validationStubs } = makeSut()
            const input = { field: 'value' }
            const validateSpy0 = jest.spyOn(validationStubs[0], 'validate')
            const validateSpy1 = jest.spyOn(validationStubs[1], 'validate')
            sut.validate(input)
            expect(validateSpy0).toHaveBeenCalledWith(input)
            expect(validateSpy1).toHaveBeenCalledWith(input)
          })
        })

    # === STEP 7: VERIFY RED PHASE ===
    - id: 'verify-red-phase'
      type: 'validation'
      description: 'TDD RED: Verify all tests fail as expected'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      run_scripts:
        description: 'Run tests to verify they fail (RED phase)'
        scripts:
          - name: 'Verify failing tests'
            command: |
              echo "🔴 TDD RED: Running tests - they should FAIL..."
              npm test -- validation || {
                echo "✅ Good! Tests are failing as expected (RED phase)"
                echo "   Now implementing validation layer..."
                exit 0
              }
              echo "❌ ERROR: Tests should fail in RED phase but they passed!"
              exit 1
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 8: TDD GREEN - IMPLEMENT PROTOCOLS ===
    - id: 'create-validation-protocols'
      type: 'create_file'
      description: 'TDD GREEN: Implement validation protocols'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/protocols/validation.ts'
      template: |
        /**
         * Validation protocol for field validation
         * @interface Validation
         */
        export interface Validation {
          /**
           * Validates input and returns error if validation fails
           * @param input - The input object to validate
           * @returns Error if validation fails, null otherwise
           */
          validate(input: any): Error | null
        }

    - id: 'create-email-validator-protocol'
      type: 'create_file'
      description: 'TDD GREEN: Implement EmailValidator protocol'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/protocols/email-validator.ts'
      template: |
        /**
         * Email validation protocol
         * @interface EmailValidator
         */
        export interface EmailValidator {
          /**
           * Checks if email is valid
           * @param email - Email to validate
           * @returns true if valid, false otherwise
           */
          isValid(email: string): boolean
        }

    - id: 'create-protocols-index'
      type: 'create_file'
      description: 'TDD GREEN: Create protocols index'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/protocols/index.ts'
      template: |
        export * from './validation'
        export * from './email-validator'

    # === STEP 9: TDD GREEN - IMPLEMENT ERRORS ===
    - id: 'create-validation-errors'
      type: 'create_file'
      description: 'TDD GREEN: Implement validation errors'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/errors/index.ts'
      template: |
        /**
         * Error thrown when a required parameter is missing
         */
        export class MissingParamError extends Error {
          constructor(paramName: string) {
            super(`Missing param: ${paramName}`)
            this.name = 'MissingParamError'
          }
        }

        /**
         * Error thrown when a parameter is invalid
         */
        export class InvalidParamError extends Error {
          constructor(paramName: string) {
            super(`Invalid param: ${paramName}`)
            this.name = 'InvalidParamError'
          }
        }

        /**
         * Error thrown when field length is below minimum
         */
        export class MinLengthError extends Error {
          constructor(fieldName: string, minLength: number) {
            super(`${fieldName} must be at least ${minLength} characters`)
            this.name = 'MinLengthError'
          }
        }

        /**
         * Error thrown when field length exceeds maximum
         */
        export class MaxLengthError extends Error {
          constructor(fieldName: string, maxLength: number) {
            super(`${fieldName} must be at most ${maxLength} characters`)
            this.name = 'MaxLengthError'
          }
        }

    # === STEP 10: TDD GREEN - IMPLEMENT VALIDATORS ===
    - id: 'create-required-field-validation'
      type: 'create_file'
      description: 'TDD GREEN: Implement RequiredFieldValidation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/validators/required-field-validation.ts'
      template: |
        import { Validation } from '@/validation/protocols'
        import { MissingParamError } from '@/validation/errors'

        /**
         * Validates that a required field is present and not empty
         */
        export class RequiredFieldValidation implements Validation {
          constructor(private readonly fieldName: string) {}

          validate(input: any): Error | null {
            const value = input[this.fieldName]

            // Check if field exists and is not empty string
            // Allow 0, false, and other falsy values except undefined, null, and empty string
            if (value === undefined || value === null || value === '') {
              return new MissingParamError(this.fieldName)
            }

            return null
          }
        }

    - id: 'create-email-validation'
      type: 'create_file'
      description: 'TDD GREEN: Implement EmailValidation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/validators/email-validation.ts'
      template: |
        import { Validation, EmailValidator } from '@/validation/protocols'
        import { InvalidParamError } from '@/validation/errors'

        /**
         * Validates email format using EmailValidator protocol
         */
        export class EmailValidation implements Validation {
          constructor(
            private readonly fieldName: string,
            private readonly emailValidator: EmailValidator
          ) {}

          validate(input: any): Error | null {
            const email = input[this.fieldName]

            if (email && !this.emailValidator.isValid(email)) {
              return new InvalidParamError(this.fieldName)
            }

            return null
          }
        }

    - id: 'create-compare-fields-validation'
      type: 'create_file'
      description: 'TDD GREEN: Implement CompareFieldsValidation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/validators/compare-fields-validation.ts'
      template: |
        import { Validation } from '@/validation/protocols'
        import { InvalidParamError } from '@/validation/errors'

        /**
         * Validates that two fields have the same value
         */
        export class CompareFieldsValidation implements Validation {
          constructor(
            private readonly fieldName: string,
            private readonly fieldToCompareName: string
          ) {}

          validate(input: any): Error | null {
            if (input[this.fieldName] !== input[this.fieldToCompareName]) {
              return new InvalidParamError(this.fieldToCompareName)
            }

            return null
          }
        }

    - id: 'create-min-length-validation'
      type: 'create_file'
      description: 'TDD GREEN: Implement MinLengthValidation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/validators/min-length-validation.ts'
      template: |
        import { Validation } from '@/validation/protocols'
        import { MinLengthError } from '@/validation/errors'

        /**
         * Validates minimum field length
         */
        export class MinLengthValidation implements Validation {
          constructor(
            private readonly fieldName: string,
            private readonly minLength: number
          ) {}

          validate(input: any): Error | null {
            const value = input[this.fieldName]

            if (value && value.length < this.minLength) {
              return new MinLengthError(this.fieldName, this.minLength)
            }

            return null
          }
        }

    - id: 'create-max-length-validation'
      type: 'create_file'
      description: 'TDD GREEN: Implement MaxLengthValidation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/validators/max-length-validation.ts'
      template: |
        import { Validation } from '@/validation/protocols'
        import { MaxLengthError } from '@/validation/errors'

        /**
         * Validates maximum field length
         */
        export class MaxLengthValidation implements Validation {
          constructor(
            private readonly fieldName: string,
            private readonly maxLength: number
          ) {}

          validate(input: any): Error | null {
            const value = input[this.fieldName]

            if (value && value.length > this.maxLength) {
              return new MaxLengthError(this.fieldName, this.maxLength)
            }

            return null
          }
        }

    - id: 'create-validation-composite'
      type: 'create_file'
      description: 'TDD GREEN: Implement ValidationComposite'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/validators/validation-composite.ts'
      template: |
        import { Validation } from '@/validation/protocols'

        /**
         * Composite pattern for combining multiple validations
         */
        export class ValidationComposite implements Validation {
          constructor(private readonly validations: Validation[]) {}

          validate(input: any): Error | null {
            for (const validation of this.validations) {
              const error = validation.validate(input)
              if (error) {
                return error
              }
            }

            return null
          }
        }

    - id: 'create-validators-index'
      type: 'create_file'
      description: 'TDD GREEN: Create validators index'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/validators/index.ts'
      template: |
        export * from './required-field-validation'
        export * from './email-validation'
        export * from './compare-fields-validation'
        export * from './min-length-validation'
        export * from './max-length-validation'
        export * from './validation-composite'

    # === STEP 11: TDD GREEN - CREATE EMAIL VALIDATOR ADAPTER ===
    - id: 'create-email-validator-adapter'
      type: 'conditional_file'
      description: 'TDD GREEN: Create EmailValidatorAdapter'
      condition: '__PROJECT_TYPE__ !== "frontend"' # Backend and Fullstack need this
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/infra/validators/email-validator-adapter.ts'
      template: |
        import { EmailValidator } from '@/validation/protocols'
        import validator from 'validator'

        /**
         * Adapter for validator.js email validation
         */
        export class EmailValidatorAdapter implements EmailValidator {
          isValid(email: string): boolean {
            return validator.isEmail(email)
          }
        }

    - id: 'create-zod-email-validator'
      type: 'conditional_file'
      description: 'TDD GREEN: Create Zod EmailValidator'
      condition: '__PROJECT_TYPE__ === "frontend" || __PROJECT_TYPE__ === "fullstack"'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/infra/validators/zod-email-validator.ts'
      template: |
        import { EmailValidator } from '@/validation/protocols'
        import { z } from 'zod'

        /**
         * Zod-based email validator for frontend/fullstack
         */
        export class ZodEmailValidator implements EmailValidator {
          private readonly schema = z.string().email()

          isValid(email: string): boolean {
            const result = this.schema.safeParse(email)
            return result.success
          }
        }

    # === STEP 12: TDD GREEN - CREATE VALIDATION FACTORY ===
    - id: 'create-validation-factory'
      type: 'create_file'
      description: 'TDD GREEN: Create validation factory example'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/validation/factories/__USE_CASE_NAME_KEBAB_CASE__-validation-factory.ts'
      template: |
        import {
          ValidationComposite,
          RequiredFieldValidation,
          EmailValidation,
          MinLengthValidation,
          CompareFieldsValidation
        } from '@/validation/validators'
        import { Validation } from '@/validation/protocols'
        // AI-NOTE: Import appropriate EmailValidator based on project type
        // Backend: import { EmailValidatorAdapter } from '@/infra/validators/email-validator-adapter'
        // Frontend: import { ZodEmailValidator } from '@/infra/validators/zod-email-validator'

        /**
         * Factory for creating __USE_CASE_NAME_PASCAL_CASE__ validation
         * @example
         * const validation = make__USE_CASE_NAME_PASCAL_CASE__Validation()
         * const error = validation.validate(input)
         */
        export const make__USE_CASE_NAME_PASCAL_CASE__Validation = (): Validation => {
          const validations: Validation[] = []

          // Required fields
          const requiredFields = ['email', 'password', 'name']
          for (const field of requiredFields) {
            validations.push(new RequiredFieldValidation(field))
          }

          // Email validation
          // AI-NOTE: Use appropriate EmailValidator
          // const emailValidator = new EmailValidatorAdapter() // Backend
          // const emailValidator = new ZodEmailValidator() // Frontend
          // validations.push(new EmailValidation('email', emailValidator))

          // Password minimum length
          validations.push(new MinLengthValidation('password', 8))

          // Password confirmation
          validations.push(new CompareFieldsValidation('password', 'passwordConfirmation'))

          return new ValidationComposite(validations)
        }

    # === STEP 13: VERIFY GREEN PHASE ===
    - id: 'verify-green-phase'
      type: 'validation'
      description: 'TDD GREEN: Verify all tests pass'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      run_scripts:
        description: 'Run tests to ensure they pass (GREEN phase)'
        scripts:
          - name: 'Verify passing tests'
            command: |
              echo "🟢 TDD GREEN: Running tests - they should PASS now..."
              npm test -- validation || {
                echo "❌ ERROR: Tests are still failing after implementation!"
                echo "   Review the implementation and fix issues."
                exit 1
              }
              echo "✅ Excellent! All validation tests are passing (GREEN phase)"
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 14: TDD REFACTOR - IMPROVE CODE QUALITY ===
    - id: 'refactor-validation-layer'
      type: 'validation'
      description: 'TDD REFACTOR: Improve validation code quality'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      condition: '__NEEDS_REFACTORING__'
      run_scripts:
        description: 'Refactor while keeping tests green'
        scripts:
          - name: 'Refactor validation layer'
            command: |
              echo "♻️ TDD REFACTOR: Improving validation layer..."
              echo "   Common refactorings:"
              echo "   - Extract validation builders"
              echo "   - Add custom validation types"
              echo "   - Improve error messages"
              echo "   - Add validation middleware"

              # Run tests before refactoring
              npm test -- validation || {
                echo "❌ Tests must be green before refactoring!"
                exit 1
              }

              # AI-NOTE: Apply refactorings here

              # Run tests after refactoring
              npm test -- validation || {
                echo "❌ Refactoring broke tests! Revert changes."
                exit 1
              }

              echo "✅ Refactoring complete - tests still green!"
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 15: CREATE INTEGRATION EXAMPLE ===
    - id: 'create-integration-example'
      type: 'create_file'
      description: 'Create example of validation integration'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/docs/validation-integration.md'
      template: |
        # Validation Layer Integration Guide

        ## Backend Integration (Express/Node.js)

        ```typescript
        // In presentation layer controller
        import { makeSignUpValidation } from '@/validation/factories'

        export class SignUpController {
          constructor(
            private readonly validation: Validation,
            private readonly signUp: SignUp
          ) {}

          async handle(request: HttpRequest): Promise<HttpResponse> {
            const error = this.validation.validate(request.body)
            if (error) {
              return badRequest(error)
            }

            // Continue with use case execution
          }
        }

        // In factory
        const validation = makeSignUpValidation()
        const controller = new SignUpController(validation, signUpUseCase)
        ```

        ## Frontend Integration (Next.js/React)

        ```typescript
        // In Server Action
        'use server'
        import { makeSignUpValidation } from '@/validation/factories'

        export async function signUpAction(formData: FormData) {
          const validation = makeSignUpValidation()
          const input = Object.fromEntries(formData)

          const error = validation.validate(input)
          if (error) {
            return { success: false, error: error.message }
          }

          // Continue with use case
        }
        ```

        ## Custom Validators

        ```typescript
        // Create custom validator
        export class CpfValidation implements Validation {
          constructor(private readonly fieldName: string) {}

          validate(input: any): Error | null {
            const cpf = input[this.fieldName]
            if (!isValidCpf(cpf)) {
              return new InvalidParamError(this.fieldName)
            }
            return null
          }
        }

        // Add to factory
        validations.push(new CpfValidation('cpf'))
        ```

# ------------------------------------------------------------------------------
# VALIDATION REFACTORING PATTERNS
# ------------------------------------------------------------------------------

validation_refactoring_patterns:
  - id: 'extract-validation-logic'
    description: 'Extract inline validation to validation layer'
    detection:
      - 'Validation logic in controllers'
      - 'Validation logic in use cases'
      - 'Repeated validation code'
    example:
      original: |
        # AI-NOTE: Extract validation from controller to validation layer
        <<<FIND>>>
        export class SignUpController {
          async handle(request: HttpRequest): Promise<HttpResponse> {
            // Inline validation
            if (!request.body.email) {
              return badRequest(new Error('Email is required'))
            }
            if (!request.body.password) {
              return badRequest(new Error('Password is required'))
            }
            if (request.body.password.length < 8) {
              return badRequest(new Error('Password too short'))
            }

            // Use case execution
            const result = await this.signUp.execute(request.body)
            return ok(result)
          }
        }
        <<</FIND>>>
        <<<REPLACE>>>
        export class SignUpController {
          constructor(
            private readonly validation: Validation,
            private readonly signUp: SignUp
          ) {}

          async handle(request: HttpRequest): Promise<HttpResponse> {
            // Delegate to validation layer
            const error = this.validation.validate(request.body)
            if (error) {
              return badRequest(error)
            }

            // Use case execution
            const result = await this.signUp.execute(request.body)
            return ok(result)
          }
        }
        <<</REPLACE>>>
      category: 'architecture'
      severity: 'HIGH'
      rlhf_impact: 2

# ------------------------------------------------------------------------------
# VALIDATION ANTI-PATTERNS
# ------------------------------------------------------------------------------

validation_anti_patterns:
  - name: 'Validation in Use Cases'
    description: 'Use cases should not contain validation logic'
    example: 'if (!email || !password) throw new Error("Invalid input")'
    correct: 'Validation should be in presentation layer before use case'
    rlhf_impact: -2

  - name: 'Duplicate Validation'
    description: 'Same validation logic repeated in multiple places'
    example: 'Email validation in controller and use case'
    correct: 'Use ValidationComposite to reuse validation logic'
    rlhf_impact: -1

  - name: 'Business Rules in Validators'
    description: 'Validators should not contain business logic'
    example: 'Checking if user exists in EmailValidation'
    correct: 'Keep validators focused on format/structure validation'
    rlhf_impact: -2

  - name: 'Hardcoded Error Messages'
    description: 'Error messages hardcoded in multiple places'
    example: 'return { error: "Email is required" }'
    correct: 'Use error classes with consistent messages'
    rlhf_impact: -1

  - name: 'Missing Validation Composition'
    description: 'Not using composite pattern for multiple validations'
    example: 'Multiple if statements for validation'
    correct: 'Use ValidationComposite to combine validators'
    rlhf_impact: -1

# --- From: shared/01-footer.part.regent ---
  # ============= BEGIN FOOTER SECTION =============


  # ------------------------------------------------------------------------------
  # AI-NOTE: IMMUTABLE DOCUMENTATION SECTIONS AHEAD.
  # Copy these sections verbatim. The [placeholders] inside the commands
  # are for HUMAN examples and MUST NOT be replaced by the AI.
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # TROUBLESHOOTING & RECOVERY
  # ------------------------------------------------------------------------------

  troubleshooting:
    lint_fails:
      - 'DO NOT commit - Fix all lint errors first'
      - 'Check for unused imports'
      - 'Verify proper TypeScript types'
      - 'Ensure no console.log statements'
      - 'Run yarn lint --fix to auto-fix when possible'

    tests_fail:
      - 'DO NOT commit - All tests must pass'
      - 'Check if mocks match the actual interfaces'
      - 'Verify Input/Output types are correct'
      - 'Ensure test coverage meets requirements'
      - 'Run specific test: yarn test [test-file-path]'

    typescript_fails:
      - 'Check all type definitions match'
      - 'Ensure no missing imports'
      - 'Verify interface implementations are complete'
      - 'Run yarn tsc --noEmit to check types'

  # Refactoring checklist
  refactoring:
    before_refactoring: |
      # Check current status and differences
      echo "📊 Checking current changes..."
      git status
      git diff

      # Ensure clean working directory
      echo "✅ Saving current work..."
      git stash save "WIP: before refactoring"

      # Create refactoring branch
      echo "🌿 Creating refactor branch..."
      git checkout -b refactor/[feature-name]

      # Run tests to ensure starting point is stable
      echo "🧪 Validating current state..."
      yarn test --run
      if [ $? -ne 0 ]; then
        echo "❌ Tests failing before refactor - fix first!"
        exit 1
      fi
      echo "✅ Ready to refactor"

    during_refactoring: |
      # After each change, check what was modified
      echo "🔍 Reviewing changes..."
      git diff --stat
      git diff

      # Validate the change
      yarn lint && yarn test --run

      # Commit atomically
      git add -p  # Interactive staging
      git commit -m "refactor([feature-name]): [specific change description]"

      # Show what was changed
      git show --stat

    common_scenarios:
      - name: 'Splitting a use case'
        wrong_example: |
          interface CreateUserAndSendEmail {
            execute: (input: CreateUserAndSendEmailInput) => Promise<CreateUserAndSendEmailOutput>
          }
        correct_example: |
          interface CreateUser{
            execute: (input: CreateUserInput) => Promise<CreateUserOutput>
          }
          interface SendWelcomeEmail {
            execute: (input: SendWelcomeEmailInput) => Promise<SendWelcomeEmailOutput>
          }

      - name: 'Renaming domain errors'
        wrong_example: |
          export class ErrorUserExists extends Error {
            constructor() {
              super('Error: user exists')
              this.name = 'ErrorUserExists'
            }
          }
        correct_example: |
          export class UserAlreadyExistsError extends Error {
            constructor() {
              super('User with this email already exists')
              this.name = 'UserAlreadyExistsError'
            }
          }

  # ------------------------------------------------------------------------------
  # LEARNING & IMPROVEMENT PATTERNS
  # The system tracks these patterns to improve over time
  # ------------------------------------------------------------------------------
  learning_patterns:
    common_errors:
      # Domain Layer Violations
      - pattern: 'import axios|fetch|prisma|redis'
        fix: 'Remove external library imports from domain layer'
        layer: 'domain'
        score_impact: -2

      - pattern: 'CreateUserAndSend|GetDataAndFormat'
        fix: 'Split into two separate use cases (SRP violation)'
        layer: 'domain'
        score_impact: -1

      - pattern: 'missing @domainConcept'
        fix: 'Add domain concept documentation for +2 score'
        layer: 'domain'
        score_impact: +1

      # Data Layer Violations
      - pattern: 'direct database access in data layer'
        fix: 'Use repository protocols instead of direct database access'
        layer: 'data'
        score_impact: -2

      - pattern: 'business logic in data layer'
        fix: 'Move business logic to domain layer'
        layer: 'data'
        score_impact: -1

      # Infrastructure Layer Violations
      - pattern: 'business logic in infrastructure'
        fix: 'Infrastructure should only contain adapters and implementations'
        layer: 'infra'
        score_impact: -2

      - pattern: 'missing error handling in adapters'
        fix: 'Add proper error handling and recovery in infrastructure adapters'
        layer: 'infra'
        score_impact: -1

      # Presentation Layer Violations
      - pattern: 'business logic in controllers|components'
        fix: 'Move business logic to use cases in domain layer'
        layer: 'presentation'
        score_impact: -2

      - pattern: 'direct database access from presentation'
        fix: 'Use use cases and factories from main layer'
        layer: 'presentation'
        score_impact: -2

      # Main Layer Violations
      - pattern: 'business logic in factories'
        fix: 'Main layer should only compose, not implement business logic'
        layer: 'main'
        score_impact: -2

      - pattern: 'missing dependency injection'
        fix: 'Use factories and dependency injection for all dependencies'
        layer: 'main'
        score_impact: -1

    success_indicators:
      - 'Uses ubiquitous language consistently across all layers'
      - 'Follows single responsibility principle in every component'
      - 'No dependency violations between layers'
      - 'Comprehensive test coverage (Domain: 100%, Data: 95%, Infra: 80%, Presentation: 90%)'
      - 'Clean git history with atomic commits'
      - 'Proper error handling at each layer boundary'
      - 'Clear separation of concerns between layers'
      - 'Type safety maintained throughout the stack'

  # AI Guidelines for All Layers
  ai_guidelines:
    general:
      - 'Always validate before committing: Run lint first, Run tests second, Only commit if both pass'
      - 'If generation fails: Identify the specific error, Fix only that error, Re-run validation, Do NOT proceed until fixed'
      - 'MUST generate different case styles from the input names (e.g., "Add Item To Cart" becomes: PascalCase=AddItemToCart, kebab-case=add-item-to-cart, lower case=add item to cart).'
      - 'MUST replace ALL placeholder variables (like __FEATURE_NAME_KEBAB_CASE__) with actual values'
      - 'MUST NOT leave any placeholder variables in the final implementation'
      - 'MUST NOT replace any [placeholders] found inside documentation sections like refactoring or recovery'
      - 'MUST use vitest for backend, @testing-library/react for frontend'
      - 'When in doubt: Choose simplicity over complexity, Split rather than combine, Ask for clarification rather than assume'

    layer_specific:
      domain:
        - 'Follow the principle: One use case = One file = One responsibility'
        - 'If tempted to add "And" in a use case name, split it'
        - 'MUST follow all domain rules - no business logic implementation, only contracts'
        - 'No external dependencies allowed in domain layer'
        - 'Use value objects for domain concepts'
        - 'Define clear domain errors with meaningful messages'

      data:
        - 'Implement use cases defined in domain layer'
        - 'Use repository protocols for data access'
        - 'Transform external data to domain models'
        - 'Handle data-specific errors and map to domain errors'
        - 'No direct database or API calls'

      infrastructure:
        - 'Implement repository interfaces defined in data layer'
        - 'Handle external service integrations (database, cache, APIs)'
        - 'Provide concrete implementations of protocols'
        - 'Include proper error handling and retry logic'
        - 'Use appropriate design patterns (Adapter, Facade)'

      presentation:
        - 'Controllers/Components should be thin - delegate to use cases'
        - 'Handle input validation and transformation'
        - 'Format responses for clients'
        - 'Implement proper error responses'
        - 'For frontend: Use hooks for business logic extraction'
        - 'For backend: Use middleware for cross-cutting concerns'

      main:
        - 'Composition root only - no business logic'
        - 'Wire up all dependencies using factories'
        - 'Configure dependency injection'
        - 'Setup application bootstrap and configuration'
        - 'For Next.js: Configure providers and middleware'
        - 'For Express/Fastify: Setup server and routes'

  # ------------------------------------------------------------------------------
  # AI-NOTE: TASK EVALUATION SECTION.
  # After the entire execution is complete, this section will be populated by a
  # human reviewer or an evaluation script.
  # ------------------------------------------------------------------------------

  evaluation:
    # AI-NOTE: This final_status will be 'SUCCESS' if all steps passed, or 'FAILED' if any step failed.
    final_status: 'PENDING' # PENDING | SUCCESS | FAILED
    # AI-NOTE: The final_rlhf_score is calculated automatically based on execution quality
    # -2: Catastrophic errors (architecture violations, wrong REPLACE/WITH format)
    # -1: Runtime errors (lint, tests, git failures)
    #  0: Low confidence (system uncertain, prevents hallucinations)
    # +1: Good execution but missing DDD elements
    # +2: Perfect with Clean Architecture, DDD, ubiquitous language
    final_rlhf_score: null # -2, -1, 0, 1, 2
    # AI-NOTE: The system automatically analyzes patterns and learns from each execution
    # This text is enhanced by automated RLHF analysis for continuous improvement
    reviewer_summary: |
      - What went well:
        - ...
      - Areas for improvement:
        - ...
    # AI-NOTE: This section lists actionable suggestions for improving the master templates or prompts.
    # This is the key to the continuous learning loop.
    template_improvement_suggestions:
      - target_template: '[layer].template.yaml'
        target_step_id: '[step-id]'
        suggestion: '[specific improvement suggestion based on execution results]'
        priority: 'medium'
        
  # ============= END FOOTER SECTION =============

  # End of TEMPLATE.yaml
