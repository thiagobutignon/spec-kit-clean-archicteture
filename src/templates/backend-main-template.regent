# =============================================
# GENERATED FILE - DO NOT EDIT DIRECTLY
# Target: backend
# Layer: main
# Built from parts in templates/parts
# Generated at: 2025-09-30 23:13:55
# To modify, edit the part files and rebuild
# =============================================


# --- From: shared/00-header.part.regent ---

# AI-NOTE: This YAML file is the single source of truth for generating clean architecture layers.
# This is the MASTER TEMPLATE that will evolve to support all architectural layers.
#
# INTELLIGENT RLHF SCORING SYSTEM:
# The system uses Reinforcement Learning from Human Feedback to score execution quality:
# -2: CATASTROPHIC - Architecture violations, incorrect REPLACE/WITH format in refactor steps
# -1: RUNTIME ERROR - Lint failures, test failures, git operation problems
#  0: LOW CONFIDENCE - System is uncertain, avoids hallucinations
# +1: GOOD - Task complete but missing architectural elements
# +2: PERFECT - Exceptional quality with Clean Architecture, DDD principles, ubiquitous language
#
# QUALITY INDICATORS FOR +2 SCORE:
# - Uses ubiquitous language terminology
# - Follows Domain-Driven Design principles
# - Applies Clean Architecture concepts
# - Implements patterns: Aggregate Root, Value Objects, Domain Events
# - Perfect branch naming convention
# - Comprehensive PR descriptions
#
version: '3.0.0'
# AI-NOTE: Update these fields to describe the specific feature and layers.
metadata:
  title: '__FEATURE_NAME_PASCAL_CASE__ Clean Architecture Implementation'
  description: 'Clean Architecture template for __FEATURE_NAME_LOWER_CASE__ feature following master template rules.'
  source: 'TEMPLATE.yaml'
  # AI-NOTE: This should be replaced with the current date, e.g., YYYY-MM-DD.
  lastUpdated: '__CURRENT_DATE__'
  # AI-NOTE: Specify which layers are being implemented
  layers:
    - 'domain'
    # Future layers will be added here:
    # - 'data'
    # - 'infra'
    # - 'presentation'
    # - 'validation'
    # - 'main'
  # AI-NOTE: Define ubiquitous language for +2 RLHF score
  ubiquitousLanguage:
    - term: '__ENTITY_NAME__'
      definition: '__ENTITY_DEFINITION_IN_BUSINESS_CONTEXT__'
    - term: '__VALUE_OBJECT_NAME__'
      definition: '__VALUE_OBJECT_BUSINESS_MEANING__'
    - term: '__DOMAIN_EVENT__'
      definition: '__EVENT_BUSINESS_SIGNIFICANCE__'



# --- From: backend/01-structure.part.regent ---
  # AI-NOTE: Hybrid Architecture - "Feature Module with Use Case Slices"
  # Features are modules containing atomic use case slices for domain cohesion and generation safety

  structure:
    # Main application structure (entry point)
    app:
      basePath: '__PROJECT_NAME__/src'
      folders:
        - 'main'           # Application bootstrap and configuration
        - 'shared'         # Truly generic, app-wide shared code
        - 'features'       # Feature modules

    # Feature Module: Container for a business domain (e.g., user, product)
    # __FEATURE_NAME_KEBAB_CASE__ = user, product, etc.
    feature_module:
      basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__'

      # 1. Use Case Slices: Each folder is self-contained, atomic use case
      # __USE_CASE_NAME_KEBAB_CASE__ = create-user, delete-user, etc.
      use_case_slice:
        basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__'
        layers:
          domain:
            folders:
              - 'usecases'      # Interface for this specific use case
              - 'errors'        # Use case specific domain errors
            # Unit tests: create-user.ts + create-user.spec.ts (side by side)
          data:
            folders:
              - 'usecases'      # Implementation for this specific use case
            # Unit tests: db-create-user.ts + db-create-user.spec.ts (side by side)
          presentation:
            folders:
              - 'controllers'   # Controller for this specific use case
              - 'errors'        # HTTP errors specific to this use case
            # Unit tests: create-user-controller.ts + create-user-controller.spec.ts
          validation:
            folders:
              - 'validators'    # Validator for this specific use case
              - 'schemas'       # Schema for this specific use case
            # Unit tests: create-user-validator.spec.ts + create-user-schema.spec.ts
          main:
            folders:
              - 'factories'     # Factory for this specific use case
            # Unit tests: create-user-controller-factory.spec.ts
          # Integration and E2E tests only (not unit tests)
          __tests__:
            folders:
              - 'integration'   # Tests that cross layers
              - 'e2e'          # End-to-end tests

      # 2. Feature-Specific Shared: Code shared ONLY within this feature
      feature_shared:
        basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared'
        layers:
          domain:
            folders:
              - 'models'        # e.g., user-model.ts (shared by all user use cases)
              - 'repositories'  # e.g., user-repository.ts (interface)
              - 'errors'        # e.g., user-not-found-error.ts
              - 'value-objects' # e.g., email-value-object.ts
          infra:
            folders:
              - 'db'            # e.g., user-prisma-repository.ts (implementation)
          presentation:
            folders:
              - 'protocols'     # e.g., user-http-protocols.ts
              - 'errors'        # e.g., user-http-errors.ts

      # 3. Feature Main/Integration: Connects all slices to main application
      feature_main:
        basePath: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/main'
        folders:
          - 'routes'        # e.g., user-routes.ts (aggregates all use case routes)
          - 'config'        # Feature-level configuration
          - 'docs'          # Feature documentation

  # Integration between features and main application
  integration:
    main_server:
      basePath: '__PROJECT_NAME__/src/main'
      folders:
        - 'config'          # Server configuration (express, fastify, etc)
        - 'routes'          # Route aggregation from all features
        - 'middlewares'     # Global middlewares
        - 'adapters'        # Framework adapters
        - 'docs'            # API documentation (Swagger, etc)
      files:
        - 'server.ts'       # Main server file
        - 'app.ts'          # Application setup

    shared:
      basePath: '__PROJECT_NAME__/src/shared'
      layers:
        domain:
          folders:
            - 'errors'          # Base error classes
            - 'protocols'       # Domain contracts/interfaces
            - 'types'           # Shared domain types
            - 'value-objects'   # Shared value objects

        data:
          folders:
            - 'protocols'       # Data layer protocols
            - 'helpers'         # Data transformation helpers

        infra:
          folders:
            - 'cryptography'    # Shared encryption/hashing adapters (bcrypt, jwt)
            - 'http'            # Shared HTTP clients and adapters
            - 'validators'      # Shared validators (email, cpf, etc)
            - 'cache'           # Shared cache implementations (Redis, memory)
            - 'telemetry'       # Shared logging and monitoring
            - 'messaging'       # Shared message queue adapters

        presentation:
          folders:
            - 'protocols'       # Presentation protocols
            - 'helpers'         # Presentation helpers
            - 'middlewares'     # Shared middlewares

        main:
          folders:
            - 'adapters'        # Shared adapters
            - 'decorators'      # Shared decorators
            - 'factories'       # Shared factories

    # Example of Hybrid Architecture workflow
    use_case_example:
      # Task: "Generate create-user use case for user feature"
      # __FEATURE_NAME_KEBAB_CASE__ = user
      # __USE_CASE_NAME_KEBAB_CASE__ = create-user

      # STEP 1: Create Feature directories (if not exist)
      create_feature_structure:
        - 'src/features/user/'
        - 'src/features/user/shared/'     # Feature-specific shared code
        - 'src/features/user/main/'       # Feature integration

      # STEP 2: Create Use Case Slice directory (isolated)
      create_slice_directory:
        - 'src/features/user/create-user/' # Self-contained use case

      # STEP 3: Create NEW files (totally isolated within slice) WITH TESTS
      create_slice_files:
        # Domain layer with unit tests
        - 'src/features/user/create-user/domain/usecases/create-user.ts'
        - 'src/features/user/create-user/domain/usecases/create-user.spec.ts'
        - 'src/features/user/create-user/domain/errors/create-user-errors.ts'

        # Data layer with unit tests
        - 'src/features/user/create-user/data/usecases/db-create-user.ts'
        - 'src/features/user/create-user/data/usecases/db-create-user.spec.ts'

        # Presentation layer with unit tests
        - 'src/features/user/create-user/presentation/controllers/create-user-controller.ts'
        - 'src/features/user/create-user/presentation/controllers/create-user-controller.spec.ts'
        - 'src/features/user/create-user/presentation/errors/create-user-http-errors.ts'

        # Validation layer with unit tests
        - 'src/features/user/create-user/validation/validators/create-user-validator.ts'
        - 'src/features/user/create-user/validation/validators/create-user-validator.spec.ts'
        - 'src/features/user/create-user/validation/schemas/create-user-schema.ts'
        - 'src/features/user/create-user/validation/schemas/create-user-schema.spec.ts'

        # Main layer with unit tests
        - 'src/features/user/create-user/main/factories/create-user-controller-factory.ts'
        - 'src/features/user/create-user/main/factories/create-user-controller-factory.spec.ts'

        # Integration tests (cross-layer)
        - 'src/features/user/create-user/__tests__/integration/create-user.integration.spec.ts'

      # STEP 4: Check/Modify FEATURE-SPECIFIC shared code
      feature_shared_files:
        - create_if_not_exists: 'src/features/user/shared/domain/models/user-model.ts'
        - create_if_not_exists: 'src/features/user/shared/domain/repositories/user-repository.ts'
        - modify: 'src/features/user/shared/domain/repositories/user-repository.ts'
          action: 'Add add() method to interface'
        - create_if_not_exists: 'src/features/user/shared/infra/db/user-prisma-repository.ts'
        - modify: 'src/features/user/shared/infra/db/user-prisma-repository.ts'
          action: 'Implement add() method'

      # STEP 5: Integrate route
      integrate_route:
        - create_if_not_exists: 'src/features/user/main/routes/user-routes.ts'
        - modify: 'src/features/user/main/routes/user-routes.ts'
          action: 'Add POST /users route importing from ../create-user/main/factories'

      # RESULT: Perfect isolation
      # - Use case slice is completely isolated in its own directory
      # - Feature-specific shared code stays within the feature
      # - Global shared remains unpolluted
      # - Zero risk of affecting other use cases (delete-user, update-user)

    example_integration:
      # How features connect to the main application
      feature_route: 'src/features/user/main/routes/user-routes.ts'
      imports_to: 'src/main/routes/index.ts'

      use_case_factory: 'src/features/user/create-user/main/factories/create-user-controller-factory.ts'
      used_in: 'src/features/user/main/routes/user-routes.ts'

      feature_shared_model: 'src/features/user/shared/domain/models/user-model.ts'
      used_by_slices: 'src/features/user/*/domain/usecases/*.ts'

      global_shared_protocol: 'src/shared/protocols/http.ts'
      used_by_features: 'src/features/*/shared/presentation/protocols'



# --- From: backend/02-architecture.part.regent ---

  # ------------------------------------------------------------------------------
  # ARCHITECTURAL RULES SECTION
  # These rules define the Clean Architecture boundaries and dependencies
  # AI-NOTE: These rules are CRITICAL - any violation should trigger RLHF score: -2
  # AI-NOTE: Use these rules to validate generated code and refactoring decisions
  # ------------------------------------------------------------------------------

  architecture:
    folder_structure:
      use_case_slice: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__'
      feature_shared: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/shared'
      feature_main: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/main'
      global_shared: '__PROJECT_NAME__/src/shared'
      main_server: '__PROJECT_NAME__/src/main'

    execution_order:
      # AI-NOTE: Vertical slicing ensures atomic feature delivery
      # Each use case should be independently deployable and testable
      # Complete one use case through ALL layers before starting another
      description: 'Use cases are implemented vertically, crossing all layers atomically'
      approach: 'Vertical Slice Architecture - One use case at a time, through all layers'
      sequence_per_use_case:
        1: 'domain'     # Use case interface and models
        2: 'data'       # Use case implementation
        3: 'infra'      # Repository implementation (only if new repository needed in feature/shared)
        4: 'validation' # Input validation for the use case
        5: 'presentation' # Controller for the use case
        6: 'main'       # Factory and route integration
        7: 'integration' # Connect to feature main routes

      workflow_diagram: |
        ```mermaid
        graph TD
          Start([Start Use Case Implementation])

          %% Branch Creation
          B1[Create Branch: feat/__FEATURE_NAME__/__USE_CASE_NAME__]

          %% Use Case Slice - Vertical Development
          UC1[Create Use Case Directory Structure]

          %% Domain Slice
          D1[Create Domain Interface]
          D2[Write Domain Tests - TDD Red]
          D3[Run: yarn test:unit - Expect Failure]
          D4[Git Commit: 'test(domain): add __USE_CASE__ tests']

          %% Data Slice
          DT1[Implement Data Use Case]
          DT2[Write Data Tests]
          DT3[Run: yarn test:unit - Green]
          DT4[Git Commit: 'feat(data): implement __USE_CASE__']

          %% Infra Slice (if needed)
          %% AI-NOTE: Repository creation is CONDITIONAL
          %% Only create if no existing repository handles this entity
          I1[Check if Repository Exists]
          I2{Need New Repository?}
          I3[Implement Repository in Feature Shared]
          I4[Write Repository Tests]
          I5[Run: yarn test:unit - Green]
          I6[Git Commit: 'feat(infra): add repository for __USE_CASE__']

          %% Validation Slice
          V1[Create Validation Schema]
          V2[Create Validators]
          V3[Write Validation Tests]
          V4[Run: yarn test:unit - Green]
          V5[Git Commit: 'feat(validation): add __USE_CASE__ validation']

          %% Presentation Slice
          P1[Create Controller]
          P2[Write Controller Tests]
          P3[Run: yarn test:unit - Green]
          P4[Git Commit: 'feat(presentation): add __USE_CASE__ controller']

          %% Main Slice
          M1[Create Controller Factory]
          M2[Write Factory Tests]
          M3[Run: yarn test:unit - Green]
          M4[Git Commit: 'feat(main): add __USE_CASE__ factory']

          %% Feature Integration
          FI1[Update Feature Routes]
          FI2[Add Route for Use Case]
          FI3[Update API Documentation]
          FI4[Git Commit: 'feat(routes): integrate __USE_CASE__ route']

          %% Integration Testing
          IT1[Write Integration Tests]
          IT2[Run: yarn test:integration]
          IT3[Write E2E Tests]
          IT4[Run: yarn test:e2e]
          IT5[Git Commit: 'test(integration): add __USE_CASE__ integration tests']

          %% Final Steps
          F1[Run All Tests]
          F2[Run: yarn lint]
          F3[Run: yarn build]
          F4[Git Push: Push Branch]
          F5[Create PR: '__FEATURE__/__USE_CASE__ Implementation']

          End([Use Case Complete])

          %% Flow - Vertical Development Through Layers
          Start --> B1
          B1 --> UC1

          %% Domain Flow
          UC1 --> D1 --> D2 --> D3 --> D4

          %% Data Flow
          D4 --> DT1 --> DT2 --> DT3 --> DT4

          %% Infra Flow (conditional)
          DT4 --> I1 --> I2
          I2 -->|Yes| I3 --> I4 --> I5 --> I6
          I2 -->|No| V1
          I6 --> V1

          %% Validation Flow
          V1 --> V2 --> V3 --> V4 --> V5

          %% Presentation Flow
          V5 --> P1 --> P2 --> P3 --> P4

          %% Main Flow
          P4 --> M1 --> M2 --> M3 --> M4

          %% Feature Integration Flow
          M4 --> FI1 --> FI2 --> FI3 --> FI4

          %% Testing Flow
          FI4 --> IT1 --> IT2 --> IT3 --> IT4 --> IT5

          %% Final Flow
          IT5 --> F1 --> F2 --> F3 --> F4 --> F5 --> End

          classDef branch fill:#FFF9C4,stroke:#F57C00,stroke-width:2px
          classDef domain fill:#E8F5E9,stroke:#4CAF50,stroke-width:2px
          classDef data fill:#E3F2FD,stroke:#2196F3,stroke-width:2px
          classDef infra fill:#FFF3E0,stroke:#FF9800,stroke-width:2px
          classDef validation fill:#F3E5F5,stroke:#9C27B0,stroke-width:2px
          classDef presentation fill:#FCE4EC,stroke:#E91E63,stroke-width:2px
          classDef main fill:#E0F2F1,stroke:#009688,stroke-width:2px
          classDef integration fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px
          classDef testing fill:#FFEBEE,stroke:#F44336,stroke-width:2px
          classDef final fill:#E8EAF6,stroke:#3F51B5,stroke-width:2px

          class B1,UC1 branch
          class D1,D2,D3,D4 domain
          class DT1,DT2,DT3,DT4 data
          class I1,I2,I3,I4,I5,I6 infra
          class V1,V2,V3,V4,V5 validation
          class P1,P2,P3,P4 presentation
          class M1,M2,M3,M4 main
          class FI1,FI2,FI3,FI4 integration
          class IT1,IT2,IT3,IT4,IT5 testing
          class F1,F2,F3,F4,F5 final
        ```

      git_workflow_per_use_case:
        description: 'Vertical slice development - one complete use case at a time'
        example_use_case: 'create-user in user feature'

        workflow_steps:
          - 'git checkout -b feat/__FEATURE_NAME__/__USE_CASE_NAME__'
          - 'Create use case slice directory: src/features/__FEATURE_NAME__/__USE_CASE_NAME__'

        domain_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/domain/usecases/__USE_CASE__.ts'
          - 'Write domain tests (TDD - RED) → yarn test:unit (expect failure)'
          - 'git add → git commit -m "test(domain): add failing tests for __USE_CASE__"'
          - 'Create domain interface → yarn test:unit → yarn lint'
          - 'git add → git commit -m "feat(domain): add __USE_CASE__ interface"'

        data_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/data/usecases/db-__USE_CASE__.ts'
          - 'Implement use case → yarn test:unit (GREEN) → yarn lint'
          - 'git add → git commit -m "feat(data): implement __USE_CASE__"'

        infra_slice_if_needed:
          - 'IMPORTANT: Infra layer is NOT in use case slice - it goes in feature/shared'
          - 'Check if repository exists in: src/features/__FEATURE_NAME__/shared/infra/db/'
          - 'Only create new repository if needed for this use case:'
          - '  Create: src/features/__FEATURE_NAME__/shared/infra/db/__ENTITY__-repository.ts'
          - '  Write repository tests → yarn test:unit → yarn lint'
          - '  git add → git commit -m "feat(infra): add __ENTITY__ repository for __FEATURE__"'
          - 'If repository already exists, skip this step entirely'

        validation_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/validation/validators/__USE_CASE__-validator.ts'
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/validation/schemas/__USE_CASE__-schema.ts'
          - 'Write validation tests → yarn test:unit → yarn lint'
          - 'git add → git commit -m "feat(validation): add __USE_CASE__ validation"'

        presentation_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/presentation/controllers/__USE_CASE__-controller.ts'
          - 'Write controller tests (TDD) → yarn test:unit → yarn lint'
          - 'git add → git commit -m "feat(presentation): add __USE_CASE__ controller"'

        main_slice:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/main/factories/__USE_CASE__-controller-factory.ts'
          - 'Wire dependencies → yarn test:unit → yarn lint'
          - 'git add → git commit -m "feat(main): add __USE_CASE__ factory"'

        feature_integration:
          - 'Update: src/features/__FEATURE_NAME__/main/routes/__FEATURE__-routes.ts'
          - 'Add route for new use case → import factory from ../__USE_CASE_NAME__/main/factories'
          - 'Update API documentation if needed'
          - 'git add → git commit -m "feat(routes): integrate __USE_CASE__ route"'

        integration_testing:
          - 'Create: src/features/__FEATURE_NAME__/__USE_CASE_NAME__/__tests__/integration/__USE_CASE__.integration.spec.ts'
          - 'Write integration tests → yarn test:integration'
          - 'Write E2E tests if needed → yarn test:e2e'
          - 'git add → git commit -m "test(integration): add __USE_CASE__ integration tests"'

        finalization:
          - 'Run full test suite → yarn test'
          - 'Run linting → yarn lint'
          - 'Run build → yarn build'
          - 'git push origin feat/__FEATURE_NAME__/__USE_CASE_NAME__'
          - 'gh pr create --base main --title "feat(__FEATURE__): implement __USE_CASE__ use case"'

        benefits:
          - 'Atomic delivery: Each PR delivers a complete, working feature'
          - 'Reduced integration risk: No big bang integration at the end'
          - 'Faster feedback: Working software delivered incrementally'
          - 'Better testing: Each slice can be tested in isolation and integrated'
          - 'Cleaner git history: Each commit represents a logical unit of work'  

    dependency_rules:
      # AI-NOTE: Dependency direction is INWARD toward domain
      # Any outward dependency is a CRITICAL violation
      # Use these rules to validate imports in generated code
      domain:
        can_import_from: []  # Domain layer is the core - imports nothing
        cannot_import_from: ['data', 'infra', 'presentation', 'validation', 'main']
        notes: 'Domain defines business rules and contracts - must remain framework agnostic'

      data:
        can_import_from: ['domain']  # Data layer implements domain interfaces
        cannot_import_from: ['infra', 'presentation', 'validation', 'main']
        notes: 'Data orchestrates use cases but delegates infrastructure concerns to infra layer'

      infra:
        can_import_from: ['data', 'domain']  # Infrastructure implements data protocols
        cannot_import_from: ['presentation', 'main']
        notes: 'Infrastructure provides concrete implementations for data layer protocols'

      presentation:
        can_import_from: ['domain', 'validation']  # Presentation uses domain models and validation
        cannot_import_from: ['data', 'infra', 'main']
        notes: 'Presentation handles HTTP concerns - uses domain models and validation rules'

      validation:
        can_import_from: []  # Validation layer is independent - no imports
        cannot_import_from: ['domain', 'data', 'infra', 'presentation', 'main']
        notes: 'Validation is pure - implements generic validation interfaces, not presentation-specific'

      main:
        can_import_from: ['data', 'domain', 'infra', 'presentation', 'validation']  # Main layer composes everything
        cannot_import_from: []  # Main is the composition root
        notes: 'Main is the composition root - wires all dependencies and creates factories'

    # Clean Architecture principles and practices
    principles:
      core_principles:
        - "Independence: Business rules don't know about outside world"
        - "Testability: Business rules can be tested without UI, Database, Web Server, etc."
        - "Flexibility: UI, Database, and any external agency are plugins"
        - "Separation: Business rules are the core, everything else is detail"
        - "Dependency Rule: Dependencies point inward toward the domain"

      design_patterns:
        domain:
          - "Interface Pattern: Define contracts for use cases"
          - "ES2015 Modules: Use import/export for code organization"
          - "Type Exports: Separate types for Input and Output"
          - "Single Method Pattern: One execute() method per use case"
          - "Port Pattern: Define boundaries for external communication"
          - "DTO Pattern: Simple data transfer objects without behavior"

        data:
          - "Implementation Pattern: Concrete implementations of domain use cases"
          - "Repository Pattern: Define protocols for data persistence"
          - "Protocol Pattern: Abstractions for external dependencies (HTTP, DB, Crypto)"
          - "Dependency Injection: Constructor injection of protocols"
          - "Prefix Pattern: Use 'Db' or 'Remote' prefix for implementations"

        infra:
          - "Adapter Pattern: Implement data protocols (FetchHttpClient, PrismaAdapter)"
          - "Single HTTP Client: One FetchClient for all HTTP operations"
          - "ORM Pattern: Prisma for PostgreSQL + pgvector support"
          - "Cache Pattern: Redis adapter for caching strategies"
          - "Helper Pattern: Database and cache helpers for connections"

        presentation:
          - "Controller Pattern: Express controllers for REST API"
          - "Middleware Pattern: Express middleware pipeline"
          - "Helper Pattern: HTTP response helpers (ok, badRequest, etc.)"
          - "Protocol Pattern: Define controller and validation interfaces"
          - "Error Handling: Centralized error middleware"
          - "Request Validation: Input sanitization and validation"

        validation:
          - "Composite Pattern: Combine multiple field validators (ValidationComposite)"
          - "Builder Pattern: Fluent interface for validation construction (ValidationBuilder)"
          - "Factory Pattern: Create validation composites (makeLoginValidation, makeSignupValidation)"

        main:
          - "Factory Pattern: Create controllers with all dependencies (makeLoginController)"
          - "Decorator Pattern: Add logging and monitoring (LogControllerDecorator)"
          - "Adapter Pattern: Express route and middleware adapters"
          - "Composition Root: Wire up controllers, middlewares, and routes"
          - "Configuration Pattern: Centralized app, env, and swagger config"
          - "Dependency Injection: IoC container for dependency management"
          - "Route Aggregation: Collect routes from all features"

      testing_strategy:
        # AI-NOTE: Testing strategy varies by layer
        # Domain: Pure unit tests with no external dependencies
        # Data: Unit tests with mocked protocols
        # Infra: Integration tests with real databases
        domain:
          approach: "Unit Tests - Pure functions and business logic"
          coverage_target: "100%"
          tools: ["Vitest", "Testing Library"]
          practices:
            # AI-NOTE: NEVER use faker or random data in tests
            # Always use deterministic, fixed test data
            - "Use fixed test data helpers instead of faker"
            - "Create mock factories with deterministic data"
            - "Test domain models and use case interfaces"
            - "Use mockAddAccountParams() with fixed values"
            - "Keep test helpers in tests/domain/mocks directory"
            - "No external dependencies or randomness in tests"

        data:
          approach: "Unit Tests with Mocks"
          coverage_target: "95%"
          tools: ["Vitest", "vi.spyOn", "vi.fn"]
          practices:
            - "Create spy classes (HasherSpy, RepositorySpy)"
            - "Use makeSut() factory for test setup"
            - "Mock protocol implementations with classes"
            - "Use vi.spyOn() for spying on methods"
            - "Test error cases with throwError helper"
            - "Verify method calls and parameters"
            - "Use fixed test data from mocks directory"

        infra:
          approach: "Integration Tests"
          coverage_target: "80%"
          tools: ["Vitest", "Prisma test database", "Module mocking"]
          practices:
            - "Use vi.mock() to mock external modules (bcrypt, jsonwebtoken)"
            - "Test with Prisma test client and PostgreSQL"
            - "Clean database between tests with Prisma reset"
            - "Use makeSut() factory pattern"
            - "Mock localStorage with jsdom or happy-dom"
            - "Use vi.mock() for Fetch API mocking"
            - "Use fixed test data - no faker"

        presentation:
          approach: "Unit Tests for Controllers and Middlewares"
          coverage_target: "90%"
          tools: ["Vitest", "HTTP helpers (ok, badRequest, serverError)"]
          practices:
            - "Use spy classes (AuthenticationSpy, ValidationSpy)"
            - "Test controller handle() method"
            - "Use makeSut() factory with dependency injection"
            - "Test HTTP response helpers (ok, badRequest, unauthorized)"
            - "Mock requests with fixed data"
            - "Test error scenarios with throwError helper"
            - "Test middleware chain execution"
            - "Verify proper error propagation"

        validation:
          approach: "Unit Tests - Validation logic"
          coverage_target: "100%"
          tools: ["Vitest", "ValidationSpy for mocking"]
          practices:
            - "Test each validator independently (RequiredField, Email, MinLength)"
            - "Test ValidationComposite with multiple validators"
            - "Use makeSut() factory for validator creation"
            - "Test specific error types (MissingParamError, InvalidFieldError)"
            - "Test validation factories return correct composites"
            - "Test edge cases (empty fields, invalid formats)"
            - "Use fixed field names and error messages"

        main:
          approach: "E2E and Integration Tests"
          coverage_target: "70%"
          tools: ["Vitest", "Playwright", "MSW"]
          practices:
            - "Test complete user flows with Playwright"
            - "Test factory functions with Vitest"
            - "Mock HTTP layer with MSW"
            - "Verify dependency wiring"
            - "Use fixed test data for E2E scenarios"
            - "No faker in integration tests"

      best_practices:
        - "SOLID Principles: Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion"
        - "DRY: Don't Repeat Yourself - Extract common logic"
        - "KISS: Keep It Simple, Silly - Avoid over-engineering"
        - "YAGNI: You Aren't Gonna Need It - Build only what's needed"
        - "SOC: Separation of Concerns - Each layer has its responsibility"
        - "Small Commits: Make atomic, focused commits"
        - "Composition over Inheritance: Favor object composition"
        - "Conventional Commits: Use semantic commit messages"
        - "TDD: Write tests first, then implementation"
        - "Clean Code: Self-documenting, readable code"


# --- From: backend/03-rules.part.regent ---

  # ------------------------------------------------------------------------------
  # AI-NOTE: IMMUTABLE SECTIONS AHEAD.
  # The sections from here until 'steps' are architectural rules.
  # You MUST copy them verbatim into the implementation file without ANY modification.
  #
  # AUTOMATED LEARNING SYSTEM:
  # The RLHF system automatically:
  # - Tracks success/failure patterns across executions
  # - Identifies common error types and their fixes
  # - Applies improvements when confidence > 80%
  # - Generates learning reports with actionable insights
  # - Prevents hallucinations with score 0 for uncertain cases
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # RULES SECTION
  # All architectural and pattern rules consolidated
  # ------------------------------------------------------------------------------

  rules:
    # Domain layer rules (modern approach)
    domain:
      allowed:
        - 'Type definitions and interfaces (Models)'
        - 'Use case interfaces with single execute() method'
        - 'Separate Input and Output types for each use case'
        - 'Simple data models without behavior'
        - 'JSDoc documentation for all public interfaces'
        - 'ES2015 module exports (export type, export interface)'

      forbidden:
        - 'Multiple methods in a single use case interface'
        - 'Combined operations (e.g., CreateUserAndSendEmail)'
        - 'Framework dependencies (Express, third-party libraries)'
        - 'External libraries (HTTP or database clients)'
        - 'Implementation details of any kind'
        - 'UI components or presentation logic'
        - 'HTTP/Database/File system operations'
        - 'Environment variables or configuration'
        - 'Console.log or any I/O operations'
        - 'Implementation of business logic (only interfaces allowed)'
        - 'Validation implementations'
        - 'Error throwing or handling'
        - 'Dependency injection'
        - 'Domain entities with methods/behavior (use simple data structures)'

      should:
        - 'Define business entities and value objects'
        - 'Contain only interfaces and types'
        - 'Be framework-agnostic'
        - 'Follow domain-driven design principles'

      should_not:
        - 'Import from other layers'
        - 'Contain implementation details'
        - 'Have framework dependencies'
      use_case:
        should:
          - 'Have only ONE execute() method per interface'
          - 'Define separate Input and Output types'
          - 'Have EXACTLY ONE responsibility (one business operation)'
          - 'Be named with single verb describing ONE action (__USE_CASE_NAME__, not __USE_CASE_NAME__And__OTHER_ACTION__)'
          - 'Include comprehensive JSDoc documentation'
          - 'Return Promise<Output> from execute method'
          - 'Be framework agnostic'
          - 'Follow naming convention: VerbNoun (e.g., __USE_CASE_EXAMPLE_1__, __USE_CASE_EXAMPLE_2__, __USE_CASE_EXAMPLE_3__)'
        should_not:
          - 'Have multiple methods (no __METHOD_1__() AND __METHOD_2__() in same interface)'
          - 'Combine multiple operations (__USE_CASE_NAME__And__OTHER_ACTION__ violates SRP)'
          - 'Contain implementation logic'
          - 'Know about HTTP, databases, or external services'
          - 'Import from data, presentation, or infrastructure layers'
          - 'Have side effects'
          - 'Use generic method names like handle(), process(), or run()'

    # Data layer rules
    data:
      should:
        - 'Implement domain use case interfaces'
        - 'Use constructor injection for dependencies'
        - 'Define protocols for external dependencies'
        - 'Use prefix naming (Db__USE_CASE_NAME__, Remote__USE_CASE_NAME__)'
        - 'Handle errors and status codes appropriately'
        - 'Keep business logic minimal (only orchestration)'
        - 'Return domain types, not infrastructure types'

      should_not:
        - 'Import from infrastructure layer directly'
        - 'Contain complex business logic (belongs in domain)'
        - 'Expose infrastructure details to domain'
        - 'Use concrete implementations instead of protocols'
        - 'Have direct database or HTTP calls (use protocols)'

    # Infrastructure layer rules
    infra:
      should:
        - 'Implement data layer protocols'
        - 'Use native Fetch API instead of axios'
        - 'Use Prisma ORM for database operations'
        - 'Support PostgreSQL with pgvector extension'
        - 'Use Redis for caching when needed'
        - 'Provide single FetchHttpClient for all HTTP needs'
        - 'Handle connection management and retries'
        - 'Use environment variables for configuration'

      should_not:
        - 'Import from domain or use case layers'
        - 'Contain business logic'
        - 'Use multiple HTTP client implementations'
        - 'Expose database-specific types to other layers'
        - 'Use axios or other HTTP libraries (use Fetch API)'
        - 'Use MongoDB (use Prisma with PostgreSQL)'

    # Presentation layer rules
    presentation:
      should:
        - 'Use Express for HTTP server and routing'
        - 'Implement Controller interface with handle method'
        - 'Return standardized HTTP responses (ok, badRequest, etc.)'
        - 'Use middlewares for cross-cutting concerns'
        - 'Handle errors gracefully with try/catch'
        - 'Validate requests before processing'
        - 'Use RESTful API design principles'
        - 'Implement proper HTTP status codes'

      should_not:
        - 'Use GraphQL (use REST with Express)'
        - 'Import from data or infra layers directly'
        - 'Contain business logic (belongs in use cases)'
        - 'Make direct HTTP calls (use data layer)'
        - 'Expose internal implementation details'
        - 'Implement middleware that does not follow the Express middleware signature (req, res, next)'

    # Error rules
    error:
      should:
        - 'Extend the native Error class'
        - 'Have descriptive names ending with Error'
        - 'Contain meaningful error messages'
        - 'Represent business rule violations'
        - 'Be thrown when domain invariants are violated'

      should_not:
        - 'Contain HTTP status codes'
        - 'Include technical/implementation details'
        - 'Expose sensitive information'
        - 'Import external dependencies'

    # Test helper rules
    test_helper:
      should:
        - 'Create mock/stub implementations of use cases'
        - 'Generate fake test data'
        - 'Be pure functions that return consistent data'
        - 'Help reduce test boilerplate'
        - 'Use ONLY Vitest (Jest is prohibited)'

      should_not:
        - 'Make real API calls or database queries'
        - 'Depend on external services'
        - 'Contain test assertions (those belong in test files)'
        - 'Have side effects or maintain state'
        - 'Use Jest (use Vitest instead)'

    # Validation rules
    validation:
      should:
        - 'Implement FieldValidation interface for field validators'
        - 'Use ValidationComposite to combine multiple validators'
        - 'Use ValidationBuilder for fluent validation construction'
        - 'Create factory functions for validation composites'
        - 'Validate individual fields with specific rules'
        - 'Return descriptive error messages'
        - 'Support chaining of validation rules'
        - 'Use static build() method for composite creation'
      should_not:
        - 'Import from domain layer'
        - 'Import from data or infra layers'
        - 'Contain business logic (only validation rules)'
        - 'Throw exceptions (return Error objects instead)'
        - 'Access external services or databases'
        - 'Use async validation (keep validators synchronous)'

    # Main layer rules
    main:
      should:
        - 'Create factory functions for controllers'
        - 'Wire up all dependencies using composition'
        - 'Apply decorators for cross-cutting concerns (logging, monitoring)'
        - 'Configure Express routes and middlewares'
        - 'Setup Swagger documentation'
        - 'Handle environment configuration'
        - 'Use adapters for framework integration'
        - 'Return decorated controllers from factories'
        - 'Setup dependency injection container'
        - 'Configure database connections and migrations'
        - 'Initialize monitoring and health checks'

      should_not:
        - 'Contain business logic (only wiring)'
        - 'Have direct database or API calls'
        - 'Include complex algorithms or calculations'
        - 'Store application state'
        - 'Define new interfaces or types (only use existing ones)'
        - 'Handle request/response logic (belongs in presentation)'

    # Reference patterns
    reference_patterns:
      clean_architecture:
        type: 'external_pattern'
        source: 'context7'
        query: 'clean architecture use case'
        url: 'https://github.com/...'
        description: 'Following Clean Architecture pattern.'

      ddd_pattern:
        type: 'external_pattern'
        source: 'context7'
        query: 'domain driven design'
        url: 'https://github.com/...'
        description: 'Following DDD patterns.'

      tdd_pattern:
        type: 'external_pattern'
        source: 'context7'
        query: 'test driven development'
        url: 'https://github.com/...'
        description: 'Following TDD patterns.'

    # Learning patterns
    learning_patterns:
      common_errors:
        - pattern: 'import axios'
          fix: 'Use Fetch API instead of axios in infra layer'
          score_impact: -2

        - pattern: '__USE_CASE_NAME__And__OTHER_ACTION__'
          fix: 'Split into two separate use cases (SRP violation)'
          score_impact: -1

        - pattern: 'missing @domainConcept'
          fix: 'Add domain concept documentation for +2 score'
          score_impact: +1

      success_indicators:
        - 'Uses ubiquitous language consistently'
        - 'Follows single responsibility principle'
        - 'No dependency violations'
        - 'Comprehensive test coverage'
        - 'Clean git history with atomic commits'

    # Required protocols for all layers
    required_protocols:
      # Domain Layer
      domain:
        - 'All use cases must have single execute() method'
        - 'All use cases must define separate Input and Output types'
        - 'All domain types must be immutable'
        - 'No use case can perform multiple operations (SRP)'
        - 'All models must be simple DTOs without behavior'

      # Data Layer
      data:
        - 'All implementations must inject dependencies via constructor'
        - 'All protocols must be interfaces, not concrete classes'
        - 'All implementations must use Db or Remote prefix'
        - 'Must return domain types, not infrastructure types'
        - 'Must handle errors and map status codes appropriately'

      # Infrastructure Layer
      infra:
        - 'All adapters must implement data layer protocols'
        - 'HTTP clients must use Fetch API, not axios'
        - 'Database repositories must use Prisma with PostgreSQL'
        - 'All external configs must come from environment variables'
        - 'Must not expose infrastructure types to other layers'

      # Presentation Layer
      presentation:
        - 'Controllers must implement handle() method'
        - 'Controllers must return HTTP helpers (ok, badRequest, etc.)'
        - 'Middlewares must implement handle() with next parameter'
        - 'Request handlers must validate input before processing'
        - 'Response handlers must use standard HTTP status codes'

      # Validation Layer
      validation:
        - 'All validators must implement FieldValidation interface'
        - 'Validators must return Error or undefined'
        - 'ValidationComposite must use static build() method'
        - 'Validation must be synchronous (no async/await)'
        - 'Factory functions must return ValidationComposite (make__USE_CASE_NAME__Validation)'

      # Main Layer
      main:
        - 'All factories must return configured instances'
        - 'Factory functions must wire all dependencies'
        - 'No business logic allowed (only composition)'
        - 'Routes must use adapter pattern for framework integration'
        - 'Must not define new types (use existing from other layers)'

      # Cross-cutting Concerns
      general:
        - 'All public interfaces must have JSDoc documentation'
        - 'All errors must extend native Error class'
        - 'All test helpers must be pure functions'
        - 'All tests must use Vitest, not Jest'
        - 'No use of faker - fixed test data only'

    # Documentation standards (JSDoc)
    documentation:
      # Domain Layer Documentation
      domain:
        use_case_interface:
          - '@description - Clear description of the use case purpose'
          - '@example - Usage example with execute() method'
          - '@see - Reference to related use cases or documentation'
        input_output_types:
          - '@typedef - Define Input and Output types'
          - '@property - Document each field with type and constraints'
          - '@example - Show valid input/output instances'
        model_type:
          - '@typedef - Define the domain model'
          - '@property - Document each property with business rules'
          - '@example - Show valid model instance'

      # Data Layer Documentation
      data:
        protocol_interface:
          - '@interface - Define protocol contracts'
          - '@method - Document each method signature'
          - '@throws - Document possible errors'
        implementation_class:
          - '@class - Describe the use case implementation'
          - '@implements - List implemented interfaces'
          - '@constructor - Document dependency injection'
          - '@method - Document orchestration logic'

      # Infrastructure Layer Documentation
      infra:
        adapter_class:
          - '@class - Describe the adapter purpose'
          - '@implements - Protocol being implemented'
          - '@dependency - External libraries used'
        database_repository:
          - '@class - Repository implementation'
          - '@method - Document CRUD operations'
          - '@throws - Database-specific errors'
        http_client:
          - '@class - HTTP client implementation'
          - '@method - Document request/response handling'
          - '@throws - Network-related errors'

      # Presentation Layer Documentation
      presentation:
        controller:
          - '@class - Controller description'
          - '@route - HTTP route and method'
          - '@param - Request parameters'
          - '@returns - HTTP response format'
          - '@throws - HTTP error responses'
        middleware:
          - '@function - Middleware purpose'
          - '@param - Request, Response, Next'
          - '@throws - Authorization/validation errors'
        route_handler:
          - '@function - Route handler description'
          - '@param - Request and response objects'
          - '@returns - HTTP response with status and data'
          - '@throws - HTTP error responses'

      # Validation Layer Documentation
      validation:
        validator_class:
          - '@class - Validator description'
          - '@implements - FieldValidation interface'
          - '@method - validate() method logic'
          - '@returns - Error or undefined'
        composite:
          - '@class - ValidationComposite'
          - '@method - Combines multiple validators'
          - '@returns - First error found or undefined'

      # Main Layer Documentation
      main:
        factory:
          - '@function - Factory function description'
          - '@returns - Configured instance with dependencies'
          - '@example - How to use the factory'
        route:
          - '@function - Route configuration'
          - '@param - Express router instance'
          - '@middleware - Applied middlewares'
        composition:
          - '@function - Dependency composition'
          - '@returns - Fully configured instance with dependencies injected'

      example_template: |
        /**
        * @description __USE_CASE_DESCRIPTION__
        * @example
        * const __USE_CASE_NAME_CAMEL_CASE__ = new __USE_CASE_NAME_PASCAL_CASE__Impl(__DEPENDENCY_NAME__)
        * const result = await __USE_CASE_NAME_CAMEL_CASE__.execute({
        *   __INPUT_FIELD_1__: '__EXAMPLE_VALUE_1__',
        *   __INPUT_FIELD_2__: '__EXAMPLE_VALUE_2__',
        *   __INPUT_FIELD_3__: '__EXAMPLE_VALUE_3__'
        * })
        * @see {@link __RELATED_USE_CASE__} for __RELATED_DESCRIPTION__
        */
        export interface __USE_CASE_NAME_PASCAL_CASE__ {
          execute(input: __USE_CASE_NAME_PASCAL_CASE__Input): Promise<__USE_CASE_NAME_PASCAL_CASE__Output>
        }

        /**
        * @typedef {Object} __USE_CASE_NAME_PASCAL_CASE__Input
        * @property {string} __INPUT_FIELD_1__ - __FIELD_1_DESCRIPTION__ (__FIELD_1_CONSTRAINTS__)
        * @property {string} __INPUT_FIELD_2__ - __FIELD_2_DESCRIPTION__
        * @property {string} __INPUT_FIELD_3__ - __FIELD_3_DESCRIPTION__ (__FIELD_3_CONSTRAINTS__)
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Input = {
          __INPUT_FIELD_1__: string
          __INPUT_FIELD_2__: string
          __INPUT_FIELD_3__: string
        }

        /**
        * @typedef {Object} __USE_CASE_NAME_PASCAL_CASE__Output
        * @property {string} __OUTPUT_FIELD_1__ - __OUTPUT_FIELD_1_DESCRIPTION__
        * @property {string} __OUTPUT_FIELD_2__ - __OUTPUT_FIELD_2_DESCRIPTION__
        * @property {string} __OUTPUT_FIELD_3__ - __OUTPUT_FIELD_3_DESCRIPTION__
        * @property {Date} __TIMESTAMP_FIELD__ - __TIMESTAMP_DESCRIPTION__
        */
        export type __USE_CASE_NAME_PASCAL_CASE__Output = {
          __OUTPUT_FIELD_1__: string
          __OUTPUT_FIELD_2__: string
          __OUTPUT_FIELD_3__: string
          __TIMESTAMP_FIELD__: Date
        }



# --- From: backend/steps/05-main.part.regent ---
# ------------------------------------------------------------------------------
# BACKEND MAIN LAYER TEMPLATE
# Clean Architecture - Application Bootstrap and Composition Root
# Supports: Express/Fastify with Dependency Injection
# Pattern: TDD with Factory Pattern and Adapters
# ------------------------------------------------------------------------------

metadata:
  layer: 'main'
  project_type: 'backend'
  architecture_style: 'clean'
  test_approach: 'tdd'
  framework: 'express' # express | fastify - AI-NOTE: Replace with actual framework
  patterns:
    - 'composition-root'
    - 'factory-pattern'
    - 'adapter-pattern'
    - 'dependency-injection'
  references:
    - 'Clean Architecture principles'
    - 'SOLID principles'
    - 'Dependency Injection pattern'
    - 'Factory Method pattern'

# ------------------------------------------------------------------------------
# MAIN LAYER STRUCTURE
# ------------------------------------------------------------------------------

structure:
  main_structure:
    description: 'Setup main layer structure for application bootstrap'
    folders:
      - 'src/main'
      - 'src/main/config'
      - 'src/main/adapters'
      - 'src/main/factories'
      - 'src/main/middlewares'
      - 'src/main/docs'
      - 'src/main/routes'
      - 'tests/main'
      - 'tests/main/routes'
      - 'tests/main/middlewares'

# ------------------------------------------------------------------------------
# MAIN LAYER IMPLEMENTATION STEPS
# Following TDD and Factory Pattern
# ------------------------------------------------------------------------------

steps:
  main_steps:
    # === STEP 1: CREATE MAIN BRANCH ===
    - id: 'create-main-branch'
      type: 'validation'
      description: 'Create feature branch for main layer implementation'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      run_scripts:
        description: 'Create and checkout main layer branch'
        scripts:
          - name: 'Create main branch'
            command: |
              git checkout -b "feat/__FEATURE_NAME_KEBAB_CASE__-main-layer"
              echo "✅ Created branch: feat/__FEATURE_NAME_KEBAB_CASE__-main-layer"
            workingDirectory: '__PROJECT_NAME__'

    # === STEP 2: CREATE ENVIRONMENT CONFIGURATION ===
    - id: 'create-env-config'
      type: 'create_file'
      description: 'Create environment configuration'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/config/env.ts'
      template: |
        /**
         * Environment configuration
         * @layer Main Layer
         * @pattern Configuration Pattern
         */
        export default {
          port: process.env.PORT || 3000,
          nodeEnv: process.env.NODE_ENV || 'development',
          mongoUrl: process.env.MONGO_URL || 'mongodb://localhost:27017/__PROJECT_NAME__',
          postgresUrl: process.env.DATABASE_URL || 'postgresql://user:pass@localhost:5432/__PROJECT_NAME__',
          redisUrl: process.env.REDIS_URL || 'redis://localhost:6379',
          jwtSecret: process.env.JWT_SECRET || 'secret',
          apiPrefix: process.env.API_PREFIX || '/api',
          corsOrigin: process.env.CORS_ORIGIN || '*',
          rateLimitWindow: parseInt(process.env.RATE_LIMIT_WINDOW || '900000'), // 15 minutes
          rateLimitMax: parseInt(process.env.RATE_LIMIT_MAX || '100')
        }

    # === STEP 3: CREATE EXPRESS/FASTIFY ADAPTER ===
    - id: 'create-route-adapter'
      type: 'create_file'
      description: 'Create route adapter for framework'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/adapters/__FRAMEWORK__-route-adapter.ts'
      template: |
        import { Controller, HttpRequest } from '@/presentation/protocols'
        // AI-NOTE: Import based on framework
        // Express: import { Request, Response } from 'express'
        // Fastify: import { FastifyRequest, FastifyReply } from 'fastify'

        /**
         * Adapts Controller to __FRAMEWORK__ route handler
         * @layer Main Layer - Adapter
         * @pattern Adapter Pattern
         */
        export const adaptRoute = (controller: Controller) => {
          // AI-NOTE: Express implementation
          // return async (req: Request, res: Response) => {
          //   const httpRequest: HttpRequest = {
          //     body: req.body,
          //     params: req.params,
          //     query: req.query,
          //     headers: req.headers,
          //     accountId: req.accountId
          //   }
          //
          //   const httpResponse = await controller.handle(httpRequest)
          //
          //   if (httpResponse.statusCode >= 200 && httpResponse.statusCode <= 299) {
          //     res.status(httpResponse.statusCode).json(httpResponse.body)
          //   } else {
          //     res.status(httpResponse.statusCode).json({
          //       error: httpResponse.body.message
          //     })
          //   }
          // }

          // AI-NOTE: Fastify implementation
          // return async (request: FastifyRequest, reply: FastifyReply) => {
          //   const httpRequest: HttpRequest = {
          //     body: request.body,
          //     params: request.params,
          //     query: request.query,
          //     headers: request.headers,
          //     accountId: request.accountId
          //   }
          //
          //   const httpResponse = await controller.handle(httpRequest)
          //
          //   return reply
          //     .status(httpResponse.statusCode)
          //     .send(httpResponse.statusCode >= 200 && httpResponse.statusCode <= 299
          //       ? httpResponse.body
          //       : { error: httpResponse.body.message })
          // }
        }

    # === STEP 4: CREATE MIDDLEWARE ADAPTER ===
    - id: 'create-middleware-adapter'
      type: 'create_file'
      description: 'Create middleware adapter for framework'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/adapters/__FRAMEWORK__-middleware-adapter.ts'
      template: |
        import { Middleware, HttpRequest } from '@/presentation/protocols'
        // AI-NOTE: Import based on framework
        // Express: import { Request, Response, NextFunction } from 'express'
        // Fastify: import { FastifyRequest, FastifyReply } from 'fastify'

        /**
         * Adapts Middleware to __FRAMEWORK__ middleware handler
         * @layer Main Layer - Adapter
         * @pattern Adapter Pattern
         */
        export const adaptMiddleware = (middleware: Middleware) => {
          // AI-NOTE: Express implementation
          // return async (req: Request, res: Response, next: NextFunction) => {
          //   const httpRequest: HttpRequest = {
          //     headers: req.headers,
          //     body: req.body,
          //     params: req.params,
          //     query: req.query
          //   }
          //
          //   const httpResponse = await middleware.handle(httpRequest)
          //
          //   if (httpResponse.statusCode === 200) {
          //     Object.assign(req, httpResponse.body)
          //     next()
          //   } else {
          //     res.status(httpResponse.statusCode).json({
          //       error: httpResponse.body.message
          //     })
          //   }
          // }

          // AI-NOTE: Fastify implementation
          // return async (request: FastifyRequest, reply: FastifyReply) => {
          //   const httpRequest: HttpRequest = {
          //     headers: request.headers,
          //     body: request.body,
          //     params: request.params,
          //     query: request.query
          //   }
          //
          //   const httpResponse = await middleware.handle(httpRequest)
          //
          //   if (httpResponse.statusCode === 200) {
          //     Object.assign(request, httpResponse.body)
          //   } else {
          //     reply.status(httpResponse.statusCode).send({
          //       error: httpResponse.body.message
          //     })
          //   }
          // }
        }

    # === STEP 5: CREATE CONTROLLER FACTORY ===
    - id: 'create-controller-factory'
      type: 'create_file'
      description: 'Create controller factory with dependency injection'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/main/factories/__USE_CASE_NAME_KEBAB_CASE__-controller-factory.ts'
      template: |
        import { Controller } from '@/presentation/protocols'
        import { __USE_CASE_NAME_PASCAL_CASE__Controller } from '@/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/presentation/controllers'
        import { makeDb__USE_CASE_NAME_PASCAL_CASE__ } from './usecases/__USE_CASE_NAME_KEBAB_CASE__-factory'
        import { make__USE_CASE_NAME_PASCAL_CASE__Validation } from './validation/__USE_CASE_NAME_KEBAB_CASE__-validation-factory'
        import { makeLogControllerDecorator } from '@/main/factories/decorators'

        /**
         * Factory for __USE_CASE_NAME_PASCAL_CASE__ Controller
         * @layer Main Layer - Factory
         * @pattern Factory Pattern, Dependency Injection
         */
        export const make__USE_CASE_NAME_PASCAL_CASE__Controller = (): Controller => {
          const useCase = makeDb__USE_CASE_NAME_PASCAL_CASE__()
          const validation = make__USE_CASE_NAME_PASCAL_CASE__Validation()
          const controller = new __USE_CASE_NAME_PASCAL_CASE__Controller(useCase, validation)

          // Apply decorators
          return makeLogControllerDecorator(controller)
        }

    # === STEP 6: CREATE USE CASE FACTORY ===
    - id: 'create-usecase-factory'
      type: 'create_file'
      description: 'Create use case factory with repository injection'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/main/factories/usecases/__USE_CASE_NAME_KEBAB_CASE__-factory.ts'
      template: |
        import { __USE_CASE_NAME_PASCAL_CASE__ } from '@/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/domain/usecases'
        import { Db__USE_CASE_NAME_PASCAL_CASE__ } from '@/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/data/usecases'
        import { __FEATURE_NAME_PASCAL_CASE__MongoRepository } from '@/features/__FEATURE_NAME_KEBAB_CASE__/shared/infra/db'
        // AI-NOTE: Import other dependencies as needed

        /**
         * Factory for __USE_CASE_NAME_PASCAL_CASE__ Use Case
         * @layer Main Layer - Factory
         * @pattern Factory Pattern, Dependency Injection
         */
        export const makeDb__USE_CASE_NAME_PASCAL_CASE__ = (): __USE_CASE_NAME_PASCAL_CASE__ => {
          const repository = new __FEATURE_NAME_PASCAL_CASE__MongoRepository()
          // AI-NOTE: Add other dependencies
          // const cacheRepository = new RedisCacheRepository()
          // const httpClient = new FetchHttpClient()

          return new Db__USE_CASE_NAME_PASCAL_CASE__(repository)
        }

    # === STEP 7: CREATE VALIDATION FACTORY ===
    - id: 'create-validation-factory'
      type: 'create_file'
      description: 'Create validation factory for use case'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/__USE_CASE_NAME_KEBAB_CASE__/main/factories/validation/__USE_CASE_NAME_KEBAB_CASE__-validation-factory.ts'
      template: |
        import { Validation } from '@/presentation/protocols'
        import {
          ValidationComposite,
          RequiredFieldValidation,
          EmailValidation,
          MinLengthValidation
        } from '@/validation/validators'
        import { EmailValidatorAdapter } from '@/infra/validators'

        /**
         * Factory for __USE_CASE_NAME_PASCAL_CASE__ Validation
         * @layer Main Layer - Factory
         * @pattern Factory Pattern, Composite Pattern
         */
        export const make__USE_CASE_NAME_PASCAL_CASE__Validation = (): Validation => {
          const validations: Validation[] = []

          // AI-NOTE: Configure validations based on use case requirements
          // Required fields
          const requiredFields = ['name', 'email']
          for (const field of requiredFields) {
            validations.push(new RequiredFieldValidation(field))
          }

          // Email validation
          validations.push(new EmailValidation('email', new EmailValidatorAdapter()))

          // Other validations
          validations.push(new MinLengthValidation('password', 8))

          return new ValidationComposite(validations)
        }

    # === STEP 8: CREATE FEATURE ROUTES ===
    - id: 'create-feature-routes'
      type: 'create_file'
      description: 'Create routes for feature use cases'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/features/__FEATURE_NAME_KEBAB_CASE__/main/routes/__FEATURE_NAME_KEBAB_CASE__-routes.ts'
      template: |
        import { adaptRoute } from '@/main/adapters'
        import { make__USE_CASE_NAME_PASCAL_CASE__Controller } from '../__USE_CASE_NAME_KEBAB_CASE__/main/factories'
        // AI-NOTE: Import other use case controllers

        // Express: import { Router } from 'express'
        // Fastify: import { FastifyInstance } from 'fastify'

        /**
         * Routes for __FEATURE_NAME_PASCAL_CASE__ feature
         * @layer Main Layer - Routes
         * @pattern Route Aggregation
         */
        // Express implementation
        // export default (router: Router): void => {
        //   router.post('/__FEATURE_NAME_KEBAB_CASE__', adaptRoute(make__USE_CASE_NAME_PASCAL_CASE__Controller()))
        //   // AI-NOTE: Add other routes
        // }

        // Fastify implementation
        // export default async (app: FastifyInstance): Promise<void> => {
        //   app.post('/__FEATURE_NAME_KEBAB_CASE__', adaptRoute(make__USE_CASE_NAME_PASCAL_CASE__Controller()))
        //   // AI-NOTE: Add other routes
        // }

    # === STEP 9: CREATE MIDDLEWARE SETUP ===
    - id: 'create-middleware-setup'
      type: 'create_file'
      description: 'Create middleware configuration'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/config/middlewares.ts'
      template: |
        // Express: import { Express } from 'express'
        // Fastify: import { FastifyInstance } from 'fastify'
        import { bodyParser, cors, contentType, noCache } from '@/main/middlewares'

        /**
         * Setup global middlewares
         * @layer Main Layer - Configuration
         * @pattern Middleware Chain
         */
        // Express implementation
        // export default (app: Express): void => {
        //   app.use(bodyParser)
        //   app.use(cors)
        //   app.use(contentType)
        //   app.use(noCache)
        // }

        // Fastify implementation
        // export default async (app: FastifyInstance): Promise<void> => {
        //   await app.register(require('@fastify/cors'), { origin: true })
        //   await app.register(require('@fastify/helmet'))
        //   await app.register(require('@fastify/rate-limit'), {
        //     max: 100,
        //     timeWindow: '15 minutes'
        //   })
        // }

    # === STEP 10: CREATE ROUTE AGGREGATOR ===
    - id: 'create-route-aggregator'
      type: 'create_file'
      description: 'Create route aggregator to load all feature routes'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/config/routes.ts'
      template: |
        // Express: import { Express, Router } from 'express'
        // Fastify: import { FastifyInstance } from 'fastify'
        import { readdirSync } from 'fs'
        import { join } from 'path'
        import env from './env'

        /**
         * Dynamic route loader
         * @layer Main Layer - Configuration
         * @pattern Route Aggregation
         */
        // Express implementation
        // export default (app: Express): void => {
        //   const router = Router()
        //   app.use(env.apiPrefix, router)
        //
        //   // Load all feature routes dynamically
        //   const featuresDir = join(__dirname, '../../features')
        //   readdirSync(featuresDir).forEach(feature => {
        //     const routesPath = join(featuresDir, feature, 'main/routes')
        //     if (existsSync(routesPath)) {
        //       readdirSync(routesPath).forEach(async file => {
        //         if (!file.endsWith('.map')) {
        //           (await import(join(routesPath, file))).default(router)
        //         }
        //       })
        //     }
        //   })
        // }

        // Fastify implementation
        // export default async (app: FastifyInstance): Promise<void> => {
        //   // Load all feature routes dynamically
        //   const featuresDir = join(__dirname, '../../features')
        //   const features = readdirSync(featuresDir)
        //
        //   for (const feature of features) {
        //     const routesPath = join(featuresDir, feature, 'main/routes')
        //     if (existsSync(routesPath)) {
        //       const files = readdirSync(routesPath)
        //       for (const file of files) {
        //         if (!file.endsWith('.map')) {
        //           await app.register(
        //             (await import(join(routesPath, file))).default,
        //             { prefix: env.apiPrefix }
        //           )
        //         }
        //       }
        //     }
        //   }
        // }

    # === STEP 11: CREATE APPLICATION SETUP ===
    - id: 'create-app-setup'
      type: 'create_file'
      description: 'Create application setup and configuration'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/config/app.ts'
      template: |
        import setupMiddlewares from './middlewares'
        import setupRoutes from './routes'
        import setupSwagger from './swagger'
        // Express: import express, { Express } from 'express'
        // Fastify: import fastify, { FastifyInstance } from 'fastify'

        /**
         * Application setup
         * @layer Main Layer - Configuration
         * @pattern Application Bootstrap
         */
        // Express implementation
        // export const setupApp = async (): Promise<Express> => {
        //   const app = express()
        //
        //   setupSwagger(app)
        //   setupMiddlewares(app)
        //   setupRoutes(app)
        //
        //   return app
        // }

        // Fastify implementation
        // export const setupApp = async (): Promise<FastifyInstance> => {
        //   const app = fastify({
        //     logger: true,
        //     trustProxy: true
        //   })
        //
        //   await setupSwagger(app)
        //   await setupMiddlewares(app)
        //   await setupRoutes(app)
        //
        //   return app
        // }

    # === STEP 12: CREATE SERVER ENTRY POINT ===
    - id: 'create-server'
      type: 'create_file'
      description: 'Create server entry point'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/server.ts'
      template: |
        import 'module-alias/register'
        import env from './config/env'
        // AI-NOTE: Import database helper
        // import { MongoHelper } from '@/infra/db/mongodb'
        // import { PrismaHelper } from '@/infra/db/prisma'

        /**
         * Server entry point
         * @layer Main Layer - Bootstrap
         * @pattern Application Entry Point
         */
        async function bootstrap() {
          try {
            // Connect to database
            // await MongoHelper.connect(env.mongoUrl)
            // await PrismaHelper.connect()

            console.log('✅ Database connected')

            // Setup and start application
            const { setupApp } = await import('./config/app')
            const app = await setupApp()

            // Express
            // app.listen(env.port, () => {
            //   console.log(`🚀 Server running at http://localhost:${env.port}`)
            // })

            // Fastify
            // await app.listen({ port: env.port, host: '0.0.0.0' })
            // console.log(`🚀 Server running at http://localhost:${env.port}`)

          } catch (error) {
            console.error('❌ Server failed to start:', error)
            process.exit(1)
          }
        }

        bootstrap()

    # === STEP 13: CREATE LOG DECORATOR FACTORY ===
    - id: 'create-log-decorator-factory'
      type: 'create_file'
      description: 'Create log decorator factory for controllers'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/factories/decorators/log-controller-decorator-factory.ts'
      template: |
        import { Controller } from '@/presentation/protocols'
        import { LogControllerDecorator } from '@/main/decorators'
        // AI-NOTE: Import log repository
        // import { LogMongoRepository } from '@/infra/db/mongodb'

        /**
         * Factory for LogControllerDecorator
         * @layer Main Layer - Factory
         * @pattern Decorator Pattern, Factory Pattern
         */
        export const makeLogControllerDecorator = (controller: Controller): Controller => {
          // const logRepository = new LogMongoRepository()
          // return new LogControllerDecorator(controller, logRepository)

          // For now, return controller without logging
          return controller
        }

    # === STEP 14: CREATE AUTH MIDDLEWARE FACTORY ===
    - id: 'create-auth-middleware-factory'
      type: 'create_file'
      description: 'Create authentication middleware factory'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/factories/middlewares/auth-middleware-factory.ts'
      template: |
        import { Middleware } from '@/presentation/protocols'
        import { AuthMiddleware } from '@/presentation/middlewares'
        import { makeDbLoadAccountByToken } from '../usecases'

        /**
         * Factory for AuthMiddleware
         * @layer Main Layer - Factory
         * @pattern Factory Pattern, Dependency Injection
         */
        export const makeAuthMiddleware = (role?: string): Middleware => {
          const loadAccountByToken = makeDbLoadAccountByToken()
          return new AuthMiddleware(loadAccountByToken, role)
        }

    # === STEP 15: CREATE E2E TEST ===
    - id: 'create-e2e-test'
      type: 'create_file'
      description: 'Create E2E test for feature'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/tests/main/routes/__FEATURE_NAME_KEBAB_CASE__-routes.test.ts'
      template: |
        import { describe, test, expect, beforeAll, afterAll, beforeEach } from 'vitest'
        import request from 'supertest'
        // Express: import { Express } from 'express'
        // Fastify: import { FastifyInstance } from 'fastify'
        import { setupApp } from '@/main/config/app'
        // AI-NOTE: Import database helper for test setup
        // import { MongoHelper } from '@/infra/db/mongodb'

        /**
         * E2E tests for __FEATURE_NAME_PASCAL_CASE__ routes
         * @layer Main Layer - Tests
         * @pattern E2E Testing
         */
        describe('__FEATURE_NAME_PASCAL_CASE__ Routes', () => {
          let app: any // Express or FastifyInstance

          beforeAll(async () => {
            // await MongoHelper.connect(process.env.MONGO_URL)
            app = await setupApp()
          })

          afterAll(async () => {
            // await MongoHelper.disconnect()
          })

          beforeEach(async () => {
            // Clean database before each test
            // const collection = await MongoHelper.getCollection('__FEATURE_NAME_KEBAB_CASE__')
            // await collection.deleteMany({})
          })

          describe('POST /__FEATURE_NAME_KEBAB_CASE__', () => {
            test('Should return 201 on success', async () => {
              const response = await request(app)
                .post('/api/__FEATURE_NAME_KEBAB_CASE__')
                .send({
                  name: 'Test Name',
                  email: 'test@example.com'
                })

              expect(response.status).toBe(201)
              expect(response.body).toHaveProperty('id')
            })

            test('Should return 400 on validation error', async () => {
              const response = await request(app)
                .post('/api/__FEATURE_NAME_KEBAB_CASE__')
                .send({
                  // Missing required fields
                })

              expect(response.status).toBe(400)
              expect(response.body).toHaveProperty('error')
            })

            test('Should return 401 on authentication error', async () => {
              // Test protected route without token
              const response = await request(app)
                .post('/api/__FEATURE_NAME_KEBAB_CASE__/protected')
                .send({
                  name: 'Test Name'
                })

              expect(response.status).toBe(401)
            })
          })
        })

    # === STEP 16: CREATE SWAGGER DOCUMENTATION ===
    - id: 'create-swagger-config'
      type: 'create_file'
      description: 'Create Swagger/OpenAPI documentation configuration'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      path: '__PROJECT_NAME__/src/main/config/swagger.ts'
      template: |
        // Express: import { Express } from 'express'
        // import swaggerUi from 'swagger-ui-express'
        // Fastify: import { FastifyInstance } from 'fastify'
        // import swagger from '@fastify/swagger'
        // import swaggerUi from '@fastify/swagger-ui'

        /**
         * Swagger/OpenAPI documentation setup
         * @layer Main Layer - Configuration
         * @pattern API Documentation
         */
        const swaggerConfig = {
          openapi: '3.0.0',
          info: {
            title: '__PROJECT_NAME__ API',
            version: '1.0.0',
            description: 'Clean Architecture API with __FRAMEWORK__'
          },
          servers: [
            {
              url: '/api',
              description: 'API Server'
            }
          ],
          components: {
            securitySchemes: {
              bearerAuth: {
                type: 'http',
                scheme: 'bearer',
                bearerFormat: 'JWT'
              }
            }
          }
        }

        // Express implementation
        // export default (app: Express): void => {
        //   app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerConfig))
        // }

        // Fastify implementation
        // export default async (app: FastifyInstance): Promise<void> => {
        //   await app.register(swagger, {
        //     swagger: swaggerConfig,
        //     hideUntagged: true,
        //     exposeRoute: true
        //   })
        //
        //   await app.register(swaggerUi, {
        //     routePrefix: '/api-docs',
        //     staticCSP: true,
        //     transformStaticCSP: (header) => header,
        //     transformSpecification: (swaggerObject) => swaggerObject,
        //     transformSpecificationClone: true
        //   })
        // }

    # === STEP 17: CREATE PR ===
    - id: 'create-pr-main'
      type: 'validation'
      description: 'Create Pull Request for main layer'
      status: 'PENDING'
      rlhf_score: null
      execution_log: ''
      run_scripts:
        description: 'Create PR using GitHub CLI'
        scripts:
          - name: 'Push and create PR'
            command: |
              git add .
              git commit -m "feat(__FEATURE_NAME_KEBAB_CASE__): implement main layer with dependency injection"
              git push -u origin "feat/__FEATURE_NAME_KEBAB_CASE__-main-layer"

              gh pr create \
                --title "feat(__FEATURE_NAME_KEBAB_CASE__): add main layer implementation" \
                --body "## Summary

              Implemented main layer for __FEATURE_NAME_PASCAL_CASE__ feature.

              ## Changes
              - ✅ Created controller factories with dependency injection
              - ✅ Created use case factories
              - ✅ Created validation factories
              - ✅ Implemented route adapters for __FRAMEWORK__
              - ✅ Setup middleware configuration
              - ✅ Created application bootstrap
              - ✅ Added E2E tests
              - ✅ Configured Swagger documentation

              ## Architecture
              - Composition Root pattern
              - Factory Method pattern
              - Adapter pattern for framework integration
              - Dependency Injection

              ## Testing
              - [ ] Unit tests pass
              - [ ] E2E tests pass
              - [ ] Manual API testing completed
              " \
                --assignee @me \
                --label "feature,backend,main-layer"
            workingDirectory: '__PROJECT_NAME__'

# ------------------------------------------------------------------------------
# MAIN LAYER REFACTORING PATTERNS
# ------------------------------------------------------------------------------

main_refactoring_patterns:
  - id: 'extract-factory-logic'
    description: 'Extract inline object creation to factories'
    detection:
      - 'Direct instantiation in routes'
      - 'Dependencies created inline'
      - 'Missing dependency injection'
    example:
      original: |
        # AI-NOTE: Extract direct instantiation to factory
        <<<FIND>>>
        // In route file
        router.post('/users', async (req, res) => {
          const repository = new UserMongoRepository()
          const useCase = new CreateUser(repository)
          const validation = new ValidationComposite([
            new RequiredFieldValidation('email')
          ])
          const controller = new CreateUserController(useCase, validation)

          const response = await controller.handle(req)
          res.status(response.statusCode).json(response.body)
        })
        <<</FIND>>>
        <<<REPLACE>>>
        // In route file
        import { adaptRoute } from '@/main/adapters'
        import { makeCreateUserController } from '@/main/factories'

        router.post('/users', adaptRoute(makeCreateUserController()))
        <<</REPLACE>>>
      category: 'architecture'
      severity: 'HIGH'
      rlhf_impact: 2

# ------------------------------------------------------------------------------
# MAIN LAYER ANTI-PATTERNS
# ------------------------------------------------------------------------------

main_anti_patterns:
  - name: 'Business Logic in Main Layer'
    description: 'Main layer should only compose, not implement business logic'
    example: 'Validation rules or business logic in factories'
    correct: 'Factories should only instantiate and wire dependencies'
    rlhf_impact: -2

  - name: 'Hard-coded Dependencies'
    description: 'Dependencies hard-coded instead of injected'
    example: 'new MongoRepository() inside controller'
    correct: 'Use factories to inject dependencies'
    rlhf_impact: -2

  - name: 'Framework Coupling'
    description: 'Business logic coupled to framework'
    example: 'Express Request/Response in use cases'
    correct: 'Use adapters to isolate framework'
    rlhf_impact: -2

  - name: 'Missing Error Handling'
    description: 'No global error handling in main layer'
    example: 'Unhandled promise rejections'
    correct: 'Setup global error handlers in app configuration'
    rlhf_impact: -1

  - name: 'Static Route Registration'
    description: 'Routes registered manually instead of dynamically'
    example: 'import userRoutes; import productRoutes'
    correct: 'Use dynamic route loading from features'
    rlhf_impact: -1

# --- From: shared/01-footer.part.regent ---
  # ============= BEGIN FOOTER SECTION =============


  # ------------------------------------------------------------------------------
  # AI-NOTE: IMMUTABLE DOCUMENTATION SECTIONS AHEAD.
  # Copy these sections verbatim. The [placeholders] inside the commands
  # are for HUMAN examples and MUST NOT be replaced by the AI.
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # TROUBLESHOOTING & RECOVERY
  # ------------------------------------------------------------------------------

  troubleshooting:
    lint_fails:
      - 'DO NOT commit - Fix all lint errors first'
      - 'Check for unused imports'
      - 'Verify proper TypeScript types'
      - 'Ensure no console.log statements'
      - 'Run yarn lint --fix to auto-fix when possible'

    tests_fail:
      - 'DO NOT commit - All tests must pass'
      - 'Check if mocks match the actual interfaces'
      - 'Verify Input/Output types are correct'
      - 'Ensure test coverage meets requirements'
      - 'Run specific test: yarn test [test-file-path]'

    typescript_fails:
      - 'Check all type definitions match'
      - 'Ensure no missing imports'
      - 'Verify interface implementations are complete'
      - 'Run yarn tsc --noEmit to check types'

  # Refactoring checklist
  refactoring:
    before_refactoring: |
      # Check current status and differences
      echo "📊 Checking current changes..."
      git status
      git diff

      # Ensure clean working directory
      echo "✅ Saving current work..."
      git stash save "WIP: before refactoring"

      # Create refactoring branch
      echo "🌿 Creating refactor branch..."
      git checkout -b refactor/[feature-name]

      # Run tests to ensure starting point is stable
      echo "🧪 Validating current state..."
      yarn test --run
      if [ $? -ne 0 ]; then
        echo "❌ Tests failing before refactor - fix first!"
        exit 1
      fi
      echo "✅ Ready to refactor"

    during_refactoring: |
      # After each change, check what was modified
      echo "🔍 Reviewing changes..."
      git diff --stat
      git diff

      # Validate the change
      yarn lint && yarn test --run

      # Commit atomically
      git add -p  # Interactive staging
      git commit -m "refactor([feature-name]): [specific change description]"

      # Show what was changed
      git show --stat

    common_scenarios:
      - name: 'Splitting a use case'
        wrong_example: |
          interface CreateUserAndSendEmail {
            execute: (input: CreateUserAndSendEmailInput) => Promise<CreateUserAndSendEmailOutput>
          }
        correct_example: |
          interface CreateUser{
            execute: (input: CreateUserInput) => Promise<CreateUserOutput>
          }
          interface SendWelcomeEmail {
            execute: (input: SendWelcomeEmailInput) => Promise<SendWelcomeEmailOutput>
          }

      - name: 'Renaming domain errors'
        wrong_example: |
          export class ErrorUserExists extends Error {
            constructor() {
              super('Error: user exists')
              this.name = 'ErrorUserExists'
            }
          }
        correct_example: |
          export class UserAlreadyExistsError extends Error {
            constructor() {
              super('User with this email already exists')
              this.name = 'UserAlreadyExistsError'
            }
          }

  # ------------------------------------------------------------------------------
  # LEARNING & IMPROVEMENT PATTERNS
  # The system tracks these patterns to improve over time
  # ------------------------------------------------------------------------------
  learning_patterns:
    common_errors:
      # Domain Layer Violations
      - pattern: 'import axios|fetch|prisma|redis'
        fix: 'Remove external library imports from domain layer'
        layer: 'domain'
        score_impact: -2

      - pattern: 'CreateUserAndSend|GetDataAndFormat'
        fix: 'Split into two separate use cases (SRP violation)'
        layer: 'domain'
        score_impact: -1

      - pattern: 'missing @domainConcept'
        fix: 'Add domain concept documentation for +2 score'
        layer: 'domain'
        score_impact: +1

      # Data Layer Violations
      - pattern: 'direct database access in data layer'
        fix: 'Use repository protocols instead of direct database access'
        layer: 'data'
        score_impact: -2

      - pattern: 'business logic in data layer'
        fix: 'Move business logic to domain layer'
        layer: 'data'
        score_impact: -1

      # Infrastructure Layer Violations
      - pattern: 'business logic in infrastructure'
        fix: 'Infrastructure should only contain adapters and implementations'
        layer: 'infra'
        score_impact: -2

      - pattern: 'missing error handling in adapters'
        fix: 'Add proper error handling and recovery in infrastructure adapters'
        layer: 'infra'
        score_impact: -1

      # Presentation Layer Violations
      - pattern: 'business logic in controllers|components'
        fix: 'Move business logic to use cases in domain layer'
        layer: 'presentation'
        score_impact: -2

      - pattern: 'direct database access from presentation'
        fix: 'Use use cases and factories from main layer'
        layer: 'presentation'
        score_impact: -2

      # Main Layer Violations
      - pattern: 'business logic in factories'
        fix: 'Main layer should only compose, not implement business logic'
        layer: 'main'
        score_impact: -2

      - pattern: 'missing dependency injection'
        fix: 'Use factories and dependency injection for all dependencies'
        layer: 'main'
        score_impact: -1

    success_indicators:
      - 'Uses ubiquitous language consistently across all layers'
      - 'Follows single responsibility principle in every component'
      - 'No dependency violations between layers'
      - 'Comprehensive test coverage (Domain: 100%, Data: 95%, Infra: 80%, Presentation: 90%)'
      - 'Clean git history with atomic commits'
      - 'Proper error handling at each layer boundary'
      - 'Clear separation of concerns between layers'
      - 'Type safety maintained throughout the stack'

  # AI Guidelines for All Layers
  ai_guidelines:
    general:
      - 'Always validate before committing: Run lint first, Run tests second, Only commit if both pass'
      - 'If generation fails: Identify the specific error, Fix only that error, Re-run validation, Do NOT proceed until fixed'
      - 'MUST generate different case styles from the input names (e.g., "Add Item To Cart" becomes: PascalCase=AddItemToCart, kebab-case=add-item-to-cart, lower case=add item to cart).'
      - 'MUST replace ALL placeholder variables (like __FEATURE_NAME_KEBAB_CASE__) with actual values'
      - 'MUST NOT leave any placeholder variables in the final implementation'
      - 'MUST NOT replace any [placeholders] found inside documentation sections like refactoring or recovery'
      - 'MUST use vitest for backend, @testing-library/react for frontend'
      - 'When in doubt: Choose simplicity over complexity, Split rather than combine, Ask for clarification rather than assume'

    layer_specific:
      domain:
        - 'Follow the principle: One use case = One file = One responsibility'
        - 'If tempted to add "And" in a use case name, split it'
        - 'MUST follow all domain rules - no business logic implementation, only contracts'
        - 'No external dependencies allowed in domain layer'
        - 'Use value objects for domain concepts'
        - 'Define clear domain errors with meaningful messages'

      data:
        - 'Implement use cases defined in domain layer'
        - 'Use repository protocols for data access'
        - 'Transform external data to domain models'
        - 'Handle data-specific errors and map to domain errors'
        - 'No direct database or API calls'

      infrastructure:
        - 'Implement repository interfaces defined in data layer'
        - 'Handle external service integrations (database, cache, APIs)'
        - 'Provide concrete implementations of protocols'
        - 'Include proper error handling and retry logic'
        - 'Use appropriate design patterns (Adapter, Facade)'

      presentation:
        - 'Controllers/Components should be thin - delegate to use cases'
        - 'Handle input validation and transformation'
        - 'Format responses for clients'
        - 'Implement proper error responses'
        - 'For frontend: Use hooks for business logic extraction'
        - 'For backend: Use middleware for cross-cutting concerns'

      main:
        - 'Composition root only - no business logic'
        - 'Wire up all dependencies using factories'
        - 'Configure dependency injection'
        - 'Setup application bootstrap and configuration'
        - 'For Next.js: Configure providers and middleware'
        - 'For Express/Fastify: Setup server and routes'

  # ------------------------------------------------------------------------------
  # AI-NOTE: TASK EVALUATION SECTION.
  # After the entire execution is complete, this section will be populated by a
  # human reviewer or an evaluation script.
  # ------------------------------------------------------------------------------

  evaluation:
    # AI-NOTE: This final_status will be 'SUCCESS' if all steps passed, or 'FAILED' if any step failed.
    final_status: 'PENDING' # PENDING | SUCCESS | FAILED
    # AI-NOTE: The final_rlhf_score is calculated automatically based on execution quality
    # -2: Catastrophic errors (architecture violations, wrong REPLACE/WITH format)
    # -1: Runtime errors (lint, tests, git failures)
    #  0: Low confidence (system uncertain, prevents hallucinations)
    # +1: Good execution but missing DDD elements
    # +2: Perfect with Clean Architecture, DDD, ubiquitous language
    final_rlhf_score: null # -2, -1, 0, 1, 2
    # AI-NOTE: The system automatically analyzes patterns and learns from each execution
    # This text is enhanced by automated RLHF analysis for continuous improvement
    reviewer_summary: |
      - What went well:
        - ...
      - Areas for improvement:
        - ...
    # AI-NOTE: This section lists actionable suggestions for improving the master templates or prompts.
    # This is the key to the continuous learning loop.
    template_improvement_suggestions:
      - target_template: '[layer].template.yaml'
        target_step_id: '[step-id]'
        suggestion: '[specific improvement suggestion based on execution results]'
        priority: 'medium'
        
  # ============= END FOOTER SECTION =============

  # End of TEMPLATE.yaml
