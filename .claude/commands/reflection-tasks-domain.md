# Task: Reflect on Domain YAML Plan

## 1. Your Deliverable

Your output is a JSON object containing your reflections and, if necessary, a revised YAML plan.

- If no changes are needed: `{"status": "NO_CHANGES_NEEDED", "reflection": "The plan is optimal and requires no changes.", "revised_yaml": null}`.
- If changes are made: `{"status": "REVISED", "reflection": "...", "revised_yaml": "..."}`.

## 2. Objective

Your goal is to act as a senior software architect reviewing a detailed implementation plan (the YAML file). You must analyze the plan for logical consistency, simplicity, and efficiency. Your job is to **refine the plan**, not to execute it.

## 3. Input Parameters

- **YAML Plan:** The complete, validated YAML content generated by the `/tasks-domain` command.

## 4. Reflection Checklist (Guiding Questions)

You must critically analyze the YAML plan by asking these questions. Your final `reflection` text must summarize your findings for each point.

- **[ ] Simplicity (KISS - Keep It Simple, Stupid):**

  - "Is there a simpler way to achieve the same goal with fewer steps?"
  - "Is any step overly complex or trying to do more than one thing?"
  - "Can I combine multiple `refactor_file` steps into a single, more cohesive one?"

- **[ ] Cohesion and Logic:**

  - "Does the order of steps make logical sense? Are dependencies correct?" (e.g., Is a file being modified before it's created?)
  - "Are the `id`s and `description`s of the steps clear and do they accurately represent the action being taken?"

- **[ ] Completeness:**

  - "Have I missed anything? If I created a new `UseCase`, did I also create the corresponding `Test Helper`?"
  - "If I refactored an interface, did I identify and create refactoring steps for all its primary consumers?" (Use your knowledge from `Serena` to think about this).
  - "Does the plan include steps to clean up temporary or broken artifacts if necessary (`delete_file`)?"

- **[ ] Efficiency:**
  - "Are there redundant steps? For example, creating a file and then immediately refactoring it? Could this be a single `create_file` step with the final content?"

## 5. Step-by-Step Execution Plan

1.  **Parse Input:** Receive the YAML plan.
2.  **Analyze and Reflect:** Read the YAML from start to finish. Go through the "Reflection Checklist" and formulate answers to each question.
3.  **Decide on Action:**
    a. **If the plan is optimal and no improvements can be made:** Conclude that no changes are necessary.
    b. **If you identify potential improvements:** Create a copy of the YAML in memory and apply the necessary modifications (reorder steps, combine steps, add missing steps, etc.).
4.  **Generate Report:**
    a. If no changes were made, produce the output JSON with `status: "NO_CHANGES_NEEDED"`.
    b. If you modified the plan, produce the output JSON with `status: "REVISED"`. In the `reflection` field, write a clear and concise summary of the changes you made and **why** you made them, referencing the checklist. Place the complete, modified YAML in the `revised_yaml` field.

---

## Example Invocation

`/reflection-tasks-domain from yaml:`

```yaml
# ... (a complete YAML generated by /tasks-domain)
steps:
  - id: "create-user-service"
    type: "create_file"
    # ...
  - id: "add-logging-to-user-service"
    type: "refactor_file"
    path: "src/features/user/domain/services/user-service.ts"
    template: |
      <<<REPLACE>>>
      // ...
      <<</REPLACE>>>
      <<<WITH>>>
      // ... with logging
      <<</WITH>>>
  # ...
```

**Expected Output (if an improvement is found):**

```json
{
  "status": "REVISED",
  "reflection": "The original plan was inefficient. It created a file in one step and then immediately refactored it in the next. I have combined these into a single 'create_file' step that generates the file with logging included from the start, following the KISS principle.",
  "revised_yaml": "steps:\n  - id: 'create-user-service-with-logging'\n    type: 'create_file'\n    # ... (the new, combined, and simplified YAML)"
}
```
