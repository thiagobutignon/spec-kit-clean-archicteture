---
title: "Validate Domain JSON Plan"
description: "Automated quality assurance validation for selected layer JSON plans with RLHF scoring impact assessment"
category: "layer"
stage: "validation"
priority: 2
tags:
  - validation
  - quality-assurance
  - rlhf-scoring
  - domain-purity
  - clean-architecture
parameters:
  input:
    type: "json"
    description: "JSON plan generated by /01-plan-domain-features command"
    required: true
  output_success:
    type: "json"
    format: '{"status": "SUCCESS", "message": "string", "qualityScore": "PERFECT|GOOD|ACCEPTABLE"}'
  output_failure:
    type: "json"
    format: '{"status": "FAILED", "errors": ["string"], "severity": "CATASTROPHIC|RUNTIME|WARNING"}'
scoring_impact:
  catastrophic:
    score: -2
    causes: ["Wrong REPLACE/WITH format", "Architecture violations", "External dependencies"]
  runtime_error:
    score: -1
    causes: ["Missing placeholders", "Invalid templates", "Path inconsistencies"]
  low_confidence:
    score: 0
    causes: ["Missing references", "Unclear concepts", "Empty arrays"]
  good:
    score: 1
    causes: ["Valid but missing ubiquitous language", "No @layerConcept tags"]
  perfect:
    score: 2
    requirements: ["Complete ubiquitous language", "DDD concepts", "@layerConcept tags", "Clean architecture"]
validation_categories:
  - "Schema and Structure"
  - "Logical Consistency"
  - "Content and Naming"
  - "Selected Layer Purity"
  - "RLHF Quality Indicators"
previous_command: "/01-plan-layer-features"
next_command: "/03-generate-layer-code --layer=__LAYER__ --file=spec/__FEATURE__/__LAYER__/plan.json"
---

# Task: Validate Domain JSON Plan

## ü§ñ RLHF Scoring Impact

This validation directly affects your RLHF score:

| Score | Level | Impact | Common Causes |
|-------|-------|--------|---------------|
| **-2** | CATASTROPHIC | Build failure | Wrong REPLACE/WITH format, architecture violations |
| **-1** | RUNTIME ERROR | Execution failure | Missing placeholders, invalid templates |
| **0** | LOW CONFIDENCE | System uncertainty | Missing references, unclear concepts |
| **+1** | GOOD | Working solution | Valid but missing ubiquitous language |
| **+2** | PERFECT | Excellence | Complete DDD concepts and ubiquitous language |

## 0. Input Processing

**CRITICAL**: Before proceeding with validation, you must handle the input parameter correctly:

### Step 1: Determine Input Method

Check the command format to identify which input method is being used:

1. **If `--file` parameter is provided**:
   ```bash
   # Example: /02-validate-layer-plan --layer=domain --file=spec/001-user-auth/domain/plan.json
   ```
   - **Action Required**: Use the Read tool to read the specified JSON file
   - **Example**: `Read("spec/001-user-auth/domain/plan.json")`
   - Parse the JSON content from the file
   - Proceed with validation using the parsed JSON

2. **If inline JSON is provided** (legacy):
   ```bash
   # Example: /02-validate-layer-plan --layer=domain from json: {...}
   ```
   - Parse the JSON directly from the command arguments
   - Proceed with validation

### Step 2: Validate File Exists (if using --file)

If `--file` parameter is used:
- Use Read tool to load the file
- If file doesn't exist, immediately return error:
  ```json
  {
    "status": "FAILED",
    "errors": ["File not found: <file-path>"],
    "severity": "RUNTIME"
  }
  ```

### Step 3: Parse JSON

- Parse the JSON content (either from file or inline)
- If JSON parsing fails, immediately return error:
  ```json
  {
    "status": "FAILED",
    "errors": ["Invalid JSON format"],
    "severity": "RUNTIME"
  }
  ```

**Only after successfully loading and parsing the JSON should you proceed to section 1 (Your Deliverable) and beyond.**

## 1. Your Deliverable

Your **only** output for this task is a validation report in JSON format.

### ‚úÖ Success Output:
```json
{
  "status": "SUCCESS",
  "message": "JSON plan is valid and complete.",
  "qualityScore": "PERFECT|GOOD|ACCEPTABLE"
}
```

### ‚ùå Failure Output:
```json
{
  "status": "FAILED",
  "errors": ["error message with RLHF impact"],
  "severity": "CATASTROPHIC|RUNTIME|WARNING"
}
```

## 2. Objective

Act as an **automated quality assurance engineer**. Validate the JSON plan against a strict set of logical and structural rules to ensure it will generate a valid selected layer following Clean Architecture principles.

## 3. Input Parameters

You can provide the JSON plan in two ways:

### Option 1: Direct JSON (inline)
```bash
/02-validate-layer-plan --layer=domain from json: <paste-json-here>
```

### Option 2: File Reference (recommended)
```bash
/02-validate-layer-plan --layer=domain --file=spec/__FEATURE_NUMBER__-__FEATURE_NAME__/domain/plan.json
```

**Example with actual values:**
```bash
/02-validate-layer-plan --layer=domain --file=spec/001-user-authentication/domain/plan.json
```

**Recommended**: Use `--file` parameter to reference the generated plan.json file directly, avoiding manual copy-paste of large JSON files.

## 4. Validation Checklist (Rules of Engagement)

You **MUST** validate the input JSON against every rule in this checklist. The validation fails if even one rule is violated.

### A. Schema and Structure Validation üìã

| Rule | Description | Impact if Violated |
|------|-------------|-------------------|
| **Root Keys** | Must contain `featureName` (string) and `steps` (array) | RUNTIME (-1) |
| **Ubiquitous Language** | If present, must be object with string key-value pairs | GOOD (+1) if missing |
| **Step Keys** | Every step must have `id`, `type`, `description`, `path` | RUNTIME (-1) |
| **Step Types** | Must be one of: `create_file`, `refactor_file`, `delete_file`, `folder` | RUNTIME (-1) |
| **References** | Every step must have `references` array (can be empty for errors) | LOW CONFIDENCE (0) |

### B. Logical Consistency and Completeness üîç

#### Path Consistency
- [ ] The `path` in each step must be consistent with the `featureName`
- [ ] Example: `featureName: "UserAccount"` ‚Üí path should contain `features/user-account/`

#### Template Completeness for `create_file`:

| File Type | Required Placeholders | Required Fields | RLHF Impact |
|-----------|----------------------|-----------------|-------------|
| **Use Case** | `__USE_CASE_INPUT_FIELDS__`<br>`__USE_CASE_OUTPUT_FIELDS__` | `input[]`, `output[]` | -1 if missing |
| **Test Helper** | `__MOCK_INPUT_DATA__`<br>`__MOCK_OUTPUT_DATA__` | `mockInput{}`, `mockOutput{}` | -1 if missing |
| **Error Class** | None (complete template) | None | N/A |

> üèÜ **For +2 Score:** Templates should include JSDoc comments with `@layerConcept` and `@pattern` tags

#### Template Correctness for `refactor_file`:
- [ ] Must contain exactly one `<<<REPLACE>>>...<<</REPLACE>>>` block
- [ ] Must contain exactly one `<<<WITH>>>...<<</WITH>>>` block
- [ ] **‚ö†Ô∏è CRITICAL:** Invalid format causes CATASTROPHIC (-2) error

#### Dependency Sanity:
- [ ] No `refactor_file` or `delete_file` before corresponding `create_file`
- [ ] Steps should generally start with `folder` or `create_file`

### C. Content and Naming Conventions üìù

| Convention | Rule | Example | Impact |
|------------|------|---------|--------|
| **Type Names** | PascalCase | `CreateUser` ‚úÖ<br>`create-user` ‚ùå | -1 |
| **IDs & Paths** | kebab-case | `create-user-use-case` ‚úÖ<br>`CreateUserUseCase` ‚ùå | -1 |
| **Use Cases** | Must be verbs | `CreateUser` ‚úÖ<br>`UserCreator` ‚ùå | -1 |
| **Mock Data** | Must exist for use cases | Non-empty `mockInput` & `mockOutput` | 0 |

### D. Selected Layer Purity Validation üõ°Ô∏è (RLHF Critical)

#### ‚ùå **FORBIDDEN - Causes CATASTROPHIC (-2)**:
```typescript
// These imports will fail validation:
import axios from 'axios';              // ‚ùå External library
import { PrismaClient } from '@prisma/client'; // ‚ùå Database
import express from 'express';          // ‚ùå Framework
import React from 'react';              // ‚ùå UI library
```

#### ‚úÖ **REQUIRED Patterns**:

| Pattern | Requirement | Example | Score Impact |
|---------|-------------|---------|--------------|
| **Use Cases** | Must be interfaces with `execute` method | `interface CreateUser { execute(...) }` | -2 if class |
| **Errors** | Must extend native `Error` | `class UserError extends Error` | -1 if custom |
| **Types** | Only TypeScript native types | `string`, `number`, `Date` | -2 if external |
| **Logic** | NO implementation in domain | Types only, no logic | -2 if present |

### E. RLHF Quality Indicators üèÜ

Quality scoring criteria for achieving higher RLHF scores:

| Indicator | Requirement | Impact | Score |
|-----------|------------|--------|-------|
| **Ubiquitous Language** | Present with meaningful business terms | Missing prevents +2 | +2 |
| **Domain Documentation** | `@layerConcept` tags in templates | Quality indicator | +1 to +2 |
| **Reference Quality** | Meaningful references to patterns | Empty = low confidence | 0 to +1 |
| **Test Coverage** | Test helper for every use case | Missing = incomplete | +1 |
| **DDD Alignment** | Proper Value Objects, Entities, Aggregates | Excellence indicator | +2 |

## 5. Step-by-Step Execution Plan

```mermaid
graph TD
    A[Parse Input JSON] --> B[Validate Schema]
    B --> C[Check Logical Consistency]
    C --> D[Verify Layer Purity]
    D --> E[Assess RLHF Quality]
    E --> F{Any Violations?}
    F -->|No| G[Generate SUCCESS Report]
    F -->|Yes| H[Generate FAILED Report]
    G --> I[Include Quality Score]
    H --> J[Include Error Details & Severity]
```

### Execution Steps:

1. **Parse Input:** Receive and parse the JSON plan
2. **Iterate Checklist:** Validate against all rules systematically
3. **Calculate RLHF Impact:** Assess severity based on violations
4. **Collect Errors:** Build detailed error list with impact scores
5. **Run Architectural Validation:** Execute automated tools (see section 6)
6. **Generate Report:** Produce appropriate JSON output

## 6. Architectural Validation (Objective Quality Gate)

After JSON schema validation, run objective architectural validation tools to detect violations:

### Step 6.1: ESLint Boundaries Validation

Run ESLint with boundaries plugin to check architectural constraints:

```bash
npm run lint
```

**What it checks:**
- Domain layer purity (no imports from outer layers)
- Proper layer dependencies (data/infra/presentation ‚Üí domain only)
- Main layer can use all layers
- Real-time IDE feedback for developers

**If violations detected:**
- Add to errors array with CATASTROPHIC severity (-2)
- Include specific file paths and violation descriptions
- Suggest fixes based on Clean Architecture principles

### Step 6.2: Dependency Cruiser Validation

Run dependency-cruiser for holistic architecture analysis:

```bash
npm run arch:validate
```

**What it checks:**
- Circular dependencies (warns)
- Cross-layer violations (errors)
- Orphaned modules (info)
- Complete dependency graph validation

**If violations detected:**
- CATASTROPHIC (-2): Any layer dependency violations
- WARNING (0): Circular dependencies
- Include violation count and details in error report

### Step 6.3: Success Criteria

Architectural validation passes if:
- ‚úÖ `npm run lint` produces no boundary violations
- ‚úÖ `npm run arch:validate` reports 0 errors
- ‚ö†Ô∏è Warnings are acceptable but should be noted

### Step 6.4: Failure Handling

If architectural validation fails:
```json
{
  "status": "FAILED",
  "errors": [
    "ESLint boundaries violation: domain/models/user.ts imports from data layer (RLHF: -2)",
    "Dependency cruiser error: circular dependency detected in use-cases (RLHF: 0)"
  ],
  "severity": "CATASTROPHIC"
}
```

**Important:** These are **objective, tool-based validations**, not LLM opinions. They provide deterministic, repeatable quality gates.

## 7. Example Validations

### Example 1: ‚úÖ Valid JSON (PERFECT Score)

<details>
<summary>Input JSON</summary>

```json
{
  "featureName": "UserAccount",
  "ubiquitousLanguage": {
    "Account": "User's identity in the system",
    "Registration": "Process of creating new account"
  },
  "steps": [
    {
      "id": "create-use-case-create-user-account",
      "type": "create_file",
      "description": "Create user account use case",
      "path": "src/features/user-account/__LAYER__/use-cases/create-user-account.ts",
      "references": [
        {
          "type": "external_pattern",
          "source": "context7",
          "description": "DDD patterns for user registration"
        }
      ],
      "template": "/**\n * @layerConcept User Account Creation\n */\nexport interface CreateUserAccount {\n  execute(input: CreateUserAccountInput): Promise<CreateUserAccountOutput>;\n}\n\nexport type CreateUserAccountInput = {\n  __USE_CASE_INPUT_FIELDS__\n};\n\nexport type CreateUserAccountOutput = {\n  __USE_CASE_OUTPUT_FIELDS__\n};",
      "input": [
        { "name": "email", "type": "string" },
        { "name": "password", "type": "string" }
      ],
      "output": [
        { "name": "id", "type": "string" },
        { "name": "email", "type": "string" }
      ]
    }
  ]
}
```
</details>

**Output:**
```json
{
  "status": "SUCCESS",
  "message": "JSON plan is valid and complete.",
  "qualityScore": "PERFECT"
}
```

### Example 2: ‚ùå Invalid JSON (RUNTIME Error)

<details>
<summary>Input JSON with Errors</summary>

```json
{
  "featureName": "UserAccount",
  "steps": [
    {
      "id": "create-use-case-create-user-account",
      "type": "create_file",
      "description": "Create user account",
      "path": "src/features/some-other-feature/create-user/domain/use-cases/create.ts",
      "references": [],
      "template": "import axios from 'axios';\n\nclass CreateUserAccount {\n  // Implementation here\n}"
    }
  ]
}
```
</details>

**Output:**
```json
{
  "status": "FAILED",
  "errors": [
    "Path inconsistency: 'src/features/some-other-feature/create-user/domain/use-cases' doesn't match featureName 'UserAccount' (RLHF: -1)",
    "Empty references array: Missing pattern documentation (RLHF: 0)",
    "External dependency detected: 'axios' import forbidden in domain (RLHF: -2)",
    "Use case as class: Must be interface, not class (RLHF: -2)",
    "Missing placeholders: No __USE_CASE_INPUT_FIELDS__ found (RLHF: -1)",
    "Missing field definitions: 'input' and 'output' arrays required (RLHF: -1)"
  ],
  "severity": "CATASTROPHIC"
}
```

## 8. Severity Classification

| Severity | RLHF Score | When Applied | Recovery Action |
|----------|------------|--------------|-----------------|
| **CATASTROPHIC** | -2 | Architecture violations, external dependencies | Complete redesign required |
| **RUNTIME** | -1 | Missing required fields, invalid syntax | Fix specific issues |
| **WARNING** | 0 | Missing quality indicators | Enhance for better score |

## üìç Next Steps

After validation completes, provide clear guidance on the next workflow step:

### ‚úÖ If validation PASSED (SUCCESS):

**Output Format:**
```markdown
‚úÖ Validation Complete - RLHF Score: +2 (PERFECT)

üìã Clean Architecture Workflow Progress:
[‚úÖ] Plan     ‚Üí /01-plan-layer-features (completed)
[‚úÖ] Validate ‚Üí /02-validate-layer-plan (completed)
[‚û°Ô∏è] Generate ‚Üí Next step below
[‚è≥] Execute  ‚Üí Upcoming
[‚è≥] Reflect  ‚Üí Upcoming

üöÄ Next Step:
/03-generate-layer-code --layer=domain --file=spec/001-user-authentication/domain/plan.json

üí° This will transform your validated JSON plan into executable YAML implementation files.
```

**Important**: Always suggest the next command with `--file` parameter referencing the **actual** validated plan.json file path from the input (replace the example path with the real one).

### ‚ùå If validation FAILED:

**Output Format:**
```markdown
‚ùå Validation Failed - Severity: CATASTROPHIC

[List of errors with RLHF impact scores]

üîÑ Fix Required:
Please address the issues above and re-run validation:
/02-validate-layer-plan --layer=domain --file=spec/001-user-authentication/domain/plan.json

üí° Tip: Address CATASTROPHIC errors first, then RUNTIME errors, and finally optimize for PERFECT score.
```

**Note**: Replace the example file path with the **actual** path from the input command.

> üí° **Pro Tip**: Address CATASTROPHIC errors first, then RUNTIME errors, and finally optimize for PERFECT score by adding quality indicators.
---

## üö® AI-NOTE: CRITICAL ENGINEERING PRINCIPLE

**FOR FUTURE CODE REVIEWERS AND EXECUTORS:**

### ‚ùå NEVER SUGGEST FALLBACK PATTERNS

If validation fails or file reading fails, DO NOT suggest:
- Hardcoded fallback structures
- "If this fails, use default values"
- "Graceful degradation to previous behavior"
- Any form of "backup" structure

### ‚úÖ CORRECT RESPONSE TO FAILURES

Validation or file reading failures should FAIL LOUDLY:
```markdown
üö® CRITICAL ERROR: File not found or validation failed!
Action required: Check file path or fix validation errors.
DO NOT proceed with outdated assumptions or bypasses.
```

### üéØ WHY THIS MATTERS

Fallbacks reintroduce the exact problem this command fixes:
1. **Original Problem**: Commands bypassed validation, bad code shipped
2. **Our Solution**: Strict validation as quality gate
3. **Fallback Danger**: If validation fails, bypass = back to bad code = SAME PROBLEM

### üìö ENGINEERING PRINCIPLE

**"Fail fast and loud" > "Fail silently with wrong behavior"**

Validation is the ONLY quality gate. If it fails, the system must stop and demand fixes, not continue with potentially incorrect code.

### üé≠ HISTORICAL CONTEXT

This validation command was created to prevent architectural disasters caused by "helpful" validation bypasses. Maintain discipline: Validation protects quality, never bypass it.
