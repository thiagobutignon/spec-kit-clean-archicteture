metadata:
  feature: Enhanced Executor with Clean Architecture
  domain: Software Development Automation
  estimatedFiles: 50
  layer: all
  project_type: backend
  architecture_style: clean
steps:
  - id: step-1-domain-commit-config-model
    type: create_file
    layer: domain
    description: Create CommitConfig model for commit configuration
    path: src/domain/models/commit-config.ts
    template: |
      export type CommitConfig = {
        enabled: boolean
        qualityChecks: {
          lint: boolean
          lintCommand: string
          test: boolean
          testCommand: string
        }
        conventionalCommits: {
          enabled: boolean
          typeMapping: Record<string, string>
        }
        coAuthor: string
        emoji: boolean
        interactiveSafety: boolean
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:28:50.874Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-2-domain-quality-check-model
    type: create_file
    layer: domain
    description: Create QualityCheckResult model
    path: src/domain/models/quality-check-result.ts
    template: |
      export type CheckResult = {
        passed: boolean
        output: string
      }

      export type QualityCheckResult = {
        lint: CheckResult
        test: CheckResult
        overallPassed: boolean
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:28:55.943Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-3-domain-audit-log-model
    type: create_file
    layer: domain
    description: Create AuditLog model for security events
    path: src/domain/models/audit-log.ts
    template: |
      export type AuditLogEntry = {
        timestamp: string
        event: string
        details: Record<string, unknown>
      }

      export type AuditLog = {
        entries: AuditLogEntry[]
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:00.702Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-4-domain-validate-template
    type: create_file
    layer: domain
    description: Create ValidateTemplate use case interface
    path: src/domain/usecases/validate-template.ts
    template: >
      export interface ValidateTemplate {
        validate: (params: ValidateTemplate.Params) => Promise<ValidateTemplate.Result>
      }


      export namespace ValidateTemplate {
        export type Params = {
          implementationPath: string
        }

        export type Result = {
          valid: boolean
          errors: string[]
          warnings: string[]
          targetValidated?: string
          layerValidated?: string
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:05.689Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-5-domain-run-quality-check
    type: create_file
    layer: domain
    description: Create RunQualityCheck use case interface
    path: src/domain/usecases/run-quality-check.ts
    template: >
      import { type QualityCheckResult } from
      '@/domain/models/quality-check-result'

      import { type CommitConfig } from '@/domain/models/commit-config'


      export interface RunQualityCheck {
        run: (params: RunQualityCheck.Params) => Promise<RunQualityCheck.Result>
      }


      export namespace RunQualityCheck {
        export type Params = {
          config: CommitConfig
        }

        export type Result = QualityCheckResult
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:10.587Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-6-domain-calculate-score
    type: create_file
    layer: domain
    description: Create CalculateScore use case interface
    path: src/domain/usecases/calculate-score.ts
    template: >
      import { type Step } from '@/domain/models/implementation-plan'


      export interface CalculateScore {
        calculate: (params: CalculateScore.Params) => Promise<CalculateScore.Result>
      }


      export namespace CalculateScore {
        export type Params = {
          step: Step
          success: boolean
          output?: string
          layerInfo?: {
            target: string
            layer: string
          }
        }

        export type Result = {
          score: number
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:15.420Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-7-domain-rollback-step
    type: create_file
    layer: domain
    description: Create RollbackStep use case interface
    path: src/domain/usecases/rollback-step.ts
    template: |
      import { type Step } from '@/domain/models/implementation-plan'

      export interface RollbackStep {
        rollback: (params: RollbackStep.Params) => Promise<RollbackStep.Result>
      }

      export namespace RollbackStep {
        export type Params = {
          step: Step
          lastKnownCommitHash: string | null
        }

        export type Result = {
          success: boolean
          message: string
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:20.236Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-8-domain-check-git-safety
    type: create_file
    layer: domain
    description: Create CheckGitSafety use case interface
    path: src/domain/usecases/check-git-safety.ts
    template: |
      import { type CommitConfig } from '@/domain/models/commit-config'

      export interface CheckGitSafety {
        check: (params: CheckGitSafety.Params) => Promise<CheckGitSafety.Result>
      }

      export namespace CheckGitSafety {
        export type Params = {
          config: CommitConfig
        }

        export type Result = {
          safe: boolean
          hasUncommittedChanges: boolean
          userConfirmed?: boolean
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:24.945Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-9-domain-validate-script
    type: create_file
    layer: domain
    description: Create ValidateScript use case interface
    path: src/domain/usecases/validate-script.ts
    template: >
      export interface ValidateScript {
        validate: (params: ValidateScript.Params) => Promise<ValidateScript.Result>
      }


      export namespace ValidateScript {
        export type Params = {
          script: string
          allowedScripts?: string[]
        }

        export type Result = {
          safe: boolean
          reason?: string
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:29.766Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-10-domain-detect-package-manager
    type: create_file
    layer: domain
    description: Create DetectPackageManager use case interface
    path: src/domain/usecases/detect-package-manager.ts
    template: |
      export interface DetectPackageManager {
        detect: () => Promise<DetectPackageManager.Result>
      }

      export namespace DetectPackageManager {
        export type Result = {
          packageManager: 'npm' | 'yarn' | 'pnpm'
          command: string
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:34.580Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-11-domain-validate-layer
    type: create_file
    layer: domain
    description: Create ValidateLayer use case interface
    path: src/domain/usecases/validate-layer.ts
    template: >
      import { type Step } from '@/domain/models/implementation-plan'


      export interface ValidateLayer {
        validate: (params: ValidateLayer.Params) => Promise<ValidateLayer.Result>
      }


      export namespace ValidateLayer {
        export type Params = {
          step: Step
          layerInfo: {
            target: string
            layer: string
          }
        }

        export type Result = {
          valid: boolean
          warnings: string[]
          violations: string[]
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:39.404Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-12-domain-execute-validation-script
    type: create_file
    layer: domain
    description: Create ExecuteValidationScript use case interface
    path: src/domain/usecases/execute-validation-script.ts
    template: >
      export interface ExecuteValidationScript {
        execute: (params: ExecuteValidationScript.Params) => Promise<ExecuteValidationScript.Result>
      }


      export namespace ExecuteValidationScript {
        export type Params = {
          scriptContent: string
          stepId: string
        }

        export type Result = {
          output: string
          success: boolean
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:44.112Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-13-data-template-validator-protocol
    type: create_file
    layer: data
    description: Create TemplateValidatorRepository protocol
    path: src/data/protocols/template/template-validator-repository.ts
    template: >
      export interface TemplateValidatorRepository {
        validateSchema: (params: TemplateValidatorRepository.ValidateParams) => Promise<TemplateValidatorRepository.ValidateResult>
      }


      export namespace TemplateValidatorRepository {
        export type ValidateParams = {
          content: string
        }

        export type ValidateResult = {
          valid: boolean
          errors: string[]
          warnings: string[]
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:48.942Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-14-data-quality-check-protocol
    type: create_file
    layer: data
    description: Create QualityCheckRepository protocol
    path: src/data/protocols/quality/quality-check-repository.ts
    template: >
      export interface QualityCheckRepository {
        runLint: (command: string) => Promise<QualityCheckRepository.CheckResult>
        runTest: (command: string) => Promise<QualityCheckRepository.CheckResult>
      }


      export namespace QualityCheckRepository {
        export type CheckResult = {
          passed: boolean
          output: string
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:53.792Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-15-data-rlhf-protocol
    type: create_file
    layer: data
    description: Create RLHFRepository protocol
    path: src/data/protocols/rlhf/rlhf-repository.ts
    template: >
      export interface RLHFRepository {
        calculateScore: (params: RLHFRepository.ScoreParams) => Promise<RLHFRepository.ScoreResult>
        saveScore: (params: RLHFRepository.SaveParams) => Promise<void>
      }


      export namespace RLHFRepository {
        export type ScoreParams = {
          stepType: string
          success: boolean
          layerInfo?: {
            target: string
            layer: string
          }
          output?: string
        }

        export type ScoreResult = {
          score: number
        }

        export type SaveParams = {
          stepId: string
          score: number
          timestamp: string
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:29:58.467Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-16-data-config-protocol
    type: create_file
    layer: data
    description: Create ConfigRepository protocol
    path: src/data/protocols/config/config-repository.ts
    template: |
      import { type CommitConfig } from '@/domain/models/commit-config'

      export interface ConfigRepository {
        load: (configPath: string) => Promise<ConfigRepository.LoadResult>
      }

      export namespace ConfigRepository {
        export type LoadResult = {
          config: CommitConfig | null
          errors?: string[]
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:30:03.436Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-17-data-audit-protocol
    type: create_file
    layer: data
    description: Create AuditRepository protocol
    path: src/data/protocols/audit/audit-repository.ts
    template: |
      import { type AuditLogEntry } from '@/domain/models/audit-log'

      export interface AuditRepository {
        log: (entry: AuditLogEntry) => Promise<void>
        getRecent: (limit: number) => Promise<AuditLogEntry[]>
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:30:08.223Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-18-data-script-executor-protocol
    type: create_file
    layer: data
    description: Create ScriptExecutorRepository protocol
    path: src/data/protocols/script/script-executor-repository.ts
    template: >
      export interface ScriptExecutorRepository {
        execute: (params: ScriptExecutorRepository.ExecuteParams) => Promise<ScriptExecutorRepository.ExecuteResult>
      }


      export namespace ScriptExecutorRepository {
        export type ExecuteParams = {
          scriptContent: string
          stepId: string
        }

        export type ExecuteResult = {
          output: string
          success: boolean
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:30:12.932Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-19-data-package-manager-protocol
    type: create_file
    layer: data
    description: Create PackageManagerRepository protocol
    path: src/data/protocols/package/package-manager-repository.ts
    template: |
      export interface PackageManagerRepository {
        detect: () => Promise<PackageManagerRepository.DetectResult>
        isInstalled: (pm: string) => Promise<boolean>
      }

      export namespace PackageManagerRepository {
        export type DetectResult = {
          packageManager: 'npm' | 'yarn' | 'pnpm'
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:30:17.744Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-20-data-layer-validator-protocol
    type: create_file
    layer: data
    description: Create LayerValidatorRepository protocol
    path: src/data/protocols/layer/layer-validator-repository.ts
    template: >
      export interface LayerValidatorRepository {
        validateImports: (params: LayerValidatorRepository.ValidateParams) => Promise<LayerValidatorRepository.ValidateResult>
      }


      export namespace LayerValidatorRepository {
        export type ValidateParams = {
          code: string
          layer: string
        }

        export type ValidateResult = {
          valid: boolean
          violations: string[]
          warnings: string[]
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:30:22.820Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-21-data-script-validator-protocol
    type: create_file
    layer: data
    description: Create ScriptValidatorRepository protocol
    path: src/data/protocols/script/script-validator-repository.ts
    template: >
      export interface ScriptValidatorRepository {
        validate: (params: ScriptValidatorRepository.ValidateParams) => Promise<ScriptValidatorRepository.ValidateResult>
      }


      export namespace ScriptValidatorRepository {
        export type ValidateParams = {
          script: string
          allowedScripts: string[]
        }

        export type ValidateResult = {
          safe: boolean
          reason?: string
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:30:27.560Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-22-data-validate-template-impl
    type: create_file
    layer: data
    description: Implement DbValidateTemplate use case
    path: src/data/usecases/template/db-validate-template.ts
    template: >
      import { type ValidateTemplate } from
      '@/domain/usecases/validate-template'

      import { type FileSystem } from '@/data/protocols/fs/file-system'

      import { type TemplateValidatorRepository } from
      '@/data/protocols/template/template-validator-repository'


      export class DbValidateTemplate implements ValidateTemplate {
        constructor (
          private readonly fileSystem: FileSystem,
          private readonly validator: TemplateValidatorRepository
        ) {}

        async validate (params: ValidateTemplate.Params): Promise<ValidateTemplate.Result> {
          const { implementationPath } = params

          const content = await this.fileSystem.readFile(implementationPath)
          const result = await this.validator.validateSchema({ content })

          return {
            valid: result.valid,
            errors: result.errors,
            warnings: result.warnings
          }
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:30:32.447Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-23-data-run-quality-check-impl
    type: create_file
    layer: data
    description: Implement DbRunQualityCheck use case
    path: src/data/usecases/quality/db-run-quality-check.ts
    template: >
      import { type RunQualityCheck } from '@/domain/usecases/run-quality-check'

      import { type QualityCheckRepository } from
      '@/data/protocols/quality/quality-check-repository'

      import { type Logger } from '@/data/protocols/log/logger'


      export class DbRunQualityCheck implements RunQualityCheck {
        constructor (
          private readonly qualityCheck: QualityCheckRepository,
          private readonly logger: Logger
        ) {}

        async run (params: RunQualityCheck.Params): Promise<RunQualityCheck.Result> {
          const { config } = params

          let lintResult = { passed: true, output: '' }
          let testResult = { passed: true, output: '' }

          if (config.qualityChecks.lint) {
            this.logger.info('Running lint check...')
            lintResult = await this.qualityCheck.runLint(config.qualityChecks.lintCommand)
          }

          if (config.qualityChecks.test) {
            this.logger.info('Running tests...')
            testResult = await this.qualityCheck.runTest(config.qualityChecks.testCommand)
          }

          return {
            lint: lintResult,
            test: testResult,
            overallPassed: lintResult.passed && testResult.passed
          }
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:30:37.423Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-24-data-calculate-score-impl
    type: create_file
    layer: data
    description: Implement DbCalculateScore use case
    path: src/data/usecases/rlhf/db-calculate-score.ts
    template: >
      import { type CalculateScore } from '@/domain/usecases/calculate-score'

      import { type RLHFRepository } from
      '@/data/protocols/rlhf/rlhf-repository'


      export class DbCalculateScore implements CalculateScore {
        constructor (
          private readonly rlhfRepository: RLHFRepository
        ) {}

        async calculate (params: CalculateScore.Params): Promise<CalculateScore.Result> {
          const { step, success, output, layerInfo } = params

          const result = await this.rlhfRepository.calculateScore({
            stepType: step.type,
            success,
            layerInfo,
            output
          })

          await this.rlhfRepository.saveScore({
            stepId: step.id,
            score: result.score,
            timestamp: new Date().toISOString()
          })

          return { score: result.score }
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:30:42.424Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-25-data-rollback-step-impl
    type: create_file
    layer: data
    description: Implement DbRollbackStep use case
    path: src/data/usecases/git/db-rollback-step.ts
    template: >
      import { type RollbackStep } from '@/domain/usecases/rollback-step'

      import { type GitRepository } from '@/data/protocols/git/git-repository'

      import { type FileSystem } from '@/data/protocols/fs/file-system'

      import { type Logger } from '@/data/protocols/log/logger'


      export class DbRollbackStep implements RollbackStep {
        constructor (
          private readonly gitRepository: GitRepository,
          private readonly fileSystem: FileSystem,
          private readonly logger: Logger
        ) {}

        async rollback (params: RollbackStep.Params): Promise<RollbackStep.Result> {
          const { step } = params

          try {
            this.logger.info('Rolling back changes...')

            await this.gitRepository.resetHead()

            if (step.path && await this.fileSystem.pathExists(step.path)) {
              await this.gitRepository.checkoutFile(step.path)
            }

            return {
              success: true,
              message: 'Rollback completed successfully'
            }
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error)
            return {
              success: false,
              message: `Rollback failed: ${message}`
            }
          }
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:31:23.933Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-26-data-check-git-safety-impl
    type: create_file
    layer: data
    description: Implement DbCheckGitSafety use case
    path: src/data/usecases/git/db-check-git-safety.ts
    template: >
      import { type CheckGitSafety } from '@/domain/usecases/check-git-safety'

      import { type GitRepository } from '@/data/protocols/git/git-repository'

      import { type Logger } from '@/data/protocols/log/logger'


      export class DbCheckGitSafety implements CheckGitSafety {
        constructor (
          private readonly gitRepository: GitRepository,
          private readonly logger: Logger
        ) {}

        async check (params: CheckGitSafety.Params): Promise<CheckGitSafety.Result> {
          const { config } = params

          const statusOutput = await this.gitRepository.status()
          const hasUncommittedChanges = statusOutput.trim().length > 0

          if (hasUncommittedChanges) {
            this.logger.warn('Uncommitted changes detected')

            if (!config.interactiveSafety) {
              this.logger.info('Non-interactive mode: continuing after delay')
              return {
                safe: true,
                hasUncommittedChanges,
                userConfirmed: false
              }
            }
          }

          return {
            safe: true,
            hasUncommittedChanges,
            userConfirmed: true
          }
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:31:28.706Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-27-data-validate-script-impl
    type: create_file
    layer: data
    description: Implement DbValidateScript use case
    path: src/data/usecases/script/db-validate-script.ts
    template: >
      import { type ValidateScript } from '@/domain/usecases/validate-script'

      import { type ScriptValidatorRepository } from
      '@/data/protocols/script/script-validator-repository'


      export class DbValidateScript implements ValidateScript {
        constructor (
          private readonly validator: ScriptValidatorRepository
        ) {}

        async validate (params: ValidateScript.Params): Promise<ValidateScript.Result> {
          const { script, allowedScripts = [] } = params

          return await this.validator.validate({
            script,
            allowedScripts
          })
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:33:39.075Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-28-data-detect-package-manager-impl
    type: create_file
    layer: data
    description: Implement DbDetectPackageManager use case
    path: src/data/usecases/package/db-detect-package-manager.ts
    template: >
      import { type DetectPackageManager } from
      '@/domain/usecases/detect-package-manager'

      import { type PackageManagerRepository } from
      '@/data/protocols/package/package-manager-repository'


      export class DbDetectPackageManager implements DetectPackageManager {
        constructor (
          private readonly repository: PackageManagerRepository
        ) {}

        async detect (): Promise<DetectPackageManager.Result> {
          const result = await this.repository.detect()

          const commands: Record<string, string> = {
            npm: 'npm run',
            yarn: 'yarn',
            pnpm: 'pnpm'
          }

          return {
            packageManager: result.packageManager,
            command: commands[result.packageManager]
          }
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:33:43.811Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-29-data-validate-layer-impl
    type: create_file
    layer: data
    description: Implement DbValidateLayer use case
    path: src/data/usecases/layer/db-validate-layer.ts
    template: >
      import { type ValidateLayer } from '@/domain/usecases/validate-layer'

      import { type LayerValidatorRepository } from
      '@/data/protocols/layer/layer-validator-repository'


      export class DbValidateLayer implements ValidateLayer {
        constructor (
          private readonly validator: LayerValidatorRepository
        ) {}

        async validate (params: ValidateLayer.Params): Promise<ValidateLayer.Result> {
          const { step, layerInfo } = params

          if (!step.template) {
            return { valid: true, warnings: [], violations: [] }
          }

          return await this.validator.validateImports({
            code: step.template,
            layer: layerInfo.layer
          })
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:33:48.577Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-30-data-execute-validation-script-impl
    type: create_file
    layer: data
    description: Implement DbExecuteValidationScript use case
    path: src/data/usecases/script/db-execute-validation-script.ts
    template: >
      import { type ExecuteValidationScript } from
      '@/domain/usecases/execute-validation-script'

      import { type ScriptExecutorRepository } from
      '@/data/protocols/script/script-executor-repository'

      import { type Logger } from '@/data/protocols/log/logger'


      export class DbExecuteValidationScript implements ExecuteValidationScript
      {
        constructor (
          private readonly executor: ScriptExecutorRepository,
          private readonly logger: Logger
        ) {}

        async execute (params: ExecuteValidationScript.Params): Promise<ExecuteValidationScript.Result> {
          const { scriptContent, stepId } = params

          this.logger.info(`Running validation script for step: ${stepId}`)

          return await this.executor.execute({
            scriptContent,
            stepId
          })
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T10:33:53.351Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-31-infra-yaml-template-validator
    type: create_file
    layer: infra
    description: Create YAML template validator adapter
    path: src/infra/template/yaml-template-validator.ts
    template: >
      import { type TemplateValidatorRepository } from
      '@/data/protocols/template/template-validator-repository'

      import * as yaml from 'yaml'


      export class YamlTemplateValidator implements TemplateValidatorRepository
      {
        async validateSchema (params: TemplateValidatorRepository.ValidateParams): Promise<TemplateValidatorRepository.ValidateResult> {
          const { content } = params
          const errors: string[] = []
          const warnings: string[] = []

          try {
            const parsed = yaml.parse(content)

            if (!parsed.steps || !Array.isArray(parsed.steps)) {
              errors.push('Missing or invalid steps array')
            }

            if (parsed.steps) {
              parsed.steps.forEach((step: unknown, index: number) => {
                if (typeof step !== 'object' || step === null) {
                  errors.push(`Step ${index} is not an object`)
                  return
                }

                const s = step as Record<string, unknown>
                if (!s.id) errors.push(`Step ${index}: missing id`)
                if (!s.type) errors.push(`Step ${index}: missing type`)
                if (!s.path && s.type === 'create_file') {
                  errors.push(`Step ${index}: missing path for create_file`)
                }
              })
            }

            return {
              valid: errors.length === 0,
              errors,
              warnings
            }
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error)
            return {
              valid: false,
              errors: [`YAML parsing error: ${message}`],
              warnings
            }
          }
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T13:09:18.136Z (1ms).
      RLHF Score: 1. No validation script provided."
  - id: step-32-infra-npm-quality-check
    type: create_file
    layer: infra
    description: Create NPM quality check adapter
    path: src/infra/quality/npm-quality-check-adapter.ts
    template: >
      import { type QualityCheckRepository } from
      '@/data/protocols/quality/quality-check-repository'

      import { $ } from 'zx'


      export class NpmQualityCheckAdapter implements QualityCheckRepository {
        async runLint (command: string): Promise<QualityCheckRepository.CheckResult> {
          try {
            $.verbose = false
            const result = await $`npm run ${command}`
            $.verbose = true

            return {
              passed: true,
              output: result.stdout + result.stderr
            }
          } catch (error) {
            $.verbose = true
            const output = this.extractOutput(error)

            return {
              passed: false,
              output
            }
          }
        }

        async runTest (command: string): Promise<QualityCheckRepository.CheckResult> {
          try {
            $.verbose = false
            const result = await $`npm run ${command}`
            $.verbose = true

            return {
              passed: true,
              output: result.stdout + result.stderr
            }
          } catch (error) {
            $.verbose = true
            const output = this.extractOutput(error)

            return {
              passed: false,
              output
            }
          }
        }

        private extractOutput (error: unknown): string {
          if (typeof error === 'object' && error !== null) {
            const err = error as { stdout?: string; stderr?: string }
            return (err.stdout || '') + (err.stderr || '')
          }
          return String(error)
        }
      }
    rlhf_score: 1
    status: SUCCESS
    execution_log: "Action completed successfully at 2025-10-02T13:09:23.273Z (0ms).
      RLHF Score: 1. No validation script provided."
  - id: step-33-infra-json-rlhf
    type: create_file
    layer: infra
    description: Create JSON RLHF adapter
    path: src/infra/rlhf/json-rlhf-adapter.ts
    template: >
      import { type RLHFRepository } from
      '@/data/protocols/rlhf/rlhf-repository'

      import { type FileSystem } from '@/data/protocols/fs/file-system'


      export class JsonRLHFAdapter implements RLHFRepository {
        private scores: Map<string, number> = new Map()

        constructor (
          private readonly fileSystem: FileSystem
        ) {}

        async calculateScore (params: RLHFRepository.ScoreParams): Promise<RLHFRepository.ScoreResult> {
          const { success, layerInfo } = params

          let score = success ? 1 : 0

          if (layerInfo) {
            if (layerInfo.layer === 'domain' || layerInfo.layer === 'main') {
              score = success ? 1.2 : -0.5
            }
          }

          return { score }
        }

        async saveScore (params: RLHFRepository.SaveParams): Promise<void> {
          const { stepId, score } = params
          this.scores.set(stepId, score)
        }
      }
    rlhf_score: null
    status: null
    execution_log: null
  - id: step-34-infra-yaml-config
    type: create_file
    layer: infra
    description: Create YAML config adapter
    path: src/infra/config/yaml-config-adapter.ts
    template: >
      import { type ConfigRepository } from
      '@/data/protocols/config/config-repository'

      import { type CommitConfig } from '@/domain/models/commit-config'

      import { type FileSystem } from '@/data/protocols/fs/file-system'

      import * as yaml from 'yaml'


      export class YamlConfigAdapter implements ConfigRepository {
        constructor (
          private readonly fileSystem: FileSystem
        ) {}

        async load (configPath: string): Promise<ConfigRepository.LoadResult> {
          try {
            const exists = await this.fileSystem.pathExists(configPath)

            if (!exists) {
              return {
                config: null,
                errors: ['Config file not found']
              }
            }

            const content = await this.fileSystem.readFile(configPath)
            const parsed = yaml.parse(content)

            const config: CommitConfig = {
              enabled: parsed.commit?.enabled ?? true,
              qualityChecks: {
                lint: parsed.commit?.quality_checks?.lint ?? true,
                lintCommand: parsed.commit?.quality_checks?.lint_command ?? 'lint',
                test: parsed.commit?.quality_checks?.test ?? true,
                testCommand: parsed.commit?.quality_checks?.test_command ?? 'test --run'
              },
              conventionalCommits: {
                enabled: parsed.commit?.conventional_commits?.enabled ?? true,
                typeMapping: parsed.commit?.conventional_commits?.type_mapping ?? {}
              },
              coAuthor: parsed.commit?.co_author ?? 'Claude <noreply@anthropic.com>',
              emoji: parsed.commit?.emoji ?? true,
              interactiveSafety: parsed.commit?.interactive_safety ?? true
            }

            return { config, errors: [] }
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error)
            return {
              config: null,
              errors: [`Failed to load config: ${message}`]
            }
          }
        }
      }
  - id: step-35-infra-file-audit
    type: create_file
    layer: infra
    description: Create file audit adapter
    path: src/infra/audit/file-audit-adapter.ts
    template: >
      import { type AuditRepository } from
      '@/data/protocols/audit/audit-repository'

      import { type AuditLogEntry } from '@/domain/models/audit-log'

      import { type FileSystem } from '@/data/protocols/fs/file-system'


      export class FileAuditAdapter implements AuditRepository {
        private entries: AuditLogEntry[] = []

        constructor (
          private readonly fileSystem: FileSystem,
          private readonly logPath: string
        ) {}

        async log (entry: AuditLogEntry): Promise<void> {
          this.entries.push(entry)

          if (this.entries.length > 100) {
            this.entries = this.entries.slice(-100)
          }

          try {
            const content = JSON.stringify(this.entries, null, 2)
            await this.fileSystem.writeFile(this.logPath, content)
          } catch {
            // Ignore write errors
          }
        }

        async getRecent (limit: number): Promise<AuditLogEntry[]> {
          return this.entries.slice(-limit)
        }
      }
  - id: step-36-infra-bash-script-executor
    type: create_file
    layer: infra
    description: Create bash script executor adapter
    path: src/infra/script/bash-script-executor.ts
    template: >
      import { type ScriptExecutorRepository } from
      '@/data/protocols/script/script-executor-repository'

      import { type FileSystem } from '@/data/protocols/fs/file-system'

      import { $ } from 'zx'

      import * as os from 'os'

      import * as path from 'path'


      export class BashScriptExecutor implements ScriptExecutorRepository {
        constructor (
          private readonly fileSystem: FileSystem
        ) {}

        async execute (params: ScriptExecutorRepository.ExecuteParams): Promise<ScriptExecutorRepository.ExecuteResult> {
          const { scriptContent, stepId } = params

          const tempScriptPath = path.join(os.tmpdir(), `step-${stepId}.sh`)

          try {
            await this.fileSystem.writeFile(tempScriptPath, scriptContent)

            $.verbose = false
            const result = await $`bash ${tempScriptPath}`
            $.verbose = true

            await this.fileSystem.remove(tempScriptPath)

            return {
              output: result.stdout + result.stderr,
              success: true
            }
          } catch (error) {
            $.verbose = true

            try {
              await this.fileSystem.remove(tempScriptPath)
            } catch {
              // Ignore cleanup errors
            }

            const message = error instanceof Error ? error.message : String(error)
            return {
              output: message,
              success: false
            }
          }
        }
      }
  - id: step-37-infra-enhanced-git-repository
    type: create_file
    layer: infra
    description: Extend ZxGitRepository with rollback methods
    path: src/infra/git/enhanced-git-repository.ts
    template: |
      import { type GitRepository } from '@/data/protocols/git/git-repository'
      import { $ } from 'zx'

      export class EnhancedGitRepository implements GitRepository {
        async add (path: string): Promise<void> {
          await $`git add ${path}`
        }

        async commit (message: string): Promise<void> {
          await $`git commit -m ${message}`
        }

        async getHeadHash (): Promise<string> {
          const result = await $`git rev-parse --short HEAD`
          return result.stdout.trim()
        }

        async status (): Promise<string> {
          const result = await $`git status --porcelain`
          return result.stdout.trim()
        }

        async resetHead (): Promise<void> {
          await $`git reset HEAD`
        }

        async checkoutFile (path: string): Promise<void> {
          await $`git checkout HEAD -- ${path}`
        }
      }
  - id: step-38-infra-package-manager-detector
    type: create_file
    layer: infra
    description: Create package manager detector
    path: src/infra/package/package-manager-detector.ts
    template: >
      import { type PackageManagerRepository } from
      '@/data/protocols/package/package-manager-repository'

      import { type FileSystem } from '@/data/protocols/fs/file-system'

      import { $ } from 'zx'


      export class PackageManagerDetector implements PackageManagerRepository {
        constructor (
          private readonly fileSystem: FileSystem
        ) {}

        async detect (): Promise<PackageManagerRepository.DetectResult> {
          if (await this.fileSystem.pathExists('pnpm-lock.yaml')) {
            if (await this.isInstalled('pnpm')) {
              return { packageManager: 'pnpm' }
            }
          }

          if (await this.fileSystem.pathExists('yarn.lock')) {
            if (await this.isInstalled('yarn')) {
              return { packageManager: 'yarn' }
            }
          }

          return { packageManager: 'npm' }
        }

        async isInstalled (pm: string): Promise<boolean> {
          try {
            $.verbose = false
            await $`which ${pm}`
            $.verbose = true
            return true
          } catch {
            $.verbose = true
            return false
          }
        }
      }
  - id: step-39-infra-layer-validator
    type: create_file
    layer: infra
    description: Create layer validator
    path: src/infra/layer/layer-validator.ts
    template: >
      import { type LayerValidatorRepository } from
      '@/data/protocols/layer/layer-validator-repository'


      export class LayerValidator implements LayerValidatorRepository {
        private readonly forbiddenImports: Record<string, string[]> = {
          domain: ['@/data', '@/infra', '@/presentation', '@/validation', '@/main'],
          data: ['@/infra', '@/presentation', '@/validation', '@/main'],
          infra: ['@/presentation', '@/validation', '@/main'],
          presentation: ['@/data', '@/infra', '@/main'],
          validation: ['@/domain', '@/data', '@/infra', '@/main']
        }

        async validateImports (params: LayerValidatorRepository.ValidateParams): Promise<LayerValidatorRepository.ValidateResult> {
          const { code, layer } = params
          const violations: string[] = []
          const warnings: string[] = []

          const forbidden = this.forbiddenImports[layer] || []

          for (const forbiddenPath of forbidden) {
            if (code.includes(`from '${forbiddenPath}`) || code.includes(`from "${forbiddenPath}`)) {
              violations.push(`Layer '${layer}' cannot import from '${forbiddenPath}'`)
            }
          }

          if (layer === 'domain') {
            if (code.match(/import.*from\s+['"](?!@\/domain)[^'"]+['"]/)) {
              warnings.push('Domain layer should only import from @/domain')
            }
          }

          return {
            valid: violations.length === 0,
            violations,
            warnings
          }
        }
      }
  - id: step-40-infra-script-validator
    type: create_file
    layer: infra
    description: Create script validator
    path: src/infra/security/script-validator.ts
    template: >
      import { type ScriptValidatorRepository } from
      '@/data/protocols/script/script-validator-repository'


      export class ScriptValidator implements ScriptValidatorRepository {
        private readonly dangerousKeywords = [
          'rm', 'rmdir', 'del', 'delete',
          'chmod', 'chown', 'sudo', 'su',
          'curl', 'wget', 'nc', 'ssh',
          'kill', 'killall', 'eval', 'exec'
        ]

        async validate (params: ScriptValidatorRepository.ValidateParams): Promise<ScriptValidatorRepository.ValidateResult> {
          const { script, allowedScripts } = params

          if (allowedScripts.includes(script)) {
            return { safe: true }
          }

          const safePattern = /^[a-zA-Z0-9:\-\s]+$/
          if (!safePattern.test(script)) {
            return {
              safe: false,
              reason: 'Script contains invalid characters'
            }
          }

          for (const keyword of this.dangerousKeywords) {
            if (script.includes(keyword)) {
              return {
                safe: false,
                reason: `Script contains dangerous keyword: ${keyword}`
              }
            }
          }

          return { safe: true }
        }
      }
  - id: step-41-presentation-lint-error
    type: create_file
    layer: presentation
    description: Create LintError class
    path: src/presentation/errors/lint-error.ts
    template: |
      export class LintError extends Error {
        constructor (message: string) {
          super(message)
          this.name = 'LintError'
        }
      }
  - id: step-42-presentation-test-error
    type: create_file
    layer: presentation
    description: Create TestError class
    path: src/presentation/errors/test-error.ts
    template: |
      export class TestError extends Error {
        constructor (message: string) {
          super(message)
          this.name = 'TestError'
        }
      }
  - id: step-43-presentation-invalid-script-error
    type: create_file
    layer: presentation
    description: Create InvalidScriptError class
    path: src/presentation/errors/invalid-script-error.ts
    template: |
      export class InvalidScriptError extends Error {
        constructor (public readonly script: string, reason: string) {
          super(`Invalid script "${script}": ${reason}`)
          this.name = 'InvalidScriptError'
        }
      }
  - id: step-44-presentation-layer-violation-error
    type: create_file
    layer: presentation
    description: Create LayerViolationError class
    path: src/presentation/errors/layer-violation-error.ts
    template: |
      export class LayerViolationError extends Error {
        constructor (
          public readonly layer: string,
          public readonly violations: string[]
        ) {
          super(`Layer violation in ${layer}: ${violations.join(', ')}`)
          this.name = 'LayerViolationError'
        }
      }
  - id: step-45-main-validate-template-factory
    type: create_file
    layer: main
    description: Create validate template factory
    path: src/main/factories/usecases/validate-template-factory.ts
    template: >
      import { type ValidateTemplate } from
      '@/domain/usecases/validate-template'

      import { DbValidateTemplate } from
      '@/data/usecases/template/db-validate-template'

      import { FsExtraAdapter } from '@/infra/fs/fs-extra-adapter'

      import { YamlTemplateValidator } from
      '@/infra/template/yaml-template-validator'


      export const makeValidateTemplate = (): ValidateTemplate => {
        const fileSystem = new FsExtraAdapter()
        const validator = new YamlTemplateValidator()
        return new DbValidateTemplate(fileSystem, validator)
      }
  - id: step-46-main-run-quality-check-factory
    type: create_file
    layer: main
    description: Create run quality check factory
    path: src/main/factories/usecases/run-quality-check-factory.ts
    template: >
      import { type RunQualityCheck } from '@/domain/usecases/run-quality-check'

      import { DbRunQualityCheck } from
      '@/data/usecases/quality/db-run-quality-check'

      import { NpmQualityCheckAdapter } from
      '@/infra/quality/npm-quality-check-adapter'

      import { ChalkLoggerAdapter } from '@/infra/log/chalk-logger-adapter'


      export const makeRunQualityCheck = (): RunQualityCheck => {
        const qualityCheck = new NpmQualityCheckAdapter()
        const logger = new ChalkLoggerAdapter()
        return new DbRunQualityCheck(qualityCheck, logger)
      }
  - id: step-47-main-calculate-score-factory
    type: create_file
    layer: main
    description: Create calculate score factory
    path: src/main/factories/usecases/calculate-score-factory.ts
    template: |
      import { type CalculateScore } from '@/domain/usecases/calculate-score'
      import { DbCalculateScore } from '@/data/usecases/rlhf/db-calculate-score'
      import { JsonRLHFAdapter } from '@/infra/rlhf/json-rlhf-adapter'
      import { FsExtraAdapter } from '@/infra/fs/fs-extra-adapter'

      export const makeCalculateScore = (): CalculateScore => {
        const fileSystem = new FsExtraAdapter()
        const rlhfRepository = new JsonRLHFAdapter(fileSystem)
        return new DbCalculateScore(rlhfRepository)
      }
  - id: step-48-main-rollback-step-factory
    type: create_file
    layer: main
    description: Create rollback step factory
    path: src/main/factories/usecases/rollback-step-factory.ts
    template: >
      import { type RollbackStep } from '@/domain/usecases/rollback-step'

      import { DbRollbackStep } from '@/data/usecases/git/db-rollback-step'

      import { EnhancedGitRepository } from
      '@/infra/git/enhanced-git-repository'

      import { FsExtraAdapter } from '@/infra/fs/fs-extra-adapter'

      import { ChalkLoggerAdapter } from '@/infra/log/chalk-logger-adapter'


      export const makeRollbackStep = (): RollbackStep => {
        const gitRepository = new EnhancedGitRepository()
        const fileSystem = new FsExtraAdapter()
        const logger = new ChalkLoggerAdapter()
        return new DbRollbackStep(gitRepository, fileSystem, logger)
      }
  - id: step-49-main-check-git-safety-factory
    type: create_file
    layer: main
    description: Create check git safety factory
    path: src/main/factories/usecases/check-git-safety-factory.ts
    template: >
      import { type CheckGitSafety } from '@/domain/usecases/check-git-safety'

      import { DbCheckGitSafety } from '@/data/usecases/git/db-check-git-safety'

      import { EnhancedGitRepository } from
      '@/infra/git/enhanced-git-repository'

      import { ChalkLoggerAdapter } from '@/infra/log/chalk-logger-adapter'


      export const makeCheckGitSafety = (): CheckGitSafety => {
        const gitRepository = new EnhancedGitRepository()
        const logger = new ChalkLoggerAdapter()
        return new DbCheckGitSafety(gitRepository, logger)
      }
  - id: step-50-main-enhanced-executor
    type: create_file
    layer: main
    description: Create enhanced executor composition
    path: src/main/enhanced-executor.ts
    template: >
      import { makeExecutePlan } from
      './factories/usecases/db-execute-plan-factory'

      import { makeValidateTemplate } from
      './factories/usecases/validate-template-factory'

      import { makeRunQualityCheck } from
      './factories/usecases/run-quality-check-factory'

      import { makeCalculateScore } from
      './factories/usecases/calculate-score-factory'

      import { makeRollbackStep } from
      './factories/usecases/rollback-step-factory'

      import { makeCheckGitSafety } from
      './factories/usecases/check-git-safety-factory'


      export const makeEnhancedExecutor = () => {
        return {
          executePlan: makeExecutePlan(),
          validateTemplate: makeValidateTemplate(),
          runQualityCheck: makeRunQualityCheck(),
          calculateScore: makeCalculateScore(),
          rollbackStep: makeRollbackStep(),
          checkGitSafety: makeCheckGitSafety()
        }
      }
